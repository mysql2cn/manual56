# 22.6.8 Python连接器 API 参考

### 22.6.8 Python连接器 API 参考

本章节包含Python连接器的公共API参考。其中的示例可以在Python 2.7,Python 3.1或更高的版本中运行。如果不涉及新版本Python中的特性，也可能在旧版本中运行(例如Python 2.4)。打个比方，使用`as`关键字的异常处理是在Python 2.6中引入的，不会在Python 2.4起作用。

下面总结了`mysql.connector`包的模块，目前，只记录了对最终用户最有用的模块，类和方法。

    mysql.connector
      errorcode
      errors
      connection
      constants
      conversion
      cursor
      dbapi
      locales
        eng
          client_error
      protocol
      utils


#### 22.6.8.1 mysql.connector模块

`mysql.connector`模块提供高级的方法和属性。

##### 22.6.8.1.1 `mysql.connector.connect()`方法

该方法与MySQL服务器连接，建立对话。如果没有指定参数，它使用已经配置的或者默认值。可接受的完整参数列表，参见：[章节 22.6.6 Python连接器的连接参数][22.06.06]。

与MySQL服务器的建立连接，既可以使用`mysql.connector.connect()`方法，也可以使用`mysql.connector.MySQLConnection()`类：

    cnx = mysql.connector.connect(user='joe', database='test')
    cnx = MySQLConnection(user='joe', database='test')

对于连接方法和属性的描述，请参见：[章节 22.6.8.2 connection.MySQLConnection类][22.06.08.02]

##### 22.6.8.1.2 `mysql.connector.apilevel`属性

该属性是字符串，表示支持的DB API级别：

    >>> mysql.connector.apilevel
    '2.0'

##### 22.6.8.1.3 `mysql.connector.paramstyle`属性

该属性为字符串，表示Python连接器的默认参数类型：

    >>> mysql.connector.paramstyle
    'pyformat'

##### 22.6.8.1.4 `mysql.connector.threadsafety`属性

该属性为整型，表示Python连接器线程安全的支持级别：

    >>> mysql.connector.threadsafety
    1

##### 22.6.8.1.5 `mysql.connector.__version__`属性

该属性为字符串，表示Python连接器的版本，在版本1.1.0的Python连机器中可用：

    >>> mysql.connector.__version__
    '1.1.0'


##### 22.6.8.1.6 `mysql.connector.__version_info__`属性

该属性为数组，表示Python连接器的版本。在版本1.1.0的Python连机器中可用：

    >>> mysql.connector.__version_info__
    (1, 1, 0, 'a', 0)

#### 22.6.8.2 connection.MySQLConnection类

`MySQLConnection`类用于打开和管理到MySQL服务器的连接。也被用于发送命令和SQL语句，以及读取结果。

##### 22.6.8.2.1 `connection.MySQLConnection(**kwargs)`容器

`MySQLConnection`容器对属性进行初始化，当至少一个选项被传入时，它就试图建立到MySQL服务器的连接。

可接受的完整参数列表，参见：[章节 22.6.6 Python连接器的连接参数][22.06.06]。


##### 22.6.8.2.2 `MySQLConnection.close()`方法

语法：
    cnx.close()

`close()`是`disconnect()`的同义词，参见[章节 22.6.8.2.19 MySQLConnection.disconnect()方法][22.06.08.02.19]。

对于从连接池中获得的连接，`close()`并不是真正的关闭，而是将他返回到连接池，并对后续的连接请求提供服务。参见[章节 22.6.7.1 Python连接器的连接池][22.06.07.01]。
 
##### 22.6.8.2.3 `MySQLConnection.commit()`方法

该方法给MySQL服务器发送一个`COMMIT`语句，提交当前的事务。由于在默认情况下Python连接器并不自动提交事务，所以使用事务型存储引擎时，在每个修改表中数据的事务中调用该方法提交事务非常重要。

    >>> cursor.execute("INSERT INTO employees (first_name) VALUES (%s)", ('Jane'))
    >>> cnx.commit()

关于取消的操作，参见[rollback][22.06.08.02.28]方法。

##### 22.6.8.2.4 `MySQLConnection.config(**kwargs)`方法

语法：

    cnx.config(**kwargs)

在`MySQLConnection`实例被实例化后，配置`MySQLConnection`。可接受的完整参数列表，参见：[章节 22.6.6 Python连接器的连接参数][22.06.06]。

参数：

* `kwargs`：配置参数。

可以使用`config()`方法来变更用户名，然后调用`reconnect()`，如示例所示：

示例：

    cnx = mysql.connector.connect(user='joe', database='test')
    # Connected as 'joe'
    cnx.config(user='jane')
    cnx.reconnect()
    # Now connected as 'jane'

对于从连接池中获得的连接，config()会引发异常。参见：[章节 22.6.7.1 Python连接器的连接池][22.06.07.01]。


##### 22.6.8.2.5 `MySQLConnection.connect()`方法

语法：

    MySQLConnection.connect(**kwargs)

该方法与MySQL服务器连接，建立对话。如果没有指定参数，它使用已经配置的或者默认值。可接受的完整参数列表，参见：[章节 22.6.6 Python连接器的连接参数][22.06.06]。

参数：

* `kwargs`：配置参数。

示例：

    cnx = MySQLConnection(user='joe', database='test') 

对于从连接池中获得的连接，他的连接对象类是`PooledMySQLConnection`。来自连接池和非连接池的连接是不同的，参见[章节 22.6.7.1 Python连接器的连接池][22.06.07.01]。


##### 22.6.8.2.6 `MySQLConnection.cursor(buffered=None, raw=None, cursor_class=None)`方法

该方法根据传入的参数，返回一个`MySQLCursor()`对象，或者它的子类。  
当`buffered`为`True`时，游标在操作被执行后获取所有的行。这在返回小结果集的查询时非常有用。在获取数据时，设置`raw`可以跳过MySQL数据类型到Python类型的转换。在你想获得高性能，或者你想自己转换时,`raw`是很有用的。  
可以用`cursor_class`参数传入类，用于实例化一个新的游标。它必须是`cursor.CursorBase`的子类。  
返回的对象由`buffered`和`raw`参数的组合决定。

* `buffered`和`raw`都不存在：`cursor.MySQLCursor`
* 存在`buffered`，不存在`raw`：`cursor.MySQLCursorBuffered`
* `buffered`和`raw`都存在：`cursor.MySQLCursorBufferedRaw` 
* 不存在`buffered`，存在`raw`：`cursor.MySQLCursorRaw`

返回一个`CursorBase`实例。


##### 22.6.8.2.7 `MySQLConnection.cmd_change_user(username='', password='', database='', charset=33)`方法

使用`username`和`password`改变用户。它还被用户指定`database`成为默认(当前)数据库。使用`charset`参数也可以改变字符集。

返回一个包含`OK`包信息的字典。


##### 22.6.8.2.8 `MySQLConnection.cmd_debug()`方法

通知服务器将调试信息写入错误日志。连接的用户必须具有[超级][06.02.01]权限。

返回一个包含`OK`包信息的字典。

##### 22.6.8.2.9 `MySQLConnection.cmd_init_db(database)`方法

该方法用于指定默认(当前)数据库。在子查询中，如果没有显式的指明数据库，则该数据库作为默认的数据库来给表引用。

返回一个包含`OK`包信息的字典。

##### 22.6.8.2.10 `MySQLConnection.cmd_ping()`方法

检测到服务器的连接是否正常。

该方法不能直接使用，可用[ping()][22.06.08.02.26]或[is_connected()][22.06.08.02.24]替代。

返回一个包含`OK`包信息的字典。

##### 22.6.8.2.11 `MySQLConnection.cmd_process_info()`方法

该方法引起 NotSupportedError 异常。使用`SHOW PROCESSLIST`语句或者查询数据库中的`INFORMATION_SCHEMA`表来替代它。

##### 22.6.8.2.12 `MySQLConnection.cmd_process_kill(mysql_pid)`方法

请求服务器去杀死通过`mysql_id`指定的线程，尽管他有效，但是最好使用`KILL`语句。

返回一个包含`OK`包信息的字典。

下面的两行具有同样的效果：

    >>> cnx.cmd_process_kill(123)
    >>> cnx.cmd_query('KILL 123')

##### 22.6.8.2.13 `MySQLConnection.cmd_query(statement)`方法

该方法发送给定的语句(`statement`)到MySQL服务器并返回结果。如果要发送多条语句，使用[`cmd_query_iter()`][22.06.08.02.14]来代替它。

返回的字典包含的信息由执行的查询类型决定。如果是[SELECT][13.02.09]语句，返回的结果是关于列的信息，其他的语句返回的字典包含OK或EOF包信息。

从MySQL服务器接收的错误将引发一个异常。返回多个结果集时将引起
`InterfaceError`。

返回一个字典。

##### 22.6.8.2.14 `MySQLConnection.cmd_query_iter(statement)`方法

类似于[cmd_query()][22.06.08.13]方法，但是它遍历结果返回生成的对象。使用`cmd_query_iter()`发送多条语句，并以分号分割。

下面的示例演示了在发送多条语句后，遍历结果集：

    statement = 'SELECT 1; INSERT INTO t1 VALUES (); SELECT 2'
    for result in cnx.cmd_query_iter(statement):
      if 'columns' in result:
        columns = result['columns']
        rows = cnx.get_rows()
      else:
        # do something useful with INSERT result

返回生成的对象。


##### 22.6.8.2.15 `MySQLConnection.cmd_quit()`方法

该方法发送`QUIT`命令到服务器，关闭当前的连接。由于MySQL没有响应，发送的包被返回了。

##### 22.6.8.2.16 `MySQLConnection.cmd_refresh(options)`方法

该方法刷新表或者缓存，或者重置复制服务器信息。连接的用户必须具有`RELOAD`权限。

`options`选项应该是位掩码值(bitmask)，一个通过使用` constants.RefreshOption`类构成的常数。

完整的选项列表，参见:[章节 22.6.8.12 constants.RefreshOption类][22.06.08.12]。

示例：

    >>> from mysql.connector import RefreshOption
    >>> refresh = RefreshOption.LOG | RefreshOption.THREADS
    >>> cnx.cmd_refresh(refresh)

 
##### 22.6.8.2.17 `MySQLConnection.cmd_shutdown()`方法

要求数据库服务器关闭。连接的用户必须具有`SHUTDOWN`权限。

返回一个包含`OK`包信息的字典。

##### 22.6.8.2.18 `MySQLConnection.cmd_statistics()`方法

返回的字典中包含MySQL服务器的正常运行时间和运行的线程数量、问题、重新加载，和打开的表的信息。


##### 22.6.8.2.19 `MySQLConnection.disconnect()`方法

该方法试图发送一个`QUIT`命令，关闭socket。没有异常返回。

MySQLConnection.close()是它的同义词，并且用的更多一些。

##### 22.6.8.2.20 `MySQLConnection.get_row()`方法

此方法检索查询结果集的下一行，返回元组。

通过`get_row()`返回的元组包含：

* 作为元组的行包含的字节对象，如果没有行可用，则返回`None`。
* EOF包作为一个字典，包含`status_flag`和`warning_count`，如果不是最后一行，返回`None`。

[MySQL 游标][22.06.08.05]使用`get_row()`方法来获取行。


##### 22.6.8.2.21 `MySQLConnection.get_rows(count=None)`方法

该方法从查询结果中取得所有的或剩下的行，把作为序列号的行和EOF包信息当做元组返回。count参数可以用来获得行的指定数量。如果没有指定count或者为`None`,所有的行都被获取。

通过`get_rows()`返回的元组包含：

* 元组列表，包含把行数据作为字节对象的元组，如果没有行可用，则返回空列表。
* EOF包，作为一个字典，包含`status_flag`和`warning_count`
。
* [MySQL 游标][22.06.08.05]使用`get_rows()`方法来获取行。

返回元组。

##### 22.6.8.2.22 `MySQLConnection.get_server_info()`方法

该方法返回MySQL服务器的信息，作为一个字符串。比如`5.6.11-log`,没连接时返回`None`。

##### 22.6.8.2.23 `MySQLConnection.get_server_version()`方法

该方法返回MySQL服务器版本的信息，以元组的形式。无连接时返回`None`。

##### 22.6.8.2.24 `MySQLConnection.is_connected()`方法

报告到MySQL服务器的连接是否可用。

该方法通过使用[ping()][22.06.08.02.26]方法来检测到MySQL服务器的连接诶是否可用，但是和`ping()`不同，`is_connected()`在连接可用是返回`True`，否则返回`False`。

##### 22.6.8.2.25 `MySQLConnection.isset_client_flag(flag)`方法

当设置了客户端标志(client flag)时，该方法返回`True`，否则返回`False`。

##### 22.6.8.2.26 `MySQLConnection.ping(attempts=1, delay=0)`方法

检查到MySQL服务器的连接是否还可用。  
当`reconnect`设置为`True`，会通过`reconnect()`方法尝试不止一次的到MySQL服务器的连接。如果想在每次重试之间等待，可使用`delay`参数(以秒为单位)。  
当连接不可用时，`InterfaceError`被触发。使用[is_connected()][22.06.08.02.24]方法来检测连接，但是不触发错误。  
报错时触发`InterfaceError`。

##### 22.6.8.2.27 `MySQLConnection.reconnect(attempts=1, delay=0)`方法

尝试重新连接MySQL服务器。  
`attempts`参数指定尝试连接的次数，`delay`参数是在每次重试之间等待的秒数。  
当你想关闭数据库进行维护，或者认为网络暂时不可用时，可以把重试参数设置的值设置的高一些，延迟也设置长一些。

##### 22.6.8.2.28 `MySQLConnection.rollback()`方法

该方法向MySQL服务器发送`ROLLBACK`语句，取消事务中的所有数据变更。默认情况下，Python连接器不会自动提交事务，当在使用诸如`InnoDB`等事务型存储引擎时取消事务是可行的。

    >>> cursor.execute("INSERT INTO employees (first_name) VALUES (%s)", ('Jane'))
    >>> cnx.rollback()

事务的[提交][commit]参见[commit()][22.06.08.02.03]方法。 

##### 22.6.8.2.29 `MySQLConnection.set_charset_collation(charset=None, collation=None)`方法

该方法设置当前连接的字符集和排序。`charset`参数可以使字符集的名字，或者`constants.CharacterSet`中定义的对应数字。  
当`collation`设置为`None`，默认使用字符集的排序。

在下面的示例中，我们设置字符集为`latin1`，排序为`latin1_swedish_ci`（默认字符集是`latin1`）:

    >>> cnx = mysql.connector.connect(user='scott')
    >>> cnx.set_charset('latin1')

如下,设置给定的排序：

    >>> cnx = mysql.connector.connect(user='scott')
    >>> cnx.set_charset('latin1', 'latin1_general_ci')

##### 22.6.8.2.30 `MySQLConnection.set_client_flags(flags)`方法

该方法为到MySQL服务器的连接设置客户端标志，以整型返回新的值。`flags`参数可以是整数，或者可用客户端标记的序号(参见[constants.ClientFlag类][22.06.08.08])。  
如果`flags`是序号，序号中的每个正数表示设置标记，负号表示不设置。

比如，取消设置`LANG_FLAG`，设置`FOUND_ROWS`:

    >>> from mysql.connector.constants import ClientFlag
    >>> cnx.set_client_flags([ClientFlag.FOUND_ROWS, -ClientFlag.LONG_FLAG])
    >>> cnx.reconnect()

要注意的是，客户端标记仅在连接到MySQL服务器时才被设置或使用。再变更后需要重新连接。

##### 22.6.8.2.31 `MySQLConnection.start_transaction()`方法

该方法开启一个事务，他接收参数表明是否使用一致性快照、使用的事务隔离级别：

    cnx.start_transaction(consistent_snapshot=bool,
                      isolation_level=level)

默认的`consistent_snapshot`值为`False`。默认的`isolation_level`值为`None`，允许使用的值有`READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`和`SERIALIZABLE`'。  
当在事务中再次调用`start_transaction()`会触发`ProgrammingError`。这和在事务中执行[START TRANSACTION][13.03.01]语句，隐式确认当前事务不同。  
使用[in_transaction][22.06.08.02.38]属性来查明当前连接是否有活动的事务。

`start_transaction()`是在Python 1.1.0版本中新增的。

##### 22.6.8.2.32 `MySQLConnection.autocommit`属性

该属性通过`True`和`False`来决定启用和关闭MySQL的自动提交特性。该属性可以被调用，用于检索当前的自动提交设置。  
需要注意的是，通过Python连接器建立的连接，默认是不启用自动提交的。可以使用自动提交参数[connection parameter][22.06.06]来启用。  
当使用诸如`InnoDB`和`NDBCluster`等事务型存储引擎、自动提交特性被关闭时，必须使用[commit][22.06.08.02.03]提交事务。

    >>> cnx.autocommit
    False
    >>> cnx.autocommit = True
    >>> cnx.autocommit
    True

##### 22.6.8.2.33 `MySQLConnection.charset_name`属性

该属性返回用于连接的字符集的字符串，无论是否连接。

##### 22.6.8.2.34 `MySQLConnection.collation_name`属性

该属性返回用于连接的排序的字符串，无论是否连接。

##### 22.6.8.2.35 `MySQLConnection.connection_id`属性

该属性返回当前连接的整型连接ID(线程ID，或者回话ID)，如果无连接返回`None`。

##### 22.6.8.2.36 `MySQLConnection.database`属性

该属性通过执行`USE`语句设置当前(默认)数据库，也可用来检索当前的数据库的名字：

    >>> cnx.database = 'test'
    >>> cnx.database = 'mysql'
    >>> cnx.database
    u'mysql'

返回一个字符串。

##### 22.6.8.2.37 `MySQLConnection.get_warnings`属性

该属性可以通过`False`和`True`值来决定是否自动获取错误。默认值是`False`。该属性也可用来检索当前的警告设置。  
在调试问题时，自动获取错误很有用，游标通过[MySQLCursor.fetchwarnings()][22.06.08.05.09]方法来制造警告：

    >>> cnx.get_warnings = True
    >>> cursor.execute('SELECT "a"+1')
    >>> cursor.fetchall()
    [(1.0,)]
    >>> cursor.fetchwarnings()
    [(u'Warning', 1292, u"Truncated incorrect DOUBLE value: 'a'")]

返回的是`True`和`False`。

##### 22.6.8.2.38 `MySQLConnection.in_transaction`属性

该属性返回`True`和`False`来表明连接中的事务是否是活动的。`True`忽略通过[start_transaction()][22.06.08.02.31]API 调用打开的事务或者执行执行SQL语句，诸如	[START TRANSACTION][13.03.01][BEGIN][13.03.01]打开的事务。

    >>> cnx.start_transaction()
    >>> cnx.in_transaction
    True
    >>> cnx.commit()
    >>> cnx.in_transaction
    False

`in_transaction`添加于MySQL Python 1.1.0版本。

##### 22.6.8.2.39 `MySQLConnection.raise_on_warnings`属性

该属性通过`True`和`False`来决定错误是否触发异常。默认值是`False`。该属性可用来检索当前的异常设置。   
设置`raise_on_warnings`时也要设置`sets get_warnings`,因为警告需要被获取，然后才能触发异常。

要注意的是， 如果你想MySQL服务器把错误直接当做错误，需要设置SQL模式(参见：[章节 22.6.8.2.42 MySQLConnection.sql_mode属性][22.06.08.02.42])。使用事务型存储引擎可以在获取异常时回滚事务。  
在任何异常被触发钱，需要获取所有的结果集。下面的示例演示了在执行查询时，引发了一个警告：

    >>> cnx.raise_on_warnings = True
    >>> cursor.execute('SELECT "a"+1')
    >>> cursor.fetchall()
    ..
    mysql.connector.errors.DataError: 1292: Truncated incorrect DOUBLE value: 'a'

返回的是`True`和`False`。

##### 22.6.8.2.40 `MySQLConnection.server_host`属性

该只读的属性返回连接到MySQL服务器的主机名和IP地址。  
返回的是字符串。
 
##### 22.6.8.2.41 `MySQLConnection.server_port`属性

该只读属性返回连接到MySQL服务器的TCP/IP端口号。  
返回的是整型。
 
##### 22.6.8.2.42 `MySQLConnection.sql_mode`属性

该属性用于设置当前连接的SQL模式，不同模式的值要用逗号分隔，或者使用`constants.SQLMode`类提供模式序列。  
传入空的字符串或者空序列，可取消所有的模式：

    >>> cnx.sql_mode = 'TRADITIONAL,NO_ENGINE_SUBSTITUTION'
    >>> cnx.sql_mode.split(',')
    [u'STRICT_TRANS_TABLES', u'STRICT_ALL_TABLES', u'NO_ZERO_IN_DATE',
    u'NO_ZERO_DATE', u'ERROR_FOR_DIVISION_BY_ZERO', u'TRADITIONAL', 
    u'NO_AUTO_CREATE_USER', u'NO_ENGINE_SUBSTITUTION']
    
    >>> from mysql.connector.constants import SQLMode
    >>> cnx.sql_mode = [ SQLMode.NO_ZERO_DATE, SQLMode.REAL_AS_FLOAT]
    >>> cnx.sql_mode
    
    u'REAL_AS_FLOAT,NO_ZERO_DATE'

返回的是字符串。 

##### 22.6.8.2.43 `MySQLConnection.time_zone`属性

该属性被用来检索当前连接的时区会话变量：

    >>> cnx.time_zone = '+00:00'
    >>> cur.execute('SELECT NOW()') ; cur.fetchone()
    (datetime.datetime(2012, 6, 15, 11, 24, 36),)
    >>> cnx.time_zone = '-09:00'
    >>> cur.execute('SELECT NOW()') ; cur.fetchone()
    (datetime.datetime(2012, 6, 15, 2, 24, 44),)
    >>> cnx.time_zone
    u'-09:00'

返回的是字符串。

##### 22.6.8.2.44 `MySQLConnection.unix_socket`属性

该只读属性返回连接到MySQL服务器的Unix socket 文件。  
返回的是字符串。
 
##### 22.6.8.2.45 `MySQLConnection.user`属性

该只读属性返回连接到MySQL服务器的用户名。  
返回的是字符串。


#### 22.6.8.3 pooling.MySQLConnectionPool类

该类提供了连接池的实例化和管理。

##### 22.6.8.3.1 pooling.MySQLConnectionPool构造器

语法：

    MySQLConnectionPool(pool_name = None, pool_size = 5, **kwargs)

该构造器实例化一个对象，管理连接池。  

参数：

* `pool_name`:连接池的名称。如果该参数没有指定，Python连接器自动生成名称，名称由`kwargs`中的`host`,`port`,`user`和`database`参数，按照上面的顺序构成。  
多个连接池具有相同的名字，不会报错。一个应用必须能够通过`pool_name`属性区别连接池，所以应该创建不同名字的连接池。  
* `pool_size`: 连接池的大小。如果该参数没有指定，则默认为5。 
* `kwrgs`: 可选的连接选项。描述请参见：[章节 22.6.6 Python连接器的连接参数][22.06.06]。

示例：  

    dbconfig = {
      "database": "test",
      "user":     "joe"
    }
    
    cnxpool = mysql.connector.pooling.MySQLConnectionPool(pool_name = "mypool",
                                                          pool_size = 3,
                                                          **dbconfig)

##### 22.6.8.3.2 MySQLConnectionPool.add_connection()方法

语法：

    cnxpool.add_connection(cnx = None)

该方法添加新的或者已经存在的`MySQLConnection`到连接池中，如果连接池已满，则触发`PoolError`错误。

参数：

* `cnx`: 添加到连接池的`MySQLConnection`对象。如果没有指定这个参数，连接池创建新的连接并添加它。

示例：

    cnxpool.add_connection()    # add new connection to pool
    cnxpool.add_connection(cnx) # add existing connection to pool

##### 22.6.8.3.3 MySQLConnectionPool.get_connection()方法

语法：

    cnxpool.get_connection()

该方法从连接池中返回一个连接，如果无连接池可用，则触发`PoolError`错误。

示例：

    cnx = cnxpool.get_connection()

##### 22.6.8.3.4 MySQLConnectionPool.set_config()方法

语法：

    cnxpool.set_config(**kwargs)

该方法为连接池中的连接设置参数。修改配置之后，新请求到的连接使用新的参数。修改之前获得的连接将不受影响，但是如果关闭了连接，回到连接池的连接为后续的连接请求服务，重新打开的连接将使用新的参数。

参数：

`kwargs`:连接参数。

示例：

    dbconfig = {
      "database": "performance_schema",
      "user":     "admin",
      "password": "secret"
    }
    
    cnxpool.set_config(**dbconfig)


##### 22.6.8.3.5 MySQLConnectionPool.pool_name属性

语法：

    cnxpool.pool_name

该属性返回连接池的名字。

示例：

    name = cnxpool.pool_name




#### 22.6.8.4 pooling.PooledMySQLConnection 类

该类被`MySQLConnectionPool`使用，返回连接池连接实例。这也是通过调用`connect()`方法命令一个连接池，然后被连接使用的类。参见[章节 22.6.7.1 Python连接器的连接池][22.06.07.01]。

`PooledMySQLConnection`连接池的连接对象和`MySQLConnection`非连接池的连接对象类似，但是有以下的不同：

* 释放来自连接池的连接，需要调用`colse()`方法，这和来自非连接池的连接一样。然而对应来自连接池的连接，调用`close()`并非真正的关闭连接，而是返回到连接池中，为后续的连接请求提供服务。  
* 连接池中的连接不能通过`config()`方法修改配置。连接的修改必须通过连接池对象本身，正如之前描述的。  
* 连接池中的连接具有`pool_name`属性，能够返回连接池的名字。


##### 22.6.8.4.1 pooling.PooledMySQLConnection构造器

语法：

    PooledMySQLConnection(cnxpool, cnx)

该构造器通过连接池和连接参数，返回一个连接池中的连接。该构造器被`MySQLConnectionPool`使用。

参数：

* `cnxpool`: 一个`MySQLConnectionPool` 实例。   
* `cnx`: 一个`MySQLConnection` 实例。

示例：

    pcnx = mysql.connector.pooling.PooledMySQLConnection(cnxpool, cnx)


##### 22.6.8.4.2 PooledMySQLConnection.close()方法

语法：

    cnx.close()

将来自连接池的连接返回。对于来自连接池的连接，`close()`并不真正的关闭，而是返回到连接池，并对后续的连接请求服务。   
如果配置参数被修改了，关闭后返回连接池的连接被重新打开，那么该连接回到连接池之后，响应新的连接时使用新的配置参数。


##### 22.6.8.4.3 PooledMySQLConnection.config()方法

对于连接池中的连接使用`config()`方法会触发`PoolError`异常，应该是去修改连接池对象本身。

##### 22.6.8.4.4 PooledMySQLConnection.pool_name属性

语法：

    cnx.pool_name

 该属性返回连接所属的连接池的名字。

示例：

    cnx = cnxpool.get_connection()
    name = cnx.pool_name


#### 22.6.8.5 cursor.MySQLCursor类

`MySQLCursor`类被用来实例化可以执行诸如SQL查询操作的对象。他通过`MySQLConnection`对象与MySQL服务器交互。

从`cursor.MySQLCursor`继承的相关的类：

* `cursor.MySQLCursorBuffered`创建一个缓冲游标，参见：[章节22.6.8.6 cursor.MySQLCursorBuffered类][22.06.08.06]。  
* `cursor.MySQLCursorPrepared`为准备好的语句创建一个游标，参见[章节22.6.8.7 cursor.MySQLCursorPrepared类][22.06.08.07]。


##### 22.6.8.5.1 `cursor.MySQLCursor`构造器

该构造器使用`connection`选项初始化实例，该实例为[MySQLConnection][22.06.08.02]的一个实例。  
在多数情况下，`MySQLConnection`[cursor()][22.06.08.02.06]方法被用来实例化`MySQLCursor`对象。

##### 22.6.8.5.2 `MySQLCursor.callproc(procname, args=())`方法

该方法使用给定的名字调用存储过程。对于程序期望的每个参数,`args`必须按照顺序给出一条这样的记录。以输入顺序修改后的副本的形式返回结果。输入参数原封不动。输出参数或者输入/输出参数可能被新的值替换。  
存储过程产生的结果集被自动获取，并以[MySQLCursorBuffered][22.06.08.06]实例存储。更多信息参见：[stored_results()][22.06.08.05.10]。

下面的示例演示了如何执行有2个参数的存储过程。值相乘，返回结果：

    # Definition of the multiply stored procedure:
    # CREATE PROCEDURE multiply(IN pFac1 INT, IN pFac2 INT, OUT pProd INT)
    # BEGIN
    #  SET pProd := pFac1 * pFac2;
    # END
    
    >>> args = (5, 5, 0) # 0 is to hold value of the OUT parameter pProd
    >>> cursor.callproc('multiply', args)
    ('5', '5', 25L)


##### 22.6.8.5.3 `MySQLCursor.close()`方法

该方法关闭MySQL游标，重置所有的结果。确保游标对象与连接对象没有关联。  
每次使用完游标，记得使用`close()`。

##### 22.6.8.5.4 `MySQLCursor.execute(operation, params=None, multi=False)`方法

该方法用于准备数据库`操作`(查询或者命令),`params`元组或字典中的参数在操作中被绑定变量。变量通过`%s(format)`，或者`%(name)s(pyformat)`参数类型指定。  
下面的示例插入新的员工信息，然后查询其数据：

    insert = (
    "INSERT INTO employees (emp_no, first_name, last_name, hire_date) "
    "VALUES (%s, %s, %s, %s)")
    data = (2, 'Jane', 'Doe', datetime.date(2012, 3, 23))
    cursor.execute(insert, data)
    
    select = "SELECT * FROM employees WHERE emp_no = %(emp_no)s"
    cursor.execute(select, { 'emp_no': 2 })

请注意，数据的值从Python对象向MySQL对象进行了必要的转换。在前面的例子中，`datetime.date()`实例被转换成`2012-03-23`。  
当`multi`被设置为`True`时`execute()`能够执行多条语句。它返回迭代器，让处理每个语句的结果集成为可能。请注意，在这个例子中，使用参数并不能有很好的效果，而且单独执行每条语句通常是很好注意。

下面的示例在一个操作中查询和插入数据，并展示结果：

    operation = 'SELECT 1; INSERT INTO t1 VALUES (); SELECT 2'
    for result in cursor.execute(operation):
      if result.with_rows:
        print("Statement '{}' has following rows:".format(
          result.statement))
        print(result.fetchall())
      else:
        print("Affected row(s) by query '{}' was {}".format(
          result.statement, result.rowcount))

如果连接被配置成可以获取警告，可以通过[MySQLCursor.fetchwarnings()][22.06.08.05.09]方法获得操作产生的警告。

当`multi`是`True`时，返回的是迭代器。

##### 22.6.8.5.5 `MySQLCursor.executemany(operation, seq_params)`方法

该方法编写数据库操作(查询或者命令),使用连续的或者`seq_of_params`序列中映射的参数来执行操作。  
`executemany()`遍历参数序列，调用`execute()`方法。插入数据时，通过使用多行插入语法来进行批处理优化。

下面的示例插入三条记录：

    data = [
      ('Jane', date(2005, 2, 12)),
      ('Joe', date(2006, 5, 23)),
      ('John', date(2010, 10, 3)),
    ]
    stmt = "INSERT INTO employees (first_name, hire_date) VALUES (%s, %s)"
    cursor.executemany(stmt, data)

在之前的例子中，发送到MySQL的[插入][13.02.05]操作应该是：

    INSERT INTO employees (first_name, hire_date)
    VALUES ('Jane', '2005-02-12'), ('Joe', '2006-05-23'), ('John', '2010-10-03')

不能通过`executemany()`方法执行多条语句，这样会触发`InternalError`异常。

##### 22.6.8.5.6 `MySQLCursor.fetchall()`方法

该方法从查询结果集中获取所有的或者剩下的行，当没有更多的行可用时，返回空的列表。  

下面的示例展示如何去检索结果集的前两行，然后检索余下的行：

    >>> cursor.execute("SELECT * FROM employees ORDER BY emp_no")
    >>> head_rows = cursor.fetchmany(size=2)
    >>> remaining_rows = cursor.fetchall()

在使用相同连接执行新的查询之前，必须获取所有的行。

##### 22.6.8.5.7 `MySQLCursor.fetchmany(size=1)`方法

该方法获取查询结果集的下一个行结果集，返回一个元组列表。如果没有更多的行可用，则返回空列表。  
返回的行数可以通过size参数指定，默认值为1。如果不足指定的行数，则可能返回少量的行。

在使用相同连接执行新的查询之前，必须获取所有的行。

##### 22.6.8.5.8 `MySQLCursor.fetchone()`方法

该方法检索查询结果的下一行，返回单一序列，如果没有行可用时，返回`None`。返回的元组包含MySQL转换成Python对象的数据。

`fetchone()`方法被[fetchmany()][22.06.08.05.07]和[fetchall()][22.06.08.05.06]使用。当`MySQLCursor`实例化为迭代器时也使用它。

下面的示例展示如何用`fetchone()`处理结果集，先使用`while`循环，然后使用迭代器：

    # Using a while-loop
    cursor.execute("SELECT * FROM employees")
    row = cursor.fetchone()
    while row is not None:
      print(row)
      row = cursor.fetchone()
    
    # Using the cursor as iterator 
    cursor.execute("SELECT * FROM employees")
    for row in cursor:
      print(row)

在使用相同连接执行新的查询之前，必须获取所有的行。

##### 22.6.8.5.9 `MySQLCursor.fetchwarnings()`方法

该方法以元组形式返回之前执行语句生成的警告信息。通过`get_warning`属性来设置连接是否获取告警信息。

下面的示例展示一个产生警告的[查询][13.02.09]语句：

    >>> cnx.get_warnings = True
    >>> cursor.execute('SELECT "a"+1')
    >>> cursor.fetchall()
    [(1.0,)]
    >>> cursor.fetchwarnings()
    [(u'Warning', 1292, u"Truncated incorrect DOUBLE value: 'a'")]

警告也可能触发错误，参见：MySQLConnection [`raise_on_warnings`][22.06.08.02.39]属性。

##### 22.6.8.5.10 `MySQLCursor.stored_results()`方法

该方法返回一个列表迭代器对象，可以用来处理通过[callproc()][22.06.08.05.02]方法调用存储过程生成的结果集。

下面的示例执行一个存储过程，产生两个结果集，然后使用`stored_results()`对他们进行检索：

    >>> cursor.callproc('sp1')
    ()
    >>> for result in cursor.stored_results():
    ...     print result.fetchall()
    ... 
    [(1,)]
    [(2,)]

除非执行其他操作或者调用其他的存储过程，否则这个结果集会一直有效。

##### 22.6.8.5.11 `MySQLCursor.column_names`属性

此只读属性返回一个结果集的列名称序列(Unicode)字符串。  
下面的示例展示了如何从一个包含使用了`column_names`关键字的数据来创建字典：

    cursor.execute("SELECT last_name, first_name, hire_date "
      "FROM employees WHERE emp_no = %s", (123,))
    row = dict(zip(cursor.column_names, cursor.fetchone())
    print("{last_name}, {first_name}: {hire_date}".format(row))

##### 22.6.8.5.12 `MySQLCursor.description`属性

该只读属性返回一个描述结果集列的元组列表。每个元组包含的值如下：

    (column_name,
     type,
     None,
     None,
     None,
     None,
     null_ok,
     column_flags)

下面的示例展示如何去解释`description`元组：

    import mysql.connector
    from mysql.connector import FieldType
    
    ...
    
    cursor.execute("SELECT emp_no, last_name, hire_date "
      "FROM employees WHERE emp_no = %s", (123,))
    for i in range(len(cursor.description)):
      print("Column {}:".format(i+1))
      desc = cursor.description[i]
      print("column_name = {}".format(desc[0]))
      print("type = {} ({})".format(desc[1], FieldType.get_info(desc[1])))
      print("null_ok = {}".format(desc[6]))
      print("column_flags = {}".format(desc[7]))

输出结果类似于：

    Column 1:
    column_name = emp_no
    type = 3 (LONG)
    null_ok = 0
    column_flags = 20483
    Column 2:
    column_name = last_name
    type = 253 (VAR_STRING)
    null_ok = 0
    column_flags = 4097
    Column 3:
    column_name = hire_date
    type = 10 (DATE)
    null_ok = 0
    column_flags = 4225

`column_flags`是`constants.FieldFlag`类的一个示例。查看如何解释它：

    >>> from mysql.connector import FieldFlag
    >>> FieldFlag.desc

##### 22.6.8.5.13 `MySQLCursor.lastrowid`属性

该只读属性返回最近修改的行的行ID。例如，[插入][13.02.05]一条包含`AUTO_INCREMENT`的列到一个表中，`lastrowid`返回新行的` AUTO_INCREMENT`的值。示例参见：[章节 22.6.4.3 使用Python连接器插入数据][22.06.04.03]。


##### 22.6.8.5.14 `MySQLCursor.statement`属性

该只读属性把最后执行的语句作为字符串返回。如果多条语句被执行了，那么该字符串包含多条语句。  
在调试和显示什么被发送到了MySQL服务器时，`statement`属性非常有用。

##### 22.6.8.5.15 `MySQLCursor.with_rows`属性

该只读属性在执行操作的结果包含行时，返回`True`。  
在需要确定一个语句产生了结果集，并且需要获取行时，`with_rows`属性非常有用。下面的语句从[SELECT][13.02.09]语句的结果中检索行，但是仅打印哪些被[UPDATE][13.02.11]语句影响的行的值。

    import mysql.connector
    cnx = mysql.connector.connect(user='scott', database='test')
    cursor = cnx.cursor()
    operation = 'SELECT 1; UPDATE t1 SET c1 = 2; SELECT 2'
    for result in cursor.execute(operation, multi=True):
      if result.with_rows:
        result.fetchall()
      else:
        print("Updated row(s): {}".format(result.rowcount))

#### 22.6.8.6 cursor.MySQLCursorBuffered类

 该类继承自`cursor.MySQLCursor`，如果有必要，在执行完一个操作后，他自动获取行。  
两个查询返回的结果集很小，并需要合并或者计算，这种情形下，`MySQLCursorBuffered`非常有用。  

既可以在使用连接的`cursor()`方法时带`buffered`参数，也可以 
在默认情况下，使用`buffered`[连接操作][22.06.06]产生所有的游标，供连接缓存使用：


    import mysql.connector
    
    cnx = mysql.connector.connect() 
    
    # Only this particular cursor will buffer results
    cnx.cursor(buffered=True)
    
    # All cursors will be buffering by default
    cnx2 = mysql.connector.connect(buffered=True)

实际的用户案例，参见[章节22.6.5.1 教程：使用Buffering Cursor增加员工的工资][22.06.05.01] 。


#### 22.6.8.7 `cursor.MySQLCursorPrepared`类

一种执行写好了的SQL语句的方式是使用`PREPARE`和`EXECUTE`语句。然而，用不同的数据重复执行相同的语句是，使用二进制客户端/服务器协议来发送和接受数据更有效。关于该协议更多的信息，参加：[章节 22.8.8 C API 写好的语句][22.08.08]。  
`MySQLCursorPrepared`类让Python在执行写好的语句时可以使用二进制协议。该类继承自`cursor.MySQLCursor. MySQLCursorPrepared `，在Python连接器的1.1.0版本中可用。

为了创建`MySQLCursorPrepared`类的实例，使用带有`cursor_class`参数的`cursor()`方法。

    import mysql.connector
    from mysql.connector.cursor import MySQLCursorPrepared
    
    cnx = mysql.connector.connect(database='employees')
    cursor = cnx.cursor(cursor_class=MySQLCursorPrepared)

在Python连接器 1.1.2版本中，创建写好的游标的简单语法如下：

    cursor = cnx.cursor(prepared=True)

当调用带有`ursor_class=MySQLCursorPrepared`选项的`cursor()`方法时，连接对象返回一个`MySQLCursorPrepared`对象。

继承自`MySQLCursorPrepared`类的游标，工作类似于：

* 当第一次给游标的`execute()`方法传入语句时，它准备好语句。如果后续的`execute()`调用语句相同，则跳过准备过程。

* `execute()`方法具有可选的第二个参数，其包含一个与语句中的参数标记相对应的数据值的列表。如果列表参数存在，则必须有一个值参数标记。

示例：

    cursor = cnx.cursor(prepared=True)
    stmt = "SELECT fullname FROM employees WHERE id = ?"  # (1)
    cursor.execute(stmt, (5,))                            # (2)
    # ... fetch data ...
    cursor.execute(stmt, (10,))                           # (3)
    # ... fetch data ...

1.语句中的`?`是一个参数标记，不要给参数标记加引号。  
2.第一次调用`execute()`方法时游标准备语句，如果在调用的同时指定了数据，那么它就执行该语句，并可以获取数据。  
3.如果后续的`execute()`调用传入的语句相同，则跳过准备过程。

`MySQLCursorPrepared`执行写好的语句可以使用`format`或`qmark`参数化的风格。与`MySQLCursor`非写好语句的执行不同的是，后者可以使用`format`或`pyformat`参数话的风格。

为了同时执行多个准备好的语句，请从`MySQLCursorPrepared`类中实例化多个游标。

#### 22.6.8.8 `constants.ClientFlag`类

该类提供MySQL客户端定义标志，可以配置会话建立连接时使用的常量。当引入`mysql.connector`时`ClientFlag`类可用。

    >>> import mysql.connector
    >>> mysql.connector.ClientFlag.FOUND_ROWS
    2

参见：[章节22.6.8.2.30 `MySQLConnection.set_client_flags(flags)`方法][22.06.08.02.30]和[连接参数][22.06.06]`client_flag`。

`ClientFlag`类无法被实例化。

#### 22.6.8.9 `constants.FieldType`类

该类支持所有的MySQL字段或者数据类型，在处理原始数据或者自定义转换时非常有用。字段类型和游标一起存储在每个列的描述中。

下面的示例展示了如何打印结果集中每列的数据类型的名字：

    from __future__ import print_function
    import mysql.connector
    from mysql.connector import FieldType
    
    cnx = mysql.connector.connect(user='scott', database='test')
    cursor = cnx.cursor()
    
    cursor.execute(
      "SELECT DATE(NOW()) AS `c1`, TIME(NOW()) AS `c2`, "
      "NOW() AS `c3`, 'a string' AS `c4`, 42 AS `c5`")
    rows = cursor.fetchall()
    
    for desc in cursor.description:
      colname = desc[0]
      coltype = desc[1]
      print("Column {} has type {}".format(
        colname, FieldType.get_info(coltype)))
    
    cursor.close()
    cnx.close()

`FieldType`类无法被实例化。

#### 22.6.8.10 `constants.SQLMode`类

该类提供众所周知的MySQL[服务器SQL模式][05.01.07]。大多数用在连接时使用连接的`sql_mode`属性设置SQL模式。参见：[章节  22.6.8.2.42 MySQLConnection.sql_mode属性][22.06.08.02.42]。

`SQLMode`类无法被实例化。

#### 22.6.8.11 `constants.CharacterSet`类

该类提供众所周知的MySQL字符集和字符集默认的排序。例子请参见：[章节 22.6.8.2.29 `MySQLConnection.set_charset_collation`(charset=None, collation=None)方法][22.06.08.02.29]。

`CharacterSet`类不能被实例化。

#### 22.6.8.12 `constants.RefreshOption`类

该类执行众多的刷新操作。

* RefreshOption.GRANT 

刷新授权表，类似于[FLUSH PRIVILEGES][13.07.06.03]。 

* RefreshOption.LOG 

刷新日志，类似于[FLUSH LOGS][13.07.06.03]。 

* RefreshOption.TABLES 

刷新表缓存，类似于[FLUSH TABLES][13.07.06.03]。 

* RefreshOption.HOSTS 

刷新主机缓存，类似于[FLUSH HOSTS][13.07.06.03]。 

* RefreshOption.STATUS 

刷新状态变量，类似于[FLUSH STATUS][13.07.06.03]。  

* RefreshOption.THREADS 

刷新线程缓存。 

* RefreshOption.SLAVE 

在从复制服务器上重置主服务器信息，重启从服务器，类似于[RESET SLAVE][13.07.06.03]。 

* RefreshOption.MASTER 

在主复制服务器上，删除二进制索引文件中的二级制日志的文件列表，清空索引文件。类似于[RESET MASTER][13.07.06.03]。 


#### 22.6.8.13 错误和异常

`mysql.connector.errors`模块为MySQL连接器/Python引起的错误和警告定义了异常类。当引入`mysql.connector`后，该模块中的大多数类都可用。

模块中的异常类大多遵循Python数据库规范v2.0(PEP-249)。对于一些MySQL客户端或服务器的错误，并不总是很清楚触发哪些异常。讨论下错误在何时重新打开一个bug报告是有好处的。

MySQL服务器错误与Python异常通过他们的SQLSTATE值进行映射(参见：[附录3 服务器错误代码和信息][C3])。下表展示了SQLSTATE类别和Python连接器引起的异常。然而，可能需要为每个服务器错误重新定义引起的异常。请注意，默认的异常是`DatabaseError`。

__表 22.34__

<div class="table">
<a name="idm47271152085696"></a><p class="title"><b>Table 22.34. </b></p>
<div class="table-contents">
<table summary="" border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">SQLSTATE Class</th><th scope="col">Connector/Python Exception</th></tr></thead><tbody><tr><td scope="row"><code class="literal">02</code></td><td><code class="literal">DataError</code></td></tr><tr><td scope="row"><code class="literal">02</code></td><td><code class="literal">DataError</code></td></tr><tr><td scope="row"><code class="literal">07</code></td><td><code class="literal">DatabaseError</code></td></tr><tr><td scope="row"><code class="literal">08</code></td><td><code class="literal">OperationalError</code></td></tr><tr><td scope="row"><code class="literal">0A</code></td><td><code class="literal">NotSupportedError</code></td></tr><tr><td scope="row"><code class="literal">21</code></td><td><code class="literal">DataError</code></td></tr><tr><td scope="row"><code class="literal">22</code></td><td><code class="literal">DataError</code></td></tr><tr><td scope="row"><code class="literal">23</code></td><td><code class="literal">IntegrityError</code></td></tr><tr><td scope="row"><code class="literal">24</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">25</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">26</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">27</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">28</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">2A</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">2B</code></td><td><code class="literal">DatabaseError</code></td></tr><tr><td scope="row"><code class="literal">2C</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">2D</code></td><td><code class="literal">DatabaseError</code></td></tr><tr><td scope="row"><code class="literal">2E</code></td><td><code class="literal">DatabaseError</code></td></tr><tr><td scope="row"><code class="literal">33</code></td><td><code class="literal">DatabaseError</code></td></tr><tr><td scope="row"><code class="literal">34</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">35</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">37</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">3C</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">3D</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">3F</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">40</code></td><td><code class="literal">InternalError</code></td></tr><tr><td scope="row"><code class="literal">42</code></td><td><code class="literal">ProgrammingError</code></td></tr><tr><td scope="row"><code class="literal">44</code></td><td><code class="literal">InternalError</code></td></tr><tr><td scope="row"><code class="literal">HZ</code></td><td><code class="literal">OperationalError</code></td></tr><tr><td scope="row"><code class="literal">XA</code></td><td><code class="literal">IntegrityError</code></td></tr><tr><td scope="row"><code class="literal">0K</code></td><td><code class="literal">OperationalError</code></td></tr><tr><td scope="row"><code class="literal">HY</code></td><td><code class="literal">DatabaseError</code></td></tr></tbody></table>
</div>


##### 22.6.8.13.1 `errorcode`模块

该模块包含MySQL服务器和客户端错误代码，并把错误数值作为模块属性定义。使用错误数字替代错误代码让源代码的阅读更简单。

    >>> from mysql.connector import errorcode
    >>> errorcode.ER_BAD_TABLE_ERROR
    1051

参见[附录3 服务器错误代码和信息][C3]和[附录4 客户端错误代码和信息][C4]。


##### 22.6.8.13.2 `errors.Error`异常

该异常类是`errors`模块所有其他异常的基本类。他可被用来在单独的`except`语句中获取所有的错误。

下面的示例展示了如何获取语法错误：

    import mysql.connector
    try:
      cnx = mysql.connector.connect(user='scott', database='employees')
      cursor = cnx.cursor()
      cursor.execute("SELECT * FORM employees")   # Syntax error in query
      cnx.close()
    except mysql.connector.Error as err:
      print("Something went wrong: {}".format(err))


该异常的初始化还支持一些少量的选项，即`msg`, `errno`, `values` 和`sqlstate`。这些选项都是可选的，默认值都是`None`。`errors.Error`是Python连接器内部用来触发MySQL客户端和服务端错误的，应用程序不要使用它来触发异常。

下面的示例展示了不使用参数和使用组合参数的结果：

    >>> from mysql.connector.errors import Error
    >>> str(Error())
    'Unknown error'
    
    >>> str(Error("Oops! There was an error."))
    'Oops! There was an error.'
    
    >>> str(Error(errno=2006))
    '2006: MySQL server has gone away'
    
    >>> str(Error(errno=2002, values=('/tmp/mysql.sock', 2)))
    "2002: Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)"
    
    >>> str(Error(errno=1146, sqlstate='42S02', msg="Table 'test.spam' doesn't exist"))
    "1146 (42S02): Table 'test.spam' doesn't exist"


当Python连接器从MySQL服务器接收到一个错误包时，它使用用户错误数字1146。正如上面展示的，信息被解析并传递给`Error`异常。

每个`Error`类的异常子类都可以使用前面提到的参数来初始化。另外，每个实例都具有`errno`，`msg`和`sqlstate`属性，可在代码中使用。

下面的示例展示了删除一个不存在的表后如何处理错误。（当[DROP TABLE][13.01.28]语句没有包含`IF EXISTS`子句）：

    import mysql.connector
    from mysql.connector import errorcode
    
    cnx = mysql.connector.connect(user='scott', database='test')
    try:
      cur.execute("DROP TABLE spam")
    except mysql.connector.Error as err:
      if err.errno == errorcode.ER_BAD_TABLE_ERROR:
        print("Creating table spam")
      else:
        raise

在1.1.1版本以前的Python连接器中，原始的信息被传递给`errors.Error()`,并不被保存下来以供检索，相反，` Error.msg`属性和错误数字以及SQLSTATE值一起被格式化。在1.1.1版本中，只有原始的信息被保存进`Error.msg`属性中。
通过打印或者取得错误对象的字符串表达式来获得错误数字和SQLSTATE值被一起格式化的值。比如：

    try:
      conn = mysql.connector.connect(database = "baddb")
    except mysql.connector.Error as e:
      print "Error code:", e.errno        # error number
      print "SQLSTATE value:", e.sqlstate # SQLSTATE value
      print "Error message:", e.msg       # error message
      print "Error:", e                   # errno, sqlstate, msg values
      s = str(e)
      print "Error:", s                   # errno, sqlstate, msg values

`errors.Error`是Python中`StandardError`的一个子类。


##### 22.6.8.13.3 `errors.DataError`异常

当有数据问题时将触发该异常。比如，把一个不能为`NULL`的列设置为`NULL`，超出列的值域，被零除，列的计数与值的计数不匹配等等。  
`errors.DataError`是`errors.DatabaseError`的一个子类。


##### 22.6.8.13.4 `errors.DatabaseError`异常

当MySQL错误不满足其他的任何异常时，该异常是默认的异常。  
`errors.DatabaseError`是`errors.Error`的一个子类。


##### 22.6.8.13.5 `errors.IntegrityError`异常

当相关数据的完整性受到影响时，触发该异常。例如，插入重复键或外键约束失败。

下面的示例展示了重复键错误触发的完整性错误：

    cursor.execute("CREATE TABLE t1 (id int, PRIMARY KEY (id))")
    try:
      cursor.execute("INSERT INTO t1 (id) VALUES (1)")
      cursor.execute("INSERT INTO t1 (id) VALUES (1)")
    except mysql.connector.IntegrityError as err:
      print("Error: {}".format(err))

`errors.IntegrityError`是`errors.DatabaseError`的一个子类。


##### 22.6.8.13.6 `errors.InterfaceError`异常

该类由Python连接器本身触发，跟MySQL无关。

`errors.InterfaceError`是`errors.Error`的一个子类。


##### 22.6.8.13.7 `errors.InternalError`异常

当遇到MySQL服务器的内部错误时讲触发该异常，比如发生了死锁。

`errors.InternalError`是`errors.DatabaseError`的一个子类。

##### 22.6.8.13.8 `errors.NotSupportedError`异常

当某些特性不被MySQL的版本支持时，返回的错误将触发该异常。
在存储程序中使用不被支持的函数或语句也同样触发该异常。

`errors.NotSupportedError`是`errors.DatabaseError`的一个子类。

##### 22.6.8.13.9 `errors.OperationalError`异常

该异常跟MySQL的相关操作错误有关。比如：连接过多，无法解析主机名；握手出错(bad handshake);服务器被关闭，协商错误。

`errors.OperationalError`是`errors.DatabaseError`的一个子类。

##### 22.6.8.13.10 `errors.PoolError`异常

连接池错误将触发该异常，`errors.PoolError`是`errors.Error`的一个子类。

##### 22.6.8.13.11 `errors.ProgrammingError`异常

程序错误将触发该异常，比如SQL中的语法错误或者表不存在。

下面的示例展示了如何处理语法错误：

    try:
      cursor.execute("CREATE DESK t1 (id int, PRIMARY KEY (id))")
    except mysql.connector.ProgrammingError as err:
      if err.errno == errorcode.ER_SYNTAX_ERROR:
        print("Check your syntax!")
      else:
        print("Error: {}".format(err))

`errors.ProgrammingError`是`errors.DatabaseError`的一个子类。

##### 22.6.8.13.12 `errors.Warning`异常

该异常用来报告重要的警告，然后，Python连接器并没有使用它。Python数据库规范v2.0 (PEP-249)中包含了该异常。

当需要在Python连接器中触发查询产生的错误时，考虑使用更严格的[服务器SQL模式][05.01.07]或者[`raise_on_warnings`][22.06.06]参数。

`errors.Warning`是Python中`StandardError`的一个子类。


##### 22.6.8.13.13 errors.custom_error_exception(error=None, exception=None) 函数

该方法为MySQL服务器错误定义了自定义异常，返回当前的自定义信息。

如果`error`是一个MySQL服务器错误数字，那么必须传递`exception`类。`error`参数可以是一个字典，在这种情况下，关键字是服务器错误数字，异常类的值将被触发。

重置该自定义信息，应用一个空字典即可：

    import mysql.connector
    from mysql.connector import errorcode
    
    # Server error 1028 should raise a DatabaseError
    mysql.connector.custom_error_exception(1028, mysql.connector.DatabaseError)
    
    # Or using a dictionary:
    mysql.connector.custom_error_exception({
      1028: mysql.connector.DatabaseError,
      1029: mysql.connector.OperationalError,
    })
    
    # To reset, pass an empty dictionary:
    mysql.connector.custom_error_exception({})


[C3]:../Appendix_C/C.03.00_Server_Error_Codes_and_Messages.md
[C3]:../Appendix_C/C.04.00_Client_Error_Codes_and_Messages.md
[05.01.07]:../Chapter_05/05.01.07_Server_SQL_Modes.md
[06.02.01]:../Chapter_06/06.02.01_Privileges_Provided_by_MySQL.md
[13.01.28]:../Chapter_13/13.01.28_DROP_TABLE_Syntax.md
[13.02.05]:../Chapter_13/13.02.05_INSERT_Syntax.md
[13.02.09]:../Chapter_13/13.02.09_SELECT_Syntax.md
[13.02.11]:../Chapter_13/13.02.11_UPDATE_Syntax.md
[13.03.01]:../Chapter_13/13.03.01_START_TRANSACTION_COMMIT_and_ROLLBACK_Syntax.md
[13.07.06.03]:../Chapter_13/13.07.06_Other_Administrative_Statements.md#13.07.06.03
[22.06.04.03]:../Chapter_22/22.06.04_Connector_Python_Coding_Examples.md#22.06.04.03
[22.06.06]:../Chapter_22/22.06.06_Connector_Python_Connection_Arguments.md
[22.06.07.01]:../Chapter_22/22.06.07_Connector_Python_Other_Topics.md#22.06.07.01
[22.08.08]:../Chapter_22/22.08.08_C_API_Prepared_Statements.md
[22.06.08.02]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02
[22.06.08.02.03]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.03
[22.06.08.02.14]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.14
[22.06.08.02.19]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.19
[22.06.08.02.24]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.24
[22.06.08.02.26]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.26
[22.06.08.02.28]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.28
[22.06.08.02.29]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.29
[22.06.08.02.30]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.30
[22.06.08.02.31]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.31
[22.06.08.02.38]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.38
[22.06.08.02.39]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.02.39
[22.06.08.05]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.05
[22.06.08.05.02]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.05.02
[22.06.08.05.06]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.05.06
[22.06.08.05.07]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.05.07
[22.06.08.05.09]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.05.09
[22.06.08.06]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.06
[22.06.08.07]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.07
[22.06.08.08]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.08
[22.06.08.12]:../Chapter_22/22.06.08_Connector_Python_API_Reference.md#22.06.08.12
[commit]:../glossary.md#commit


