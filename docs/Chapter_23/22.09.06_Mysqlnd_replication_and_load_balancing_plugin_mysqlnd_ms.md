以下章节由[22.9.6. Mysqlnd replication and load balancing plugin (mysqlnd_ms)](http://dev.mysql.com/doc/refman/5.6/en/apis-php-book.mysqlnd-ms.html)翻译而来

### 22.9.6. Mysqlnd 复制与负载均和插件 (mysqlnd_ms)


Mysqlnd复制与负载均衡插件（mysqlnd_ms）向所有使用[mysqlnd](./22.9.5_MySQL_Native_Driver.md)(MySQL原生PHP驱动)的PHP MySQL扩展提供了易用的MySQL复制（replication）特性支持。   

MySQL原生PHP驱动（mysqlnd）为PHP 5.3.3及后续版本设立了一个用于构建内部插件的C语言API。基于C语言构建的插件，如复制与负载均衡插件，具有扩展[MySQL原生驱动](./22.9.5_MySQL_Native_Driver.md)（mysqlnd）功能的能力。   

从PHP 5.3.0开始，MySQL原生PHP驱动作为一个C库以被包含进PHP发行版的方式进行分发。它作为MySQL客户端库（libmysqlclient）的简易替代向外提供服务。使用Mysql原生驱动（mysqlnd）有如下好处：不需要额外的下载环节，mysqlnd与PHP捆绑发行；myslnd受PHP所使用的协议的约束；在某些情况下消耗的内存会更少；包含诸如异步队列等新的功能。   

在多数情况下,像mysqlnd_ms（MySQL原生驱动复制与负载均衡插件）这样的mysqlnd（MySQL原生驱动）插件是对用户透明的.复制与负载均衡差价支持所有PHP程序和所有MySQL PHP扩展。复制与负载均衡差价不更改现有的任何API。所以，它可以非常容易的在现有的PHP程序当总进行使用。   
以下章节为[22.9.6.1. Key Features](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-ms.key-features.html)的翻译

--------

#### [22.9.6.1. 主要特性](#22.9.6.1)


PECL/mysqlnd_ms（PHP扩展社区库/MySQL原生驱动复制与负载均衡插件）的主要特性如下.   

* 透明进而易用。   
    * 支持所有PHP MySQL扩展。 
    * 支持SSL协议。
    * 标准API，具有一致性。
    * 根据使用的情况不，对程序的改动很小或者完全不需要改动程序。
    * 惰性连接：在具体的SQL语句执行前，不建立到数据库的连接(主库和从库)。
    * 可选性：在一个web请求中，执行一次写入操作后，便自动使用主库，以达到减少对复制特性的延迟的可能的影响的目的。
        
* 可以同任何MySQL集群方案（MySQL clustering solution）一同使用。
    * MySQL复制：读写分离是由这个插件完成的。读写分离是这个插件的主要关注点。
    * MySQL集群（MySQL Cluster）：可以禁用读写分离。配置多个主库。
    * 第三方方案：此插件为MySQL复制特性优化过，但是仍然可以与任何其他的MySQL集群方案（MySQL clustering solution）一同使用。 

* 特有的读写分离特性
    * 自动探测SELECT语句。
    * 支持更改SQL的自动分配策略。
    * 用户定义。
    * 在需要的时候可以关闭读写分离，比如使用像MySQL Cluster这样的同步集群时。

* 特有的负载均衡策略
    * 轮循策略（Round Robin）：对于每个对从库的请求，通过轮循的方式选择不同的从库响应。
    * 随机策略：对于每个对从库的请求，随机选择一个从库进行响应。
    * 一次随机策略（粘性）：随机选择一个从库响应某一段时间内的所有来自web的对从库的请求。
    * 用户定义：程序可以对mysqlnd_ms（MySQL原生驱动复制与负载均衡插件）注册回调函数。
    * PHP 5.4.0及后续版本：如果使用API调用来控制事务，能够进行事物感知。
    * 加权负载均衡：可以为不同的服务器赋予不同的权重，比如控制向性能墙的服务器发送更多的请求，向性能弱的服务器发送少的请求。或者向提高逻辑通路更短的服务器的优先级以降低延迟。

* 全局事务ID
    * 客户端模拟(器)。在异步集群中（如应用了MySQL复制特性的集群），更容易的演练主库下线（因故），从库接替主库的过程。
    * 支持从MySQL 5.6.5版本开始引进的内建的全局事务ID（标识符）特性。
    * 当遇到读操作需要保证会话一致性的时候，支持使用事务ID来识别已经完成同步的从库（异步）。
    * 抑制：可选特性，mysqlnd_ms插件能够等待一个从库“同步”完成后在继续其他工作。
    
* 服务等级和一致性水平
    * 对于程序中的连接,会自动搜索集群中合适的节点进行响应。会话的完整性和强一致性有保证。
    * 满足最终一致性要求的从库（应用了MySQL复制特性）访问能够被快速本地缓存访问替代，可以显著的降低服务器负载。
 
* 分区和分片 
    * 在应用了复制特性的集群中的服务器能够被组织成若干分组。 MySQL提示（SQL hints）特性可以被用来手动分发查询（queries）到特定的组。分株特性可以用来将数据分组（或分片），或者解决由更新带来的与热点有关的问题。
    * MySQL复制特性过滤器通过表过滤器进行支持.
以下章节由[22.9.6.2. Limitations](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-ms.limitations.html)翻译而来

------

#### [22.9.6.2. 局限](#22.9.6.2)


内建的读写分离机制比较基础。每个由SELECT开始的查询都被视为一次读请求被分发至MySQL从库服务器。其他的所有查询（如SHOW语句）都被视为写请求被分发至MySQL主库服务器。内建的机制使用[SQL提示](#22.9.6.7)（SQL hints），或者用户定义的[回调函数](#E22.282)进行覆盖。


读写分离器不具备多重语句感知能力。多重语句被视为一个语句。语句在何地运行的决策是基于语句首进行判定的。比如说，如果使用使用[mysqli_multi_query](./22.9.3.9_The_mysqli_class.md#22.9.3.9.34)函数来执行一个多重语句 ``` SELECT id FROM test ; INSERT INTO test(id) VALUES (1)``` ，因为其以SELECT开头故语句将被分发到从库服务器。多重语句的后半部分，INSERT语句将不会被分发至主库服务器。

> **注意**   

>程序必须感知到出于负载均衡为目的的链接切换结果。请查看关于[连接池与切换](#22.9.6.5.2)，[事务处理](#22.9.6.5.3)，[故障转移负载均衡](#22.9.6.5.6)和[读写分离](＃22.9.6.5.8)的相关文档.
以下章节由[22.9.6.3. On the name](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-ms.name.html)翻译而来

#### [22.9.6.3. 插件名由来](#22.9.6.3)

Mysqlnd_ms是MySQL原生驱动主从插件（mysqlnd master slave plugin）的简称。这个名字起的很“短平快”。在项目开始的时候该项目的开发者们不想使用代码风格的命名方式来命名这个项目。
以下章节由[22.9.6.4. Quickstart and Examples](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-ms.quickstart.html)翻译而来

------

#### [22.9.6.4. 快速入门与实例](#22.9.6.4)

Mysqlnd复制与负载均衡插件很方便使用。本节快速入门将向您演示一些典型的应用案例，并向您提供一些使用该插件的实际建议。   

除了快速入门手册外，我们强烈建议您阅读参考部分的章节。本快速入门手册尽量避免讨论理论概念和插件的局限。在参考部分的章节我们会具体探讨这些事宜。从快速入门手册开始了解本插件是件不错的事情。然而，在将插件应用在生产环境（或其他的重要环境）之前，我们强烈建议您先阅读参考部分章节以获得足够的背景知识。 

本章重点关注如何在一个异步的MySQL集群（及MySQL复制主从集群）上使用PECL/mysqlnd_ms。一般来说一个异步集群要比一个同步集群更难使用与维护。比如说，维护MySQL集群（MySQL Cluster）需要获取比需要的更多的信息。

##### [22.9.6.4.1. 设置](#22.9.6.4.1)

Mysqlnd_ms是以作为PHP扩展的形式实现的。另请参阅[安装说明](#22.9.6.6.2)中的相关章节来安装[PECL/mysqlnd_ms](http://pecl.php.net/package/mysqlnd_ms)扩展。

首先，编译或配置你计划与mysqlnd库一起使用的PHP MySQL扩展（API）（[mysqli](./22.9.3_MySQL_Improved_Extension.md#22.9.3.15)，[PDO_MYSQL](./22.9.4_MySQL_Functions.md)，[mysql](./22.9.2_Original_MySQL_API.md#22.9.2.5)）。PECL/mysqlnd_ms是mysqlnd库的一个插件。如果想要跟其他的PHP MySQL扩展一块使用，该插件必须要使用mysqlnd库。

然后，讲扩展加载进PHP并且在PHP配置文件中激活该扩展，激活相关的命令为：mysqlnd_ms.enable。

[ **示例 22.215. 使插件生效 (php.ini)** ](#e22.215)

```
mysqlnd_ms.enable=1
mysqlnd_ms.config_file=/path/to/mysqlnd_ms_plugin.ini
```

该插件使用自己的配置文件，使用PHP配置参数项[mysqlnd_ms.config_file](#22.9.6.6.3)来指定插件的配置文件路径。这个文件必须对PHP运行用户（如，运行web服务器的用户，apache，www，nobody等）是可读的。请注意，从mysqlnd_ms 1.4.0开始，需要使用[mysqlnd_ms.config_file](#22.9.6.6.3) 这个配置项代替原有的配置项[mysqlnd_ms.ini_file](＃22.9.6.6.3)。仍然使用旧的配置项名称是一个常见的错误.   

生成插件配置文件，然后在mysql配置文件中使用配置项[mysqlnd_ms.config_file](#22.9.6.6.3)指定该配置文件的路径。   

mysqlnd_ms插件配置文件是基于JSON格式的。配置文件可被区块化。每个区块有其自己的名称，如 myapp。每个区块都可以独立设置自己的参数及参数值。   

一个区块之少要包含MySQL 主库服务器地址（MySQL replication master server），和从库的地址列表。该插件支持每个区块只用一个主库。多主库的MySQL replication集群配置没有不能够得到完全支持。在配置文件中需要指定主库的主机名（hostname），主库的端口号或者socket地址。指定从库的从库关键字（slave keyword）。

[ **示例 22.216. mysqlnd_ms最简配置文件（mysqlnd_ms_plugin.ini）** ](#e22.216)

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": [

        ]
    }
}
```
在配置文件中，MySQL从库地址列表选项必须存在，列表可以为空。推荐至少设置一个从库。你可以给服务器列表起一个名字，也可以不这么作。没有名字的服务器列表包含服务器的别名，如：本示例中的master_0为主库master的别名。快速入门手册中使用更加详细的无名字示例。

[ **示例 22.217. 推荐的最简配置文件（mysqlnd_ms_plugin.ini）** ](#e22.217)

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
```


在至少配置文件中至少包含两个服务器时，mysqlnd_ms插件便可以启用负载均衡机制和切换链接（switch connections）机制。切换链接机制并不总是透明的，在一些特定的情况下能够引发一些问题。关于[连接池与切换](#2.6.9.5.2)，[事务处理](2.6.9.5.3)，[故障转移（fail over）负载均衡](2.6.9.5.6)，[读写分离](2.6.9.5.8)章节会有详细的说明。其他的潜在隐患也会在稍后说明。   

通过配置至少一主一从的服务器，使切换连接特性生效，进而可以发现相关问题的，来达到应对可能由连接切换引发的潜在问题之目的，是一种负责的表现。

您配置的MySQL主库和MySQL从库，并不一定需要成为MySQL复制特性（MySQL replication）设置的一部分。出于测试的目的，你可以仅使用一台MySQL服务器，在配置文件中将其设置为主库或从库，详见下例。这样设置可以帮助你定位很多可能由连接切换所引发的潜在问题。然而，这样设置容易遇到由复制延迟所引发的相关问题。

[ **示例 22.218. 仅使用一台服务器（设为主库或从库）(仅作测试使用!)** ](#e22.218)

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
```

插件会尝试提示你次设置文件无效。从1.5.0版本开始，如果配置文件不可读，为空或JSON解析失败，会在PHP启动阶段突出一个警告。根据你的相关设置情况，这个警告也可能仅出现在日志文件中。当连接初始化完毕并且能够在设置中找到有效的区块后，进一步的验证便会完成。变更mysqlnd_ms.force_config_usage设置项可以帮助你找到有问题的设置。请参见：[]配置文件调试指南](#22.9.6.6)。

##### [**22.9.6.4.2. 运行语句**](#22.9.6.4.2)

该插件可以与任何使用mysqlnd库的PHP MySQL扩展（mysqli，mysql，和PDO_MYSQL）一同使用。PECL/mysqlnd_ms直接与mysqlnd库对接。它并不改变上述扩展的API或使用方法。

当一个到MySQL的连接被建立时，该扩展比这个连接调用的主机名参数的值和配置文件中的区块名称作比较。比如，配置文件中有一个名为myapp的区块，那么将按照这个区块的设置与相应的主机建立连接。

[**示例 22.219. mysqlnd_ms插件配置文件（mysqlnd_ms_plugin.ini）**](#e22.219)

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.220. 打开一个负载均衡连接**](#e22.220)

```php
<?php
/* Load balanced following "myapp" section rules from the plugins config file */
/* 应用myapp区块配置的负载均衡连接 */
$mysqli = new mysqli("myapp", "username", "password", "database");
$pdo = new PDO('mysql:host=myapp;dbname=database', 'username', 'password');
$mysql = mysql_connect("myapp", "username", "password");
?>
```

上面的连接示例会建立负载均衡连接。插件会将被判定为读的语句分发到IP为192.168.2.27的MySQL从库，并且开始为MySQL客户端连接监听3306端口。所有被判定为非读的语句会被分发到在本主机（localhost）上面运行的MySQL主库上面。如果使用的是类UNIX操作系统，在本主机（localhost）运行的主库服务会开始接受建立在UNIX socket /tmp/mysql.sock 上面的MySQL客户端连接，而使用TCP/IP协议进行连接是Windows主机的默认方法。插件会使用‘username’作为用户名，使用‘password‘作为密码来与配置文件中myapp区块中列出的MySQL服务器进行连接。连接后插件会选择使用’database‘库作为当前库。

用户名，密码和库名，将从连接API调用的相关参数中取出，并且在所有服务器上面使用。也就是说，你必须在配置文件的一个区块所列的所有MySQL服务器上面使用相同的用户名和密码。在 PECL/mysqlnd_ms 1.1.0中，允许在配置文件中为每一台服务器指定用户名和密码，这些用户名密码将用来在API调用时进行验证。

在运行语句时，插件并不更改API。读写分离“开箱即用”。假设主库和从库之间没有大的复制延迟的情况下，请看下面的例子。

[**示例 22.221. 执行语句**](#e22.221)

```php

<?php
/* Load balanced following "myapp" section rules from the plugins config file */
/* 应用myapp区块配置的负载均衡连接 */
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Statements will be run on the master */
/* 语句将在主库上执行 */
if (!$mysqli->query("DROP TABLE IF EXISTS test")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("CREATE TABLE test(id INT)")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* read-only: statement will be run on a slave */
/* 仅有读操作的语句: 语句将在从库上执行 */
if (!($res = $mysqli->query("SELECT id FROM test")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("Slave returns id = '%s'\n", $row['id'];
}
$mysqli->close();
?>
```

上例的输出将类似与下面这样:

Slave returns id = '1'

##### [**22.9.6.4.3. 连接状态**](#22.9.6.4.3)

该插件更改了PHP MySQL 连接句柄的语义处理机制。新的连接处理机制相当于一个连接池，而不是一个单独的MySQL客户端网络连接。一个连接池包括一个主库连接，和任意多的可选的从库连接。

连接池中的每个连接都有它自己的状态。比如说，SQL 用户变量（user variable），临时表，事物等，都是状态的一部分。上面提及的都那些项目隶属于连接状态，请参见[连接池与切换相关概念]()文档，如果出于负载均衡角度考虑，插件想要切换连接，那么程序将被分配一个拥有着不同状态的连接。必须告知程序让其知晓相关变更。

[**示例 22.222. 一主一从的配置文件**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.223. 隐患：连接状态和SQL用户变量]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connection 1, connection bound SQL user variable, no SELECT thus run on master */
/* 连接1，用SQL用户变量绑定连接，没有SELECT查询会跑在主库上面 */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connection 2, run on slave because SELECT */
/* 连接2,SELECT查询会在从库上运行 */
if (!($res = $mysqli->query("SELECT @myrole AS _role"))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
```
    
上例输出:

@myrole = ''

上例会建立一个负载均衡连接并且执行两个语句。第一个语句```SET @myrole='master'```不是以SELECT关键字开头的.所以插件没有将其判定为一个只读查询（只读查询会在从库上运行）.插件将这个语句分配到主库运行。该语句设置了一个绑定在主库连接上用户变量。主库的连接状态已经被改变。

第二个语句是```SELECT @myrole AS _role```。插件将其判定为一个只读查询。所以语句会在从库上执行。这个连接没有与任何SQL用户变量进行绑定。它与第一个主库连接相比有着不同的连接状态。SQL用户请求变量（The requested SQL user variable）没有被设置。示例脚本输出：

@myrole = ''.

对于成寻开发者来说，关注连接状态是一种尽责的表现。Mysqlnd_ms插件并不监控所有的连接状态行为。监控所有的可能情形是很耗费CPU资源，也是几乎不可实现的。

The pitfalls can easily be worked around using SQL hints.

使用SQL提示（SQL hints）很容易解决这些隐患问题。

##### [**22.9.6.4.4. SQL提示（SQL Hints）**](#22.9.6.4.4)

SQL提示可以强制一个查询使用连接池中的特定服务器。它会发给插件一个使用特定服务器的提示，这可以解决由连接切换和连接状态所引发的问题。

SQL hint是符合标准的SQL注释。因为SQL注释应该被SQL处理系统忽略，他们不干涉其他的程序，如MySQL服务器程序，MySQL代理程序，或者防火墙。

Mysqlnd_ms支持三种SQL hint：MYSQLND_MS_MASTER_SWITCH hint会让插件在主库上面执行一个语句。MYSQLND_MS_SLAVE_SWITCH 会让语句强制使用从库。MYSQLND_MS_LAST_USED_SWITCH 会让语句运行在上一条语句运行的库上。

The plugin scans the beginning of a statement for the existence of an SQL hint. SQL hints are only recognized if they appear at the beginning of the statement.

Mysqlnd_ms插件会扫描语的开头部分，来确定SQL hint是否存在。只有SQL hint出现在语句开头的位置时，他们才能够被识别到。

[**示例 22.224. 一主一从配置文件**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.225. 使用SQL hint防止连接切换**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connection 1, connection bound SQL user variable, no SELECT thus run on master */
/* 连接1，连接绑定SQL用户变量，无SELECT语句会运行在主库上 */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connection 1, run on master because of SQL hint */
/* 连接1，由于SQL hint 的作用会运行在主库上*/
if (!($res = $mysqli->query(sprintf("/*%s*/SELECT @myrole AS _role", MYSQLND_MS_LAST_USED_SWITCH)))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
```
    
上例输出：

@myrole = 'master'


在上例中，当SELECT语句运行时，我们使用MYSQLND_MS_LAST_USED_SWITCH 来避免会话从主库切换到从库上面。

SQL hint也可以被用来强制使SELECT语句运行在主库上。 当MySQL从库长时间无法同步主库完成的但是你仍然需要获取集群中存储的最近的信息的时候，这个特性就会变得很有用。

Mysqlnd_ms 1.2.0 为了应对当前数据需要被获取的案例，进而引入了服务水平的概念。使用服务等级，你就可以投入更少的经历，并且不在需要使用SQL hint来应对对应的应用案例。请阅读[服务等级和一致性]()章节获取更多信息。

[**示例 22.226. 对抗复制延迟**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Force use of master, master has always fresh and current data */
/* 强制使用主库，主库总是刷新并且提供当前数据 */
if (!$mysqli->query(sprintf("/*%s*/SELECT critical_data FROM important_table", MYSQLND_MS_MASTER_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
?>
```

另外一个应用SQL hint的案例是可以在从库上创建表。如果没有给出SQL hint的话，mysqlnd_ms插件会将CREATE和INSERT语句分发到主库上去。使用MYSQLND_MS_SLAVE_SWITCH这个SQL hint可以将他们分发到从库上面，例如构建一些临时报告用表。

[**示例 22.227. 在从库上创建表**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Force use of slave */
/* 强制使用从库 */
if (!$mysqli->query(sprintf("/*%s*/CREATE TABLE slave_reporting(id INT)", MYSQLND_MS_SLAVE_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* Continue using this particular slave connection */
/* 继续使用特定从库连接 */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO slave_reporting(id) VALUES (1), (2), (3)", MYSQLND_MS_LAST_USED_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* Don't use MYSQLND_MS_SLAVE_SWITCH which would allow switching to another slave! */
if ($res = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM slave_reporting", MYSQLND_MS_LAST_USED_SWITCH))) {
  $row = $res->fetch_assoc();
  $res->close();
  printf("There are %d rows in the table 'slave_reporting'", $row['_num']);
} else {
  printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
$mysqli->close();
?>
```

The SQL hint MYSQLND_MS_LAST_USED forbids switching a connection, and forces use of the previously used connection.

SQL hint MYSQLND_MS_LAST_USED会禁止连接的却换,并且强制使用之前使用的连接。

##### [**22.9.6.4.5. 事务**](＃22.9.6.4.5)

当前版本的mysqlnd_ms插件默认上并不是事务安全的。因为它并不能感知所有应用案例中的运行事务。SQL事务是在SQL服务器上面工作的基本单元。Mysqlnd_ms插件并不总能知晓事务何时开始，何时结束。所以，插件可能在事务执行的过程中决定切换连接。

没有任何一种MySQL负载均衡器能够在不从程序获取任何提示的情况下探测到事务的边界。

You can either use SQL hints to work around this limitation. Alternatively, you can activate transaction API call monitoring. In the latter case you must use API calls only to control transactions, see below.

应对这个局限的方法之一是使用SQL hint，你也可以激活事务API调用监控。下面的例子中，你必须使用API调用来控制事务，见下。

[**示例 22.228. 一主一丛配置**]()

```json
[myapp]
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.229. 对事务应用SQL hint**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
  
/* Not a SELECT, will use master */
/* 非SELECT,在主库运行 */
if (!$mysqli->query("START TRANSACTION")) {
 /* Please use better error handling in your code */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Prevent connection switch! */
/* 防止连接切换！ */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO test(id) VALUES (1)", MYSQLND_MS_LAST_USED_SWITCH)))) {
 /* Please do proper ROLLBACK in your code, don't just die */
 /* 请在你的代码中作适当的回滚操作，不要直接调用die */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if ($res = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM test", MYSQLND_MS_LAST_USED_SWITCH)))) {
  $row = $res->fetch_assoc();
  $res->close();
  if ($row['_num'] > 1000) {
   if (!$mysqli->query(sprintf("/*%s*/INSERT INTO events(task) VALUES ('cleanup')", MYSQLND_MS_LAST_USED_SWITCH)))) {
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
   }
  }
} else {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/UPDATE log SET last_update = NOW()", MYSQLND_MS_LAST_USED_SWITCH)))) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/COMMIT", MYSQLND_MS_LAST_USED_SWITCH)))) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

$mysqli->close();
?>
```

从PHP 5.4.0开始，如果autocommit模式被API调用设置，而不是被SQL语句设置（比如说，SET AUTOCOMMIT=0 ）的话，mysqlnd库允许插件监控autocommit模式的状态。

如果使用PHP 5.4.0 及以后版本，API调用启用autocommit模式，当在配置文件中有trx_stickiness=master这个设置时，插件会自动禁用负载均衡并和SQL事务的连接切换。如果这样配置，插件会停止负载均衡并将所有语句分发到主库。这样可以防止在一个事务运行时连接切换，一旦autocommit重新开启，负载均衡便再次开启。

API based transaction boundary detection has been improved with PHP 5.5.0 and PECL/mysqlnd_ms 1.5.0 to cover not only calls to mysqli_autocommit but also mysqli_begin, mysqli_commit and mysqli_rollback.

基于API的事务边界探测在PHP 5.5.0及后续版本中得到了加强。PECL/mysqlnd_ms 1.5.0不仅仅可以支持mysqli_autocommit，同样也可以支持mysqli_begin，mysqli_commit和mysqli_rollback。

[**示例 22.230. 事务感知负载均衡：trx_stickiness设置**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "trx_stickiness": "master"
    }
}
```

[**示例 22.231. 事务感知**]()

```
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Disable autocommit, plugin will run all statements on the master */
/* 禁用autocommit，插件会将所有语句都分发到主库运行 */
$mysqli->autocommit(FALSE);

if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
 /* Please do proper ROLLBACK in your code, don't just die */
 /* 请在你的代码中作适当的回滚操作，不要直接调用die */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if ($res = $mysqli->query("SELECT COUNT(*) AS _num FROM test")) {
  $row = $res->fetch_assoc();
  $res->close();
  if ($row['_num'] > 1000) {
   if (!$mysqli->query("INSERT INTO events(task) VALUES ('cleanup')")) {
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
   }
  }
} else {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query("UPDATE log SET last_update = NOW()")) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->commit()) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Plugin assumes that the transaction has ended and starts load balancing again */
/* 插件假设事务已经完成并重新开始负载均衡 */
$mysqli->autocommit(TRUE);
$mysqli->close();
?>
```

>版本要求

>插件的配置项trx_stickiness=master 需要PHP 5.4.0 及后续版本。

请查看事务助理相关概念章节的限制概述（restrictions outlined）部分。

##### [22.9.6.4.6. 服务水平及一致性](#22.9.6.4.6)

>版本要求

>服务水平在PECL/mysqlnd_ms 1.2.0-alpha版本被引进。mysqlnd_ms_qos 在PHP 5.4.0 及后续版本中可用。

不同种类的MySQL集群方案向用户提供不同的数据和一致性水平。一个异步的MySQL复制集群（MySQL replication cluster）默认就能保证最终一致性。一个运行在异步集群从库上的读请求操作，根据从库与主库的同步状态不同，可能会返回当前的数据，旧数据，或者什么都不返回。

使用MySQL复制集群的应用程序需要被设计成能够正确的处理最终一致性数据。然而，在一些案例中旧数据是不能够接受的。在那些案例中，为了让集群能够向外提供达标的服务质量，只有特定的从库甚至只有主库被允许访问。

As of PECL mysqlnd_ms 1.2.0 the plugin is capable of selecting MySQL replication nodes automatically that deliver session consistency or strong consistency. Session consistency means that one client can read its writes. Other clients may or may not see the clients' write. Strong consistency means that all clients will see all writes from the client.

从PECL/mysql_ms 1.2.0版本开始，插件已经有了能够正确大自动选择能够提供会话一致性或强一致性的MySQL复制集群节点的能力。会话一致性的意思是，一个客户端可以正确读出它写入的数据。其他客户端可能有可能能读取到他的写入，也有可能读取不到他的写入。强一致性的意思是，所有客户端都可以正确读取某个客户端的所有写入的数据。

[**示例 22.232. 会话一致性：读出写入的数据**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.233. 会话一致性需求**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* read-write splitting: master used */
/* 读写分离：使用主库 */
if (!$mysqli->query("INSERT INTO orders(order_id, item) VALUES (1, 'christmas tree, 1.8m')")) {
   /* Please use better error handling in your code */
   /* 请在你的代码中作适当的回滚操作，不要直接调用die */
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Request session consistency: read your writes */
/* 需要保证会话一致性：读出写入的数据 */    
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks a node which has the changes, here: master */
/* 插件挑选一个包含数据变更的节点，本例中为主库节点 */
if (!$res = $mysqli->query("SELECT item FROM orders WHERE order_id = 1"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

var_dump($res->fetch_assoc());

/* Back to eventual consistency: stale data allowed */
/* 回到最终一致性：允许旧数据 */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks any slave, stale data is allowed */
/* 插件选择任何一个从库，允许旧数据 */
if (!$res = $mysqli->query("SELECT item, price FROM specials"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
```

服务水平可以在插件的配置文件中，或者运行时阶段使用mysqlnd_ms_set_qos参数进行设置。在上面例子中，这个功能被用来确保未来所有语句的会话一致性（读出你的写入），知道配置变更。对orders表的SELECT查询语句会运行在从库上，从而保证之前的所有写入可以被客户端读取。读写分离逻辑会作适当的更改以满足服务水平要求。


在应用程序读取到它对orders表所做的变更的那部分数据之后，他会回到默认的服务水平：最终一致性。最终一致性在选择阶段运行语句方面没有任何限制。所以，对specials表的SELECT查询语句会在从库上运行。

The new functionality supersedes the use of SQL hints and the master_on_write configuration option. In many cases mysqlnd_ms_set_qos is easier to use, more powerful improves portability.

这个新功能取代了SQL hint和master_on_write配置选项。在许多案例中，mysqlnd_ms_qos都更易用,也会大大改善代码的可移植性。

[**示例 22.234. Maximum age/slave lag**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "failover" : "master"
    }
}
```

[**示例 22.235. 限制slave lag**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Read from slaves lagging no more than four seconds */
/* 如果与主库的延迟不超过4秒，则从从库读取数据 */
$ret = mysqlnd_ms_set_qos($mysqli,
         MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
         MYSQLND_MS_QOS_OPTION_AGE, 4);

if (!$ret)
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks any slave, which may or may not have the changes */
/* 插件任意挑选一个从库，这个从库有可能包含刚刚变更的数据，也有可能不包含 */
if (!$res = $mysqli->query("SELECT item, price FROM daytrade"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));


/* Back to default: use of all slaves and masters permitted */
/* 回到默认设置：所有主库和从库都可以使用 */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
```

最终一致性服务水平可以与一个可选的参数一同使用，这个参数可以设置在选择从库的时候最大的从库延迟。如果这个参数被设置了，插件会检查所有的从库的SHOW SLAVE STATUS结果。在上面例子中，之后状态为Slave_IO_Running=Yes，Slave_SQL_Running=Yes且Seconds_Behind_Master <= 4的从库会被考虑用来运行从表daytrade中查询项目的SELECT查询语句。



对于应用程序来说，检查SHOW SLAVE STATUS结果的这个过程是透明的。如果出现错误，这些错误会被当成警告吐出。连接句柄被设置为没有错误。及时所有的SHOW SLAVE STATUS语句（这些语句都是由插件执行的）都执行失败，用户语句的执行也不会停止，假设主库的故障转移已经启动。所以，不需要对程序代码进行更改。

>**大开销及低效的操作**   
>在所有从库上检查SHOW SLAVE STATUS的输出结果会增加应用程序的开销。它是一种打开小，效率低的操作。请尽量少的使用这种操作。很遗憾的是，一个MySQL复制集群不会向客户端提供从中央实例上请求一个候选列表的可能性。所以一种更加高效的检查从库延迟的方法行不通了。
>
> 请进一步查看MySQL手册中的解释关于SHOW SLAVE STATUS 的局限和特性的相关章节


为了避免mysql_ms插件在没有满足条件的从库（从库与主库延迟小于设定的时间）能被找到时吐出警告，我们应该在插件配置文件中设置主库的故障转移。如果没有从库能够被使用并且故障转移被打开的话，插件会选择一个主库来执行语句。


如果没有从库能够被使用，并且故障转移被关闭了，插件会吐出一个警告，语句不会被执行，并且会产生一个连接错误。

[**示例 22.236. 故障转移未被设置**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.237. 没有能满足时间限制的从库**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Read from slaves lagging no more than four seconds */
/* 从延迟不大于4秒的从库读取数据 */
$ret = mysqlnd_ms_set_qos($mysqli,
         MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
         MYSQLND_MS_QOS_OPTION_AGE, 4);

if (!$ret)
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks any slave, which may or may not have the changes */
/* 插件任意挑选一个从库，这个从库有可能包含刚刚变更的数据，也有可能不包含 */
if (!$res = $mysqli->query("SELECT item, price FROM daytrade"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));


/* Back to default: use of all slaves and masters permitted */
/* 回到默认设置：所有主库和从库都可以使用 */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
```
    
上例输出：

```php
PHP Warning:  mysqli::query(): (mysqlnd_ms) Couldn't find the appropriate slave connection. 0 slaves to choose from. Something is wrong in %s on line %d
PHP Warning:  mysqli::query(): (mysqlnd_ms) No connection selected by the last filter in %s on line %d
[2000] (mysqlnd_ms) No connection selected by the last filter
```

##### [22.9.6.4.7. 全局事务ID（Global transaction IDs）](#22.9.6.4.7)

>**版本要求**
>客户端全局事务ID（client-side global transaction ID）mysqlnd_ms 1.2.0-alpha版本被引进。这个特性不依赖于同步集群，比如说：MySQL Cluster。你可以在MySQL异步集群（如传统的MySQL replication）上使用它。
>
>从MySQL 5.6.5-m8版本开始，MySQL开始内建全局事务标识符（global transaction identifiers）。从PECL/mysqlnd_ms 1.3.0-alpha版本开始支持全局事务ID。

PECL/mysqlnd_ms 亦可以使用自己的全局事务ID模拟器或者使用MySQL内建的GTID（MySQL 5.6.5-m8及后续版本）。从开发者的角度来看，客户端端GTID和服务器GTID基本可以PECL/mysqlnd_ms提供相同的特性，和一样的服务水平.他们的区别将在概念章节作具体讨论。


在演示怎样使用服务器端GTID之前,快速入门手册中首先演示PECL/mysqlnd_ms内建的客户端全局事务ID模拟器.这么做得目的是为了确保我们会首先讨论一些基本概念。

概念和客户端端模拟器

全局事务ID（GTID）本质上来讲是主库上的一个表上的一个计数器。每当有一个事务在主库上被提交，这个计数器便增加一次。从库会复制这个表。这个计数器有两个目的。一旦主库故障，它可以帮助数据库管理员来识别同步率最高的从库成为新的主库。同步率最高的从库就是计数器数值最大的那个。应用程序可以利用全局事务ID来查找那些从库已经复制了某些写操作）（由全局事务ID识别）。


PECL/mysqlnd_ms可以为每个提交的事务注入SQL语句，用来让GTID计数器数值增长。对于一个想要识别一个应用程序写操作的应用程序来说，GTID是可读的。这可以让插件通过查询主库和已经复制了更改的从库从而向外交付会话一致性（读出你的写入）的服务水平，

客户端端的全局事务ID模拟器有着一些局限。在将其应用在生产环境之前，请仔细阅读概念章节，以彻底理解其背后的原则和理念。在不需要充分了解那些背景知识的前提下，你仍然可以继续阅读快速入门手册。

首先，在你的主库上面创建一个计数器表并且插入一条记录。插件并不会自动建立这个表的。数据库管理员必须手动确保表的存在。根据错误报告模式的不同，插件有可能直接静默忽略此表的缺失，或者bail out。

[**示例 22.238. 在主库上面建立数据库表**]()

```sql
CREATE TABLE `trx` (
  `trx_id` int(11) DEFAULT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=latin1
INSERT INTO `trx`(`trx_id`) VALUES (1);
```

在插件配置文件中，设置一个SQL来是使用global_transaction_id_injection会话的on_commit更新全局事务ID表。请检查UPDATE语句中的表名，确保表明没有问题。在本例中,test.trx 被用来指向test库的trx表。使用上一步刚刚建立的表。使用表的全名是十分重要的，因为执行注入的连接可能使用的一个其他的默认的数据库。请保证用来打开会话的用户是允许执行UPDATE语句的。

当mysqlnd_ms执行全局事务ID注入时候，有可能会自动开启错误汇报。

[**示例 22.239. 插件配置：SQL 客户端端GTID注入**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "report_error":true
        }
    }
}
```

[**示例 22.240. 全局事务ID注入**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("DROP TABLE IF EXISTS test"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("CREATE TABLE test(id INT)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* auto commit mode, read on slave, no increment */
/* auto commit模式，从从库上读， GTID不增长*/
if (!($res = $mysqli->query("SELECT id FROM test")))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

var_dump($res->fetch_assoc());
?>
```
    

上例输出：

```
array(1) {
  ["id"]=>
  string(1) "1"
}
```

上例在主库上以auto commit模式执行三个语句，引发主库上的三个事务。对于每个语句来说，插件会在用户的SQL语句之前注入一个定义好的UPDATE语句。当脚本结束时，在主库上的全局事务ID计数器已经增长3次。

例子中执行的第四个SQL语句，一个SELECT语句，并不触发增长。只有落（写在）在主库上的事务会使GTID计数器数值增长。

>**全局事务ID SQL：高效方案征集**
>客户端端全局事务ID模拟器使用的SQL是低效的。它是为了表述清晰优化的，而不是为性能优化的。请不要在生产环境使用。请帮助我们寻找更高效的方案。我们十分感谢您的贡献。

[**示例 22.241. 插件配置: 抓取GTID的SQL**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "report_error":true
        }
    }
}
```

[**示例 22.242. 在注入后获取GTID**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("DROP TABLE IF EXISTS test"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

printf("GTID after transaction %s\n", mysqlnd_ms_get_last_gtid($mysqli));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("CREATE TABLE test(id INT)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

printf("GTID after transaction %s\n", mysqlnd_ms_get_last_gtid($mysqli));
?>
```
    
上例输出：

```
GTID after transaction 7
GTID after transaction 8
```

应用程序可以询问PECL/mysqlnd_ms 插件该应用程序最后一次执行的写操作的全局事务ID是多少。方法mysqlnd_ms_get_last_gtid返回一个GTID，插件的配置文件有一个章节是global_transaction_id_injection，这个章节当中有一个条目是当运行SQL语句从fetch_last_gtid，这个条目的内容是一个SQL语句，方法mysqlnd_ms_get_last_gtid就返回执行这个语句获得到的GTID。

不建议应用程序运行SQL语句本身，因为着可能引起一个潜在的风险，就是会误增加GTID。同时，如果方法被使用，程序迁移也会很容易，比如，可以迁移到内建MySQL全局事务ID特性的MySQL服务器。

本快速入门手册展示了一个将会返回等于或大于之前的语句执行后的结果的GTID的语句。在语句执行和SELECT语句获得GTID之间的这个时间段，如果没有其他客户端请求使GTID增长，那么此GTID就是之前的语句导致的那个GTID。不然的话，GTID的数值应该变大。

[**示例 22.243. 插件配置：检视某GTID**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "check_for_gtid" : "SELECT trx_id FROM test.trx WHERE trx_id >= #GTID",
            "report_error":true
        }
    }
}
```

[**示例 22.244. 会话一致性服务水平和GTID聚合（combined）**](http://)

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* GTID as an identifier for the last write */
/* GTID 相当于最后写入的表示符 */
$gtid = mysqlnd_ms_get_last_gtid($mysqli);

/* Session consistency (read your writes): try to read from slaves not only master */
/* 会话一致性（读出你的写入）：尝试从从库和主库读 */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION, MYSQLND_MS_QOS_OPTION_GTID, $gtid)) {
    die(sprintf("[006] [%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Either run on master or a slave which has replicated the INSERT */
/* 在主库或者已经复制了这个INSERT的从库上面运行  */
if (!($res = $mysqli->query("SELECT id FROM test"))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

var_dump($res->fetch_assoc());
?>
```

Mysqlnd_ms_get_last_gtid返回的GTID可以被用来当作会话一致性水平的一个选项.会话一致性的交付是要满足读出你的写入这个要求.会话一致性可以通过调用mysqlnd_ms_set_qos来请求。在本例中，插件会在主库或者已经复制了之前的INSERT操作的从库上执行SELECT语句。

PECL/mysqlnd_ms插件将透明的检查所有的在配置当中的从库，通过检查从库上面的GTID表，来查看其是否已经复制了直线的INSERT操作。插件配置文件里面有一个章节是global_transaction_id_injection，该章节里面有一个选项为check_for_gtid，上面的那个检查过程就是通过运行check_for_gtid选项配置的SQL来完成的。请注意，这是一个慢并且大开销的程序。应用程序可以通过减少使用他的次数或者只从主库当中读（除非主控的读负载很高）。

服务器端全局事务ID特性的使用

从MySQL 5.6.5-m8 开始，MySQL复制系统（MySQL Replication system）引入了服务器端全局事务ID特性。服务器会自动生成并维护事务ID。用户不需要关系如何维护他们。不需要进一步设置任何的表，或者设置on_commit模式。客户端模拟器不在被需要了。

客户端可以继续使用全局事务ID来满足自己在从MySQL Replication从库读取信息的会话一致性的要求。算法上面描述的一致。fetch_last_gtid和check_for_gtid选项必须配置为不同的SQL语句。这些语句在下面给出了。请注意，MySQL 5.6.5-m8是一个开发版。服务器实现的具体细节可能会在未来改变，或者为了适配所示的SQL语句。

使用下面的配置文件，任何上面描述的功能都可以与服务器端全局事务ID特性一同使用。mysqlnd_ms_get_last_gtid和mysqlnd_ms_set_qos会和上面描述的一样继续工作。唯一的区别是服务器并不是使用一个有序数值而是使用一个包含服务器描述符和有序数值的字符串。所以用户不能容易的从mysqlnd_ms_get_last_gtid返回的GTID中获得旧的数据。

[**示例 22.245. 插件配置； 使用MySQL 5.6.5-m8内建GTID特性**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "fetch_last_gtid" : "SELECT @@GLOBAL.GTID_DONE AS trx_id FROM DUAL",
            "check_for_gtid" : "SELECT GTID_SUBSET('#GTID', @@GLOBAL.GTID_DONE) AS trx_id FROM DUAL",
            "report_error":true
        }
    }
}
```

[##### 22.9.6.4.8. 缓存整合](#22.9.6.4.8)

>**版本要求，依赖关系和状态**   
>请阅读概念章节，来获得更多关于版本要求，扩展加载顺序和当前状态的信息。


数据库集群能够向外提供不同的一致性等级。从PECL/mysqlnd_ms 1.2.0 开始，已经可以让插件只考虑再能够交付需要的一致性服务水平的集群中的节点中运行任务。比如，如果使用一个集群范围最终一致性的MySQL Replication异步集群，我们可以在任何时候通过使用mysqlnd_ms_set_quos来要求会话一致性（读出你的写）。请阅读服务水平和一致性的引言章节。

[**示例 22.246. 概括: 关于读出你的写入的服务质量**](#22.246)

```php
/* Request session consistency: read your writes */
/* 需要会话一致性：读出你的写 */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
``` 

架设PECL/mysqlnd已经被明确的告知需要提供非会话一致性服务水平的优先级高于最终一致性，作为无效策略用一个客户端端的缓存（配置了TTL）替换一个数据库节点的读请求是可能的。数据库节点和缓存都有可能能够或者不能够提供当前的数据，这个是最终一致性的定义。


用本地缓存替换掉数据库的读访问可以提高整个应用整体的性能并且降低数据库的负载。如果缓存项目能够被其他客户端重用，就能够省略一个数据库访问这样就能降低数据库负载。进一步的，如果一个数据库查询的计算与交付过程要比本地缓存慢，那么系统性能会变得更好。


[**示例 22.247. 插件配置：没有特殊的缓存条目**](http://)

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
    }
}
```

[**示例 22.248. 缓存从库请求**](http://)

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Explicitly allow eventual consistency and caching (TTL <= 60 seconds) */
/* 明确允许最终一致性和缓存（TTL <= 60 seconds）*/
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL, MYSQLND_MS_QOS_OPTION_CACHE, 60)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* To make this example work, we must wait for a slave to catch up. */
/* 为了让本示例工作，我们必须等待主库同步完毕。蛮力风格。*/
$attempts = 0;
do {
  /* check if slave has the table */
  /* 检查从库是否有对应的表*/
  if ($res = $mysqli->query("SELECT id FROM test")) {
    break;
  } else if ($mysqli->errno) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
  }
  /* wait for slave to catch up */
  /* 等待主库同步 */
  usleep(200000);
} while ($attempts++ < 10);

/* Query has been run on a slave, result is in the cache */
/* 查询在主库运行，结果在缓存中*/
assert($res);
var_dump($res->fetch_assoc());
/* Served from cache */
/* 用缓存提供服务 */
$res = $mysqli->query("SELECT id FROM test");
?>
```

上例展示了如何使用缓存特性。首先，你必将服务质量设置为最终一致性和明确允许缓存。这个动作可以通过调用mysqlnd_ms_set_qos来完成。然后，每个只读语句的结果集会被缓存，缓存时间为mysqlnd_ms_set_qos设置的时间。

真正的TTL会比mysqlnd_ms_set_qos设置的时间小，或者持平。通过mysqlnd_ms_set_qos设置的为最大的缓存时间。真正的TTL为设置值减去从库的复制延迟。比如，如果TTL设置为60秒，然后从库报告同步延迟为10秒，那么实际的TTL会被计算为50秒。TTL会针对每个缓存查询单独进行计算。

[**示例 22.249. Read your writes and caching combined**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Explicitly allow eventual consistency and caching (TTL <= 60 seconds) */
/* 明确允许最终一致性和缓存（TTL <= 60 seconds）*/
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL, MYSQLND_MS_QOS_OPTION_CACHE, 60)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* To make this example work, we must wait for a slave to catch up. Brute force style. */
/* 为了让本示例工作，我们必须等待主库同步完毕。蛮力风格。*/
$attempts = 0;
do {
  /* check if slave has the table */
  /* 检查从库是否有对应的表*/
  if ($res = $mysqli->query("SELECT id FROM test")) {
    break;
  } else if ($mysqli->errno) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
  }
  /* wait for slave to catch up */
  /* 等待主库同步 */
  usleep(200000);
} while ($attempts++ < 10);

assert($res);

/* Query has been run on a slave, result is in the cache */
/* 查询在主库运行，结果在缓存中*/
var_dump($res->fetch_assoc());

/* Served from cache */
/* 用缓存提供服务 */
if (!($res = $mysqli->query("SELECT id FROM test")))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
var_dump($res->fetch_assoc());

/* Update on master */
/* 更新主库 */
if (!$mysqli->query("UPDATE test SET id = 2"))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Read your writes */
/* 读取你的写 */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Fetch latest data */
/* 抓取最新数据 */
if (!($res = $mysqli->query("SELECT id FROM test")))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
var_dump($res->fetch_assoc());
?>
```

为了避免进一步的缓存使用,服务质量可以在任何时候变更。如果需要，你可以切换为会话一致性（读出你的写）.如果这样的话，缓存将不再被使用，将直接读取数据。

##### [22.9.6.4.9. 故障转移（Failover)](#22.9.6.4.9)

默认情况下，如果连接到某个主机失败，插件是不会做任何跟故障转移的相关动作的。这样可以避免跟连接状态有关的潜在故障。我们推荐手动的处理类似于失败事务这样的连接错误。你应该捕获异常，重建连接状态，并且重新运行查询，具体示例如下。

如果连接状态没有任何问题，你可以启用自动静默故障转移。根据配置的不同，自动且静默故障转移会在问题或者错误发生之前尝试切换到主库，或者让允许的查询在尝试连接主库前试着连结其它从库。因为自动故障转移不是万无一失的，这些细节将不会在快速入门手册中探讨。这些细节将在下面的概念章节具体给出。


[**示例 22.250. 手动故障转移, 可选自动转移（automatic optional）**]()

```json
  {
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "simulate_slave_failure",
                "port": "0"
            },
            "slave_1": {
                "host": "127.0.0.1",
                "port": 3311
            }
        },
       "filters": { "roundrobin": [] }
    }
  }
```


[**示例 22.251. 手动故障转移**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
/* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

$sql = "SELECT 1 FROM DUAL";

/* error handling as it should be done regardless of the plugin */
/* 错误处理应该在插件之外独立进行 */
if (!($res = $link->query($sql))) {
  /* plugin specific: check for connection error */
  /* plugin specific: 检查连接错误 */
  switch ($link->errno) {
    case 2002:
    case 2003:
    case 2005:
      printf("Connection error - trying next slave!\n");
      /* load balancer will pick next slave */
      /* 负载均衡会挑选下一个从库 */
      $res = $link->query($sql);
      break;
    default:
      /* no connection error, failover is unlikely to help */
      /* 没有连接错误，故障转移帮不到什么。*/
      die(sprintf("SQL error: [%d] %s", $link->errno, $link->error));
      break;
  }
}
if ($res) {
  var_dump($res->fetch_assoc());
}
?>
```

##### [22.9.6.4.10. 分区和分片](#22.9.6.4.10)

我们会因为各种各样的原因使用数据库集群。集群可以提高可用性，容错能力，并且通过将任务分发到多台机器上来提升性能。有时候集群会与分区和分片结合使用，来达到进一步将大的负载的认为化为小的更易于管理的单元。

Mysqlnd_ms插件旨在支持各种各样的MySQL数据库集群。一些风格的数据库集群有内建的分区和分片特性，这些特性的使用是透明的。插件支持两种最常见的方法：MySQL Replication 表过滤,和分片（基于分区）。

MySQL Replication 支持像过滤器一样分区，这允许你建立能够完全或者部分复制主库或者某些表的从库。然后应用程序需要负责根据过滤器规则来选择一个从库。你可以使用mysqlnd_ms node_groups过滤器来手动支持这个点，也可以使用预置（试验）表过滤器。

手动分区和分片通过节点组过滤器（node grouping filter）进行支持，这跟1.5.0及以后版本的SQL hint一样。node_groups过滤器可以让你将一个符号名分配到主库和从库的一个组中。在示例中，主库master_0 和组Partition_A中的slave_0。如何分组完全是你的决定。比如，你可以使用节点组进行分片，或者通过组名来确定分片比如Shard_A_Range_0_100。


[**示例 22.252. 集群节点组**]()

```json
 {
  "myapp": {
       "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "simulate_slave_failure",
                "port": "0"
            },
            "slave_1": {
                "host": "127.0.0.1",
                "port": 3311
            }
        },
        "filters": {
            "node_groups": {
                "Partition_A" : {
                    "master": ["master_0"],
                    "slave": ["slave_0"]
                }
            },
           "roundrobin": []
        }
    }
}
```

示例 22.253. 使用SQL hint 手动分区

```php
<?php
function select($mysqli, $msg, $hint = '') {
  /* Note: weak test, two connections to two servers may have the same thread id */
  /* 注意：弱测试，连接到两个服务器的两个id可能有相同的 thread id*/
  $sql = sprintf("SELECT CONNECTION_ID() AS _thread, '%s' AS _hint FROM DUAL", $msg);
  if ($hint) {
    $sql = $hint . $sql;
  }
  if (!($res = $mysqli->query($sql))) {
    printf("[%d] %s", $mysqli->errno, $mysqli->error);
    return false;
  }
  $row =  $res->fetch_assoc();
  printf("%d - %s - %s\n", $row['_thread'], $row['_hint'], $sql);
  return true;
}

$mysqli = new mysqli("myapp", "user", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* All slaves allowed */
/* 允许所有从库 */
select($mysqli, "slave_0");
select($mysqli, "slave_1");

/* only servers of node group "Partition_A" allowed */
/* 只有在Partition_A这个组的节点被允许 */
select($mysqli, "slave_1", "/*Partition_A*/");
select($mysqli, "slave_1", "/*Partition_A*/");
?>
```

```    
6804 - slave_0 - SELECT CONNECTION_ID() AS _thread, 'slave1' AS _hint FROM DUAL
2442 - slave_1 - SELECT CONNECTION_ID() AS _thread, 'slave2' AS _hint FROM DUAL
6804 - slave_0 - /*Partition_A*/SELECT CONNECTION_ID() AS _thread, 'slave1' AS _hint FROM DUAL
6804 - slave_0 - /*Partition_A*/SELECT CONNECTION_ID() AS _thread, 'slave1' AS _hint FROM DUAL
```

默认情况下，插件会使用所有已经配置的主库和从库服务器来执行查询。但是如果一个查询是以类似于/*node_group*/这样的SQL hint 开头的话，插件会只考虑在node_group组中列出的服务器上执行查询。所以以/*Partition_A*/开头的SELECT查询只会在slave_0上执行。
以下章节由[22.9.6.5. Concepts](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-ms.concepts.html)翻译而来
--------

#### 2.9.6.5 概念

本章节解释了关于mysqlnd_ms插件的架构和相关概念,并且描述了在使用了数据库集群的环境下MySQL replication和mysqlnd_ms对于研发任务的影响.想要成功的使用mysqlnd_ms,阅读和理解这些感念是必须的。

##### 22.9.6.5.1. 体系结构

Mysqlnd复制与负载均衡插件被实现成了一个PHP扩展.他是用C语言写成,并且在PHP环境下运行.在PHP解释器的启动阶段,PHP引擎进行模块初始化的阶段,它被注册为一个mysqlnd插件,用来替换特定的mysqlnd的C语言方法。

在PHP运行时阶段，插件检查每一个从mysqlnd（php）到MySQL服务器的查询。如果一个查询被识别为只读查询，它会被分发到预先配置的从库中的一个上面。语句在如下的情形下会被考虑为一个只读查询，语句以SELECT开头，存在SQL hint /\*ms=slave\*/；在之前的查询中已经选择了一个从库，且当前查询以SQL hint /\*ms=last_used\*/。在其他的所有情况中，查询会被分发到MySQL replication集群主库上面。

为了更好的可移植性，应用程序应该使用MYSQLND\_MS\_MASTER\_SWITCH，MYSQLND\_MS\_SLAVE\_SWITCH和MYSQLND\_MS\_LAST\_USED\_SWITCH预定义的mysqlnd_ms常量，而不是他们的具体的文字值，如/\*ms=slave\*/。

插件会处理主库和从库上的数据库连接的开关。从应用程序的角度来看，它始终只需要处理一个连接。然而，在内部，这个公共连接（句柄）代表着一个由插件管理的网络连接池。插件会使用多个连接自动分配到主库和从库（复数个）的查询。

数据库连接有一个状态，这状态有下列元素组成，事务状态，事务设置，字符集设置，临时表等。只要能够自动并且透明的完成，插件会尝试在所有内部连接中保持相同的状态。在一些不能够很容易的维护所有连接的状态的案例中，如使用BEGIN TRANSACTION时，插件会让用户自己来处理连接状态。

##### 22.9.6.5.2. 连接池和连接切换

复制和负载均衡插件会改变PHP MySQL连接句柄的语义。现有的PHP MySQL扩展（mysqli，mysql，和PDO_MYSQL）的API并不会改变，没有功能的添加和删减。但是在使用插件时，他们的行为会有改变。现有的程序不需要对新的API进行适配，但是他们可能需要被修改因为API的行为有所改变。

插件打破了mysqli，mysql，和PDO_MYSQL链接句柄和MySQL网络链接之间的一对一关系。现在mysqli，mysql，和PDO_MYSQL链接句柄相当于一个本地连接池，该连接池包含了配置好的MySQL replication主库和MySQL replication从库（可以多个）。插件会将查询重定向到主库和从库上面。某些时候，可能有且仅有一个php链接句柄指向MySQL主库服务器。稍后，它可能指向从库之一或者仍然指向主库。控制和替换被PHP MySQL链接句柄引用的网络连接并不是透明的。

每一个MySQL链接都有一个状态。同一个连接池中的链接的状态可以是不同的。无论何时只要插件从一个连接切换到另外一个，当前的用户连接状态有可能改变。应用程序必须感知此变化。

下面的列表列出了连接状态包含的内容。列表的内容可能不全。

* 事务状态/Transaction status
* 临时表/Temporary tables
* 表锁/Table locks
* 会话系统变量和会话用户变量/Session system variables and session user variables
* 使用USE语句设定的当前数据库和其他改变状态的SQL语句/The current database set using USE and other state chaining SQL commands
* 预处理语句/Prepared statements
* 句柄变量/HANDLER variables
* 由GET_LOCK()获得的锁/Locks acquired with GET_LOCK()

连接切换事件发生在查询被执行之前.在下一条语句被执行之前，插件不会切换连接。

>**与Replication相关的问题**
>请检视MySQL手册与replication和相关问题的章节。一些限制可能与PHP插件并不相关，但是是MySQL replication系统的部件或特性。

广播信息

插件的理念是当连接状态完全在插件的控制下或者出于安全的原因，校准统一连接池中连接的状态。只有改变连接状态的少部分动作会落到这种类别上。

下面是一个会改变连接状态，并且被广播到连接池中所有连接的客户端调用的列表。

如果任何下列的调用被执行，插件会遍历所有打开的主库和从库连接。这个遍历的动作会持续的进行下去，直到所有的服务器都被接触过，及时是某个服务器返回失败，遍历也不会停止。

| 库调用 | 说明 | 版本 |   
| :-- | :-- | :-- |   
| change_user() | 被mysqli\_change\_user用户API调用。Also triggered upon reuse of a persistent mysqli connection. | Since 1.0.0. |
| select_db|	Called by the following user API calls: mysql_select_db, mysql_list_tables, mysql_db_query, mysql_list_fields, mysqli_select_db. Note, that SQL USE is not monitored.|	Since 1.0.0.|
| set_charset()|	Called by the following user API calls: mysql_set_charset. mysqli_set_charset. Note, that SQL SET NAMES is not monitored.|	Since 1.0.0. |
| set_server_option()|	Called by the following user API calls: mysqli_multi_query, mysqli_real_query, mysqli_query, mysql_query.|	Since 1.0.0. |
| set_client_option()|	Called by the following user API calls: mysqli_options, mysqli_ssl_set, mysqli_connect, mysql_connect, mysql_pconnect.|	Since 1.0.0. |
| set_autocommit()|	Called by the following user API calls: mysqli_autocommit, PDO::setAttribute(PDO::ATTR_AUTOCOMMIT).|	Since 1.0.0. PHP >= 5.4.0. |
| ssl_set()|	Called by the following user API calls: mysqli_ssl_set.|	Since 1.1.0. |

广播和惰性连接


插件不会代理或者“记住”全部的设置，以便将这些设置应用在之后打开的连接上。如果使用惰性连接，记住这点很重要。惰性连接是在客户端发送第一个连接之前不会打开的连接。插件默认的行为是使用惰性连接。

下列的连接库调用都会改变连接状态，他们的执行会被记录下来，以供之后打开的惰性连接时使用。这可以帮助确保连接池中的所有连接的连接状态都是可比较的。

| 库调用 | 说明 | 版本 |   
| :-- | :-- | :-- |  
| change_user()	| User, password and database recorded for future use. | Since 1.1.0. |
| select_db	| Database recorded for future use. | Since 1.1.0. |
| set_charset()	| Calls set_client_option(MYSQL_SET_CHARSET_NAME, charset) on lazy connection to ensure charset will be used upon opening the lazy connection.	| Since 1.1.0.|
| set_autocommit()	| Adds SET AUTOCOMMIT=0\|1 to the list of init commands of a lazy connection using set_client_option(MYSQL_INIT_COMMAND, "SET AUTOCOMMIT=...%quot;).	| Since 1.1.0. PHP >= 5.4.0. |

>**连接状态**
>连接状态不仅仅可以被API调用改变。所以，及时PECL/mysqlnd_ms监控所有API调用，应用程序仍然需要有感知连接状态改变的能力。最终的结论是应用程序需要有在需要的时候维护连接状态的能力。

字符集和字符转译

由于默认使用惰性连接，就有可能发生应用程序尝试在连接建立之前转译一个字符串以用在SQL语句之中的情况。在这种情况下，字符串转译是不可能的。在连接被建立之前，字符串转译函数并不知道应该使用什么字符集。

为了解决这个问题，一个新的配置选项 server_charset 在1.4.0版本中被引入.

必须要注意这种情况：用一种字符集转义字符串，但却在使用不同字符集的连接上使用其结果。请注意，PECL/mysqlnd_ms 插件会控制连接，且一个应用成寻的连接会表现为一个可能有不同的默认字符集的多连接连接池。推荐手动配置所有相关的服务器使其使用相同的默认字符集。设置选项 server_charset在这种情况下也能够起到相同的作用。如果使用server_charset选项，插件会在所有新打开的连接上设置为配置号的字符集。

#####22.9.6.5.3. 事务处理

事务处理被从根本上改变了.一个SQL事务是一个在数据库上运行的工作单元。这个工作单元包括一个或多个SQL语句。

默认情况下，插件不能够感知SQL事务。插件可以为了负载均衡在任何时间点切换连接。连接的切换可能发生在一个事务的执行期间。这点与SQL事务的性质相违背的。默认情况下，插件是非事务安全的。

不管那种MySQL负载均衡器都必须被提示事务的边界在哪，也就是事务的开始和结束都需要想办法提示给负载均衡器。提示可以通过隐式的监控API调用或使用SQL Hint来实现。根据PHP版本的不同，两种方法都可以被插件支持。API监控需要PHP 5.4.0及以上版本。如同其他的MySQL负载均衡器一样，插件不能够根据MySQL客户端服务器协议（MySQL Client Server Protocol）探测事务边界。所以，完全透明的事务感知负载均衡是不可能实现的。侵入性最小的选项便为API监控，根据你的程序的具体情况，不需要更改程序，或者只需要更改程序很小的一部分。

请阅读示例章节的关于使用SQL Hint或API监控的使用示例。关于API监控可以如何赋予插件事务感知能力的背后的细节将在下面描述。

从PHP 5.4.0开始，mysqlnd 库允许本插件继承该库的C API调用set_autocommit()，用来判定autocommit模式的状态。

PHP MySQL扩展会调用一个查询（如，SET AUTOCOMMIT=0|1），或者使用mysqlnd的库调用set_autocommit()来控制autocommit模式的设置。如果一个扩展使用set_autocommit()调用，插件便能够做到事务感知。如果使用SQL语句来设置autocommit mode，是无法做到事务感知的。
库函数set_autocommit()会被 mysqli_autocommit 和PDO::setAttribute(PDO::ATTR_AUTOCOMMIT) 用户API 调用集调用。

插件设置选项trx_stickiness=master可以被用来实现插件的事务感知。在这种模式下，如果autocommit被禁用，插件会停止负载均，开始分发所有语句到主库直到autocommit模式再次生效。

一个不想要为事务设置SQL hint但是想要使用透明API监控来避免程序改变的应用程序必须确保autocommit设置只能够通过列出的API调用来进行更改。

基于API的事务边界探测在PHP 5.5.0和PECL/mysqlnd_ms 1.5.0中被改进了，他们不仅支持 mysqli_autocommit调用，而且也支持 mysqli_begin， mysqli_commit和mysqli_rollback调用。

##### 22.9.6.5.4. 错误处理

使用PECL/mysqlnd_ms的应用程序需要含有适当的容错机制来应对所有的用户API调用。并且因为插件会改变一个连接句柄的语义，API调用可能会返回出乎意料的错误。如果在一个并不代表单独的网络连接，而是一个连接池的连接句柄上使用插件，当连接池中的任何一个连接发生发生错误时，错误代码和错误消息都会被发送到连接句柄上。

如果使用默认的惰性连接，连接一开始不会建立，直到有查询需要执行时，连接才会打开。所以，一个语句执行的API调用可能返回一个连接错误。在下例中，一个错误在试图在从库上面运行一个语句时被引发。因为连接配置文件中列了一个无效的从库主机名，所以打开一个从库连接会失败。

Example 22.254. 引发连接错误。

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "invalid_host_name",
            }
        },
        "lazy_connections": 1
    }
}
```

显式的激活惰性连接，仅作演示用。

示例 22.255. 查询执行时连接错误。

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Of course, your error handling is nicer... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connection 1, connection bound SQL user variable, no SELECT thus run on master */
/* 连接 1，连接与SQL用户变量绑定，没有SELECT语句会运行在主库上面。*/
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connection 2, run on slave because SELECT, provoke connection error */
/* 连接 2，因为有SELECT语句，所以在从库运行，激发连接错误。*/
if (!($res = $mysqli->query("SELECT @myrole AS _role"))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
```
上例会输出与下面类似的内容:

```php
PHP Warning:  mysqli::query(): php_network_getaddresses: getaddrinfo failed: Name or service not known in %s on line %d
PHP Warning:  mysqli::query(): [2002] php_network_getaddresses: getaddrinfo failed: Name or service not known (trying to connect via tcp://invalid_host_name:3306) in %s on line %d
[2002] php_network_getaddresses: getaddrinfo failed: Name or service not known
```
希望应用程序能够部署合适的错误处理机制来出来可能的连接错误。

根据使用案例，程序可能需要采用与处理其他错误不同的机制连处理连接错误。典型的连接错误是 2002 (CR_CONNECTION_ERROR) - Can't connect to local MySQL server through socket '%s' (%d)，2003 (CR_CONN_HOST_ERROR) - Can't connect to MySQL server on '%s' (%d) 和 2005 (CR_UNKNOWN_HOST) - Unknown MySQL server host '%s' (%d)。比如说，程序可能要探测错误代码并且手工执行一个故障转移。插件的基本思想是除了主库的故障转移以外，不提供自动故障转移，因为故障转移不是一个透明的操作。

示例 22.256. 激发连接错误

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "invalid_host_name"
            },
            "slave_1": {
                "host": "192.168.78.136"
            }
        },
        "lazy_connections": 1,
        "filters": {
            "roundrobin": [

            ]
        }
    }
}
```

为了演示的目的,这里明确的激活惰性连接,round robin负载均衡模式会覆盖默认的random once模式.

示例 22.257. 基本故障转移

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Of course, your error handling is nicer... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connection 1, connection bound SQL user variable, no SELECT thus run on master */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connection 2, first slave */
$res = $mysqli->query("SELECT VERSION() AS _version");
/* Hackish manual fail over */
if (2002 == $mysqli->errno || 2003 == $mysqli->errno || 2004 == $mysqli->errno) {
  /* Connection 3, first slave connection failed, trying next slave */
  $res = $mysqli->query("SELECT VERSION() AS _version");
}

if (!$res) {
  printf("ERROR, [%d] '%s'\n", $mysqli->errno, $mysqli->error);
} else {
 /* Error messages are taken from connection 3, thus no error */
 printf("SUCCESS, [%d] '%s'\n", $mysqli->errno, $mysqli->error);
 $row = $res->fetch_assoc();
 $res->close();
 printf("version = %s\n", $row['_version']);
}
$mysqli->close();
?>
```

上例会输出类似于下面的内容:

[1045] Access denied for user 'username'@'localhost' (using password: YES)
PHP Warning:  mysqli::query(): php_network_getaddresses: getaddrinfo failed: Name or service not known in %s on line %d
PHP Warning:  mysqli::query(): [2002] php_network_getaddresses: getaddrinfo failed: Name or service not known (trying to connect via tcp://invalid_host_name:3306) in %s on line %d
SUCCESS, [0] ''
version = 5.6.2-m5-log

在一些案例中，有可能不能方便的获取发生在一个连接句柄上的所有的网络连接上的所有错误。比如说，让我们假设一个连接句柄代表着一个包含三个连接的连接池。一个连接连接到主库，其余的两个连接连接到从库。应用程序使用用户API调用mysqli_select_db来更改当前使用的库，该API会去调用mysqlnd 库函数去更改数据库。mysqlnd_ms会监控这个函数，并且尝试在所有连接上面改变当前连接的数据库，让所有连接的连接状态同步。现在，假设已经成功的改变了主库，但是两个从库都变更失败了。一旦第一个从库连接发生了错误,插件会在连接句柄上面报出一个恰当的异常(错误)。当第二个从库连接切换数据库失败后，插件也会做同样的事情。第一个从库连接的错误会被第二个覆盖。

这样的案例可以通过检查错误类型为E_WARNING（见上）的错误或者通过分析 mysqlnd_ms debug and trace log来进行调试。

##### 22.9.6.5.5. 瞬态错误

一些分布式数据库集群使用瞬态错误。瞬态错误是一个很和能很快就消失的临时错误。根据瞬态错误的定义，在一个数据库服务器上忽略一个瞬态错误并且重新尝试执行之前失败的操作是安全的。重试操作无副作用。客户端不会立刻被强制放弃之他们的工作并执行故障转移到另外一台服务器上。在放弃在此服务器上执行任务之前，这些工作会进入一个重试回路来等待错误消失。瞬态错误可以被发现，比如说，当使用MySQL Cluster时就可以。但是他们没有被集成到任何特定的集群方案本身上面。

PECL/mysqlnd_ms 在遇到一个瞬态错误时可以自动执行一个重试回路。这种机制增加了分发的透明度，从而降低在不改变应用程序源码的条件下将应用从一个单一数据库环境迁移到一个数据库集群上面的难度。

自动重试回路会按照用户配置的重试次数和重试间隔重复被请求的操作。如果错误在回路过程中消失，应用程序将永远不会看到这个错误。如果错误没有消失，错误会被转发到应用程序进行处理。

在下面的例子中，一个重复键错误被故意激发，使插件在将错误传递给应用程序重试之前失败的查询2次.在两次重试的间隔使100毫秒。

示例 22.258. 激发瞬态错误

```json
mysqlnd_ms.enable=1
mysqlnd_ms.collect_statistics=1

    

{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.78.136",
                "port": "3306"
            }
       },
       "transient_error": {
          "mysql_error_codes": [
            1062
          ],
          "max_retries": 2,
          "usleep_retry": 100
       }
    }
}
```

示例 22.259. 瞬态错误重试回路

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Of course, your error handling is nicer... */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT PRIMARY KEY)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1))")) {
  printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Retry loop is completely transparent. Checking statistics is
 the only way to know about implicit retries */
$stats = mysqlnd_ms_get_stats();
printf("Transient error retries before error: %d\n", $stats['transient_error_retries']);

/* Provoking duplicate key error to see statistics change */
if (!$mysqli->query("INSERT INTO test(id) VALUES (1))")) {
  printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

$stats = mysqlnd_ms_get_stats();
printf("Transient error retries after error: %d\n", $stats['transient_error_retries']);

$mysqli->close();
?>
```

上例会输出类似于下面的内容:

Transient error retries before error: 0
[1062] Duplicate entry '1' for key 'PRIMARY'
Transient error retries before error: 2

因为从用户的角度来看,重试回路的执行是透明的，所以示例检查插件提供的统计数据，来了解重试回路的情况。

如同示例展示的，插件可以被配置为考虑任何瞬时错误，而不用去理会数据库服务器的错误语义规则。原生的MySQL服务器只会考虑唯一一个错误为临时错误，该错误的错误代码为1297。当需要配置除了1297以外的错误代码时候，务必要保证你的配置与你的集群的错误代码的语义相容。

下面的mysqlnd C API 调用会被插件监控用以检查瞬态错误：query()，change_user()，select_db()， set_charset()，set_server_option() prepare()，execute()，set_autocommit()，tx_begin()，tx_commit()，tx_rollback()，tx_commit_or_rollback()。与他们相对应的用户API调用有着相似的名字。

插件的重试回路的最大间隔取决于一个还在讨论中的功能。对于query()，prepare()或者execute()的重试间隔最大可以为max_retries * usleep_retry毫秒。

然而，连接状态控制功能被分发到了所有连接。重试回路的设置会被应用到命令需要执行的每一个连接。因此，这种功能可能会中断比一个函数在一个服务器上运行的时间厂的程序的运行。例如，set_autocommit()被分发到连接上并且可能可以间隔(max_retries * usleep_retry) * number_of_open_connections) 毫秒。当设置一个长的间隔和大的重试次数的时候请格外注意上面这点。使用默认的设置max_retries=1，usleep_retry=100，lazy_connections=1 的时候你应该不会看到一个多余一秒的延迟。

##### 22.9.6.5.6. 故障转移

默认情况下，连接的故障转移要由用户来处理。应用程序需要检查它所调用的数据库函数返回的数值，并且对可能的错误做出反应。例如，如果插件识别出一个查询为只读查询，该查询将要被发送到从库服务器上，并且插件选择的从库服务器不可用，插件会在不执行语句之后吐出一个错误。

Default: manual failover
默认：手动故障转移

应由程序处理错误，如果需要的话，程序需要重新发起查询请求以触发集群选择另外一个从库来执行语句。插件将不会尝试进行自动的故障转移，因为插件不能确定自动的故障转移不会改变连接状态。例如，应用程序可能在一个基于已经被绑定到一个特定的连接上的SQL用户变量的查询上面出问题。如果插件做了自动故障转移，它可能隐式的切换了连接，这样的查询可能会返回不正确的结果。想要保证正确的结果，应用程序必须关注故障转移，并且要重建必要的连接状态。所以，默认情况下，插件不提供自动故障转移。

如果用户在打开连接后不会更改连接状态，那么可以激活自动故障转移。请注意：自动故障转移的逻辑是局限于连接尝试的。自动故障转移不能被应用于已经建立的连接上面。没有办法让插件尝试在一个已经在过去连接到MySQL服务上的连接上面进行故障转移的。

Automatic failover
自动故障转移

故障转移策略在插件配置文件中有配置项，可以适用故障转移配置命令进行配置。

自动且静默的故障转移可以通过故障转移命令进行配置生效。自动故障转移可以被配置为在从库失败之后尝试一个指定的主库，或者，在返回给用户一个错误之前轮循从库和主库。尝试连接的次数是可以被限制的，并且已有故障的主机可以排除在未来的负载均衡行为之外。限制重试次数并且记住故障主机仍被视为实验性的特性，尽管这两个特性已经看起来比较稳定。这些特性的语法和语义解析规则可能会在未来版本中改变。

请注意，从1.5.0版本开始，如果连接粘性（transaction stickiness）特性激活且连接边界被探测到后，自动故障转移会在一个事务进行的期间被禁用。插件不会在事务进行期间切换连接。同时，也不会进行自动，静默故障转移。但是一个错误将会被吐出。事务的失败会交给用户进行处理。请检视，trx_stickiness 特性的相关文档来了解具体的做法。

错误处理章节包含了一个基本的手动故障转移示例。

Standby servers
备用服务器

如果使用加权故障转移，（这个特性在PECL/mysqlnd 1.4.0 中被引进。）你可以配置备用服务器（备用服务器很少在普通的操作中被用到。）
一个备用服务器主要被用来在碰到最差的情况下作为故障转移的目标，备用服务器可以被分配为一个很低的权值/优先级（比其它所有的服务器都低）。只要所有的服务器都在线并且高权值服务器正在承担被分配的主要负载。那么只会有非常少的请求会被分发到有着很低权值的备用服务器。

一旦拥有高权值的服务器故障，你仍可以故障转移到备用服务器，备用服务器通过被设置一个低的权值的方式赋予了一个低的负载均衡优先级。故障转移可以某种程度的手动或者自动。如果自动完成故障转移，你需要将其与remember_failed 相结合使用。

在这一点上，想要让负载均衡器彻底不向备用服务器分配任何任务是不可能的。鉴于你可以给一台服务器设定的最高权值是65535，这应该不是什么问题。对于给定的两台从库服务器，起到备用服务器作用的那台可以设定为权值为1，这样备用服务器将会处理远远小于总负载1%的负载。

Failover and primary copy
故障转移和主从复制

请注意, 如果使用主从复制集群，如MySQL Replication，想要在主库失败的时候来进行连接故障转移是很难的。在任何时候，对于一个给定的数据集，集群当中只有一个主库。如果主库挂掉，来自客户端的写请求，将没有故障转移的目标。如果遇到主库运行中断的现象，在必要的时候，数据库管理员必须关注这个情况并且更新客户端的设置。

##### 22.9.6.5.7. 负载均衡

插件支持四种分发语句到配置好的从库的负载均衡策略。

**随机/random**
>在语句执行时，随机选择一个服务器。

**一次随机（默认）/random once (default)**
>在第一个条语句执行后随机选择一个服务器，在之后的PHP请求中一直使用这个选择。
>此为默认选项，这个模式对连接状态的影响最小。

**轮循/round robin**
>轮流使用配置好的服务器列表中的服务器。

**通过回调进行用户自定义/user-defined via callback**
>可以通过这种模式部署其他的策略。

通过插件的配置文件使用random, roundrobin, 和 user filters 来配置负载均衡策略。
服务器可以被赋予权值。一个被给定权值位2的服务器会处理给定权值位1的服务器的2倍的请求。加权的方法在异构的环境中会有很好的效果。例如，你可以给性能好的机器分配更多的请求。异或，你可以根据逻辑路径的长短（通常对延迟有影响）来配置不同的机器。

##### 22.9.6.5.8. 读写分离

插件会在配置好的MySQL从库上面执行只读的语句，会在MySQL主库上面执行其他所有的查询。满足以下条件之一的会被考虑为只读语句，以SELECT关键字开头，包含SQL hint /*ms=slave*/，或者在之前的查询运行是已经有一个从库被选择，并且当前的查询以SQL hint /*ms=last_used*/ 开头。其他的所有案例中，查询都将会被发送到MySQL replication 主库服务器。推荐使用常量 MYSQLND_MS_SLAVE_SWITCH , MYSQLND_MS_MASTER_SWITCH 和 MYSQLND_MS_LAST_USED_SWITCH 来代替 /*ms=slave*/。请参见 mysqlnd_ms 常量列表。

SQL hint是一种特殊类型的符合标准的SQL注释。插件会检查每条语句是否存在特定的SQL hint。SQL hint是插件声明的常量的一部分，在mysqlnd_ms常量文档中会有详细的描述。其他与语句处理有关的系统，比如MySQL服务器，SQL防火墙，SQL proxy，并不被SQL hint 影响，因为那些系统被设计成忽略SQL注释。

一个用户定义的读写分离器可以请求内建的逻辑来发送语句到特定的地点，可以通过激活mysqlnd_ms_is_select来达到这个目的。

>**注意**
>内建的读写分离器不是多重语句感知的。多重语句被视为一个语句，分配器会检查语句的开头来决定在何处运行该语句。例如，如果一个多重语句以 ```SELECT 1 FROM DUAL; INSERT INTO test(id) VALUES (1); ...```开头，尽管语句不是只读的插件仍然会只在从库运行它。

##### 22.9.6.5.9. 过滤器

>**版本需求**
>过滤器特性在mysqlnd_ms 1.1.0-beta被引入。

过滤器。使用了MySQL replication集群的PHP应用在一个语句被执行前必须先确定一个可以执行语句的集群中的一个服务器组。换句话说，一个预先定义好的服务器列表必须被过滤掉，指导只有一个服务器是可用的。

这个过滤的过程可能包含一个或多个过滤器，且过滤器可以被链接在一起。它们会按照在插件配置文件中定义的顺序去执行。

>**说明：比较过滤器链和管道**
>过滤器链的概念可以跟在操作系统的CLI界面使用管道来链接系统实用工具来做类比。例如，一个输入流需要经过处理器，过滤器，之后转到输出队列。之后，输出会作为下一个命令的输入，它们通过管道符来进行链接。

可用的过滤器：
* 负载均衡过滤器：随机（random）和轮循（roundrobin）。
* 选择过滤器： user, user_multi, quality_of_service。

随机过滤器实（random）现了‘随机’和‘一次随机’两种负载均衡策略。‘轮循’负载均衡策略可以通过轮循过滤器（roundrobin）被设置。可以通过用户过滤器（user）来为服务器设置‘用户自定义回调’的服务器选择模式。quality_of_service过滤器找到集群中的可以交付特定的负载能力的节点，如，读出你的写（会话一致性），或者落后于比允许的值更长的时间的从库。

过滤器可以通过接收参数来改变它们的行为。随机过滤器（random）可以接收一个可选的sticky参数。如果该参数为真，过滤器会将负载均衡策略由随机变更为一次随机。随机的意思是每个语句要被执行的时候每次选择一个随机的服务器。一次随机的意思是在第一个语句需要被执行的时候随机选择一个服务器，剩余的PHP请求将使用这台服务器响应。

过滤器的概念当中的最大的优势之一便是可以将多个过滤器链接起来。这点优势不会立刻体现出来，因为random, roundrobin 和 user过滤器应该输出不多于一台服务器。如果一个过滤器将备选的运行语句的服务器数量从一个列表减少到了只有一台服务器，那么为了减少备选服务器的数量使用一台服务器作为另外一个过滤器的输入将变得没有意义。

一个过滤器排序不当的例子：

* 待运行语句：SELECT 1 FROM DUAL. 已经通过了所有的过滤器。
* 所有配置了的节点都被视为第一个过滤器的输入。主库节点：master_0。 从库节点：slave_0, slave_1。
* 过滤器：random，参数：sticky＝1.随机选择一个从库，来响应之后的所有PHP请求。输出：slave_0。
* slave_0的输出和待执行语句被视作下一个过滤器的输入。在这里，下一个过滤器是：roundrobin，传递给过滤器的服务器列表为：slave_0。
* 过滤器：roundrobin。服务器列表仅包含一台服务器，轮循将会总是返回相同的服务器。

如果尝试使用这样的一个过滤器顺序，插件会吐出一个形如```(mysqlnd_ms) Error while creating filter '%s' . Non-multi filter '%s' already created. Stopping in %s on line %d```的例子。并且，一个对应的错误有可能被放置到链接句柄上面。

第二种过滤器存在的形式：多重过滤器。一个多重过滤器会在处理完毕后吐出零个，一个或者多个服务器.quality_of_service过滤器便是一个例子。如果服务质量请求设置了一个从库延迟上限并且一个从库的延迟没有达到上限，过滤器会返回多余一个的集群节点。一个多重过滤器后面必须要有其他过滤器来进一步的减少执行语句的备选服务器的数量直到一个候选者被找到。

一个还有quality_of_service多重过滤器并且后面接着一个负载均衡过滤器的过滤器排序示例：

* 待执行语句：```SELECT sum(price) FROM orders WHERE order_id = 1```。传给了所有过滤器。
* 所有配置的节点都被视为第一个过滤器的输入。主库节点：master_0。从库节点：slave_0, slave_1, slave_2, slave_3。
* 过滤器：quality_of_service，规则：会话一致性（session_consistency）。输出：master_0
* master_0的输出和待执行语句被视为下一个过滤器的输入，下一个过滤器为roundrobin（轮循）。
* 过滤器：roundrobin。服务器列表包含一个服务器。所以轮循策略选择master_0。

一个过滤器队列不能以多重过滤器结尾。如果试图使用一个以多重过滤器结尾的过滤器队列，插件可能会吐出形如```(mysqlnd_ms) Error in configuration. Last filter is multi filter. Needs to be non-multi one. Stopping in %s on line %d```的警告。并且，一个对应的错误有可能被放置到链接句柄上面。

> **预测特性：MySQL replication 过滤器**
> 在未来的版本中,可能会增加多重过滤器。比如，可能会有一个表过滤器（table）来支持MySQL replication过滤。这将允许你定义规则，来规定特定的数据库或者表来复制到replication集群中特定的节点上。假设你的replication集群包含4个从库（slave_0, slave_1, slave_2, slave_3），其中两个从库（slave_0, slave_1）复制了一个叫做sales的数据库。如果应用查询了数据库slaves，那么假设的table过滤器会将可能执行查询的服务器列表减少到slave_0 和 slave_1。因为过滤器的输出和备选服务器列表包含一个以上的服务器，所以，有必要和可能要进一步给备选列表加入一个过滤器，比如，使用负载均衡过滤器（load balancing）来确定语句在哪个服务器上执行。

##### 22.9.6.5.10. 服务水平和一致性

> **版本要求**
> 服务水平特性在mysqlnd_ms 1.2.0-alpha 版本被引进。
> mysqlnd_ms_set_qos 需要PHP 5.4.0及以上版本。

本插件可以于很多不同的MySQL数据库集群一同使用。不同的集群可以对应用提供不同的服务水平。服务水平可以按照其能达到的数据一致性水平被分类。插件现在可知：

* 最终一致性
* 会话一致性
* 强一致性

根据集群的被使用的方法不同,有可能达到比默认的服务水平更高的服务水平。比如，一个从一个异步的MySQL replication从库做的读操作是最终一致的。这样，也许可以这样说，一个MySQL replication集群的默认的一致性水平是最终一致性。然而，如果一个客户端在一个绘画中使用了master only模式进行读写的话，集群会交付会话一致性（读出你的写）。PECL mysqlnd 1.2.0 将怎么选择合适的节点来满足上述的服务器水平的具体细节与用户剥离了（用户不需要关心这些细节）。

服务水平可以通过插件配置文件中的qualify-of-service过滤器选项进行设置，也可以在运行时通过调用mysqlnd_ms_set_qos方法进行设置。

插件对于不同的服务水平的定义如下：

最终一致性是异步集群提供的默认的服务，比如经典的MySQL replication。在任意一个节点执行一个读操作都可能会（也可能不会）返回脏数据。但是从应用的角度来看数据是最终一致的。

会话一致性是保证一个客户端可以随时读出自己的写。如果客户端在第一个写之后总是使用主库或者从来不对还没有复制客户端的写操作的从库进行查询的话，一个异步的MySQL replication集群可以交付会话一致性。

插件理解的强一致性是一个客户端总能看到其他全部客户端的所有提交过的写。当使用MySQL Cluster或者任何其他的能够提供异步数据分发的集群的时候，默认要满足强一致性。

*服务水平参数*

最终一致性和会话一致性服务等级可以接受参数。

经典的MySQL  replication可以提供最终一致性的服务。默认情况下，所有节点都可以响应读请求。一个可选的参数age可以来过滤出与主库延迟超过特定秒的从库。插件使用SHOW SLAVE STATUS来计量延迟，请检视MySQL参考手册来了解SHOW SLAVE STATUS命令的精确性和可靠性。

会话一致性（读出你的写）接收一个可选的参数GTID，基于该参数会话一致性服务水平会考虑不仅从主库读取数据，同时也从已经复制了特定的由其事务标识符描述的写的从库上面读取数据。这样的话，当使用异步MySQL replication时候，读请求可以在仍然保证会话一致性的前提下被负载均衡机制分发到从库上面。

之后需要使用[客户端端全局事务ID注入]特性

*新方法的优点*

新的方法在某些方面取代了SQL hint 和配置选项master_on_write的使用。如果一个运行在一个异步MySQL replication 集群上的应用程序的某些读请求不能接受旧数据，告知插件来选择合适的节点要比将所有的读语句之前都加上SQL hint 前缀来保证使用主库要简单的多。此外，插件还可能能够使用选定的从库来响应读请求。

master_on_write配置选项会令插件在第一个写之后使用主库（会话一致性，读出你的写）。在一些案例中，可能只有一部分，很少的读操作需要会话一致性，会话中其余的读操作并不需要会话一致性。这样，master_on_write选项可能会导致主库会加载过多的读请求（超过必要的程度）。在那些案例中，只针对确实需要的读操作来请求一个高于默认服务水平的服务水平是更好的选择。一旦读操作结束，应用程序可以返回默认的服务水平。在不同的服务水平之间切换只能使用[mysqlnd_ms_set_qos]

*关于性能的注意事项*

一个MySQL replication集群不能告知客户端那些从库是有能力交付何种服务水平的服务。所以，在一些案例中，客户端需要向从库发送查询请求来检查他们的状态。PECL mysqlnd_ms 会透明的在后台执行必要的SQL语句来进行上述操作。然而，这是一个昂贵且缓慢的操作。如果最终一致性指定了从库延迟或者会话一致性与全局事务ID进行了绑定，响应的SQL语句就会被执行。

如果最终一致性指定了最大的从库延迟，插件会为每个语句执行和负载均衡按照如下的规则选择候选者。如果语句是一个写语句，所有的主库都会被考虑为候选者，从库不会被标记同时也不会被考虑为候选者。如果语句是是读语句，插件会在每个从库连接上面透明的执行SHOW SLAVE STATUS。它会遍历所有的链接，发送语句并且开始检查结果。一般情况下，这比遍历所有的链接发送查询并且等待返回结果稍微快一点。一个从库会在SHOW SLAVE STATUS返回的结果为：Slave_IO_Running=Yes, Slave_SQL_Running=Yes 且Seconds_Behind_Master小于等于可允许的最大延迟情况下被考虑为候选者。为了放置SQL错误，插件会吐出一个警告但是不会在连接上放置一个错误。错误没有被设置为可以将插件作为链接切断器使用。（需要进一步调整）

如果绘画一致性结合了全局事务ID，插件会执行SQL语句由插件配置文件中global_transaction_id_injection章节的fetch_last_gtid配置项所设置的语句。进一步的细节与上面所描述的是相同。

在 1.2.0版本中，对于执行后台查询并没有进一步地优化。未来地版本可能会包含响应地优化，这要取决于用户需求。

如果没有参数和选项被设置，没有SQL被需要。在那个案例中，插件会考虑下面所列地所有类型地节点。

* 最终一致性，没有多余选项设置：所有主库，所有从库
* 会话一致性，没有多余选项设置：所有主库
* 强一致性（没有选项被允许）：所有主库

*抑制*

服务质量过滤器可以同[全局事务ID]绑定来抑制客户端。抑制的动作会通过降低客户端请求速度的方式来减少主库上面的写负载。如果会话一致性被要求并且全局事务ID被用来检查从库的状态，这个检查过程可以通过两种方式完成。默认情况下，一个从库会被检查，如果其不匹配会话一致性的要求，它会被直接跳过。另外，插件可以等待从库与主库同步，一直到可能满足会话一致性要求。如需开启抑制，你可以设置[wait_for_gtid_timeout]配置选项。

##### 22.9.6.5.11. 全局事务ID

> *版本需求*
> 客户端端全集事务ID注入在 mysqlnd_ms 1.2.0-alpha版本中被引进.
> 事务边际会被监控API调用探测。这个特性在PHP 5.4.0中被引入。请检视[事务处理]
>
> 从 MySQL 5.6.5-m8 版本开始，MySQL 服务器内建全局事务ID特性。
> MySQL 内建的全局事务ID特性由 PECL/mysqlnd_ms 1.3.0-alpha及之后的版本支持。使用该服务器特性不需要客户端端事务边界监控或者任何设置的动作。

*理念和客户端端模拟器*

PECL/mysqlnd_ms可以执行客户端端透明全局事务ID注入。在最基本的形式下，一个全局事务ID是一给我随着每一个在主库上执行的事务而增长的计数器。这个计数器被保存在主库上的一个表上面。从库会复制这个计数器表。

一旦主库故障，数据库管理员可以简单的标记最近使用的从库来升级为主库。最近使用的从库由着最大的事务ID。

应用程序开发者向插件请求程序最后一次成功执行写操作的全局事务ID（GTID）。插件会返回一个指向不旧于客户端最后一次写操作的事务的ID。其次，GTID可以被当作参数传递给服务质量（QoS）过滤器，作为会话一致性的一个选项。会话一致性可以会保证你可以读出你的写入。过滤器会保证所有的读操作要么被分发到一个主库上，要么被分发到已经复制了所需的GTID的标识的数据的从库上。

*当注入完成时*

插件透明的在主库上维护GTID表。在aotocommit模式下，每次使用主库的时候，插件都会在执行用户语句之前注入一个[UPDATE]语句。在manual transaction 模式下，注入会在程序调用[commit()]来关闭事务前结束。插件配置文件中的GTID章节的配置选项*report_error*被用来控制一个失败的注入是应该取消当前的操作还是直接被静默的忽略掉（默认）。

请注意，[事务边界监控]有PHP 版本的要求,另外有一些局限

*局限*

客户端端全局事务ID注入存在着缺点。这些潜在的问题并不是PECL/mysqlnd_ms特有而是一些通性问题。

* 全局事务ID表必须在所有主库和副本上面进行部署。
* GTID可能缺失。只有使用了插件的PHP客户端才会维护GTID表。其他的客户端不会。
* 客户端端事务边界探测是基于且仅基于API调用的。
* 客户端端事务边界探测不会隐式的提交到帐户中。一些MySQL SQL语句会引起一个隐式提交，这个动作不能被回滚。

*使用服务器端全局事务ID*

从PECL/mysqlnd_ms 1.3.0-alpha开始，MySQL 5.6.5-m8及后续版本的内建的全局事务ID特性得到了支持。使用服务器端的特性可以避免上面列出的所有局限。请参见MySQL参考手册来获取使用服务器内建全局事务ID的先决条件和局限。

究竟是使用客户端端模拟器还是服务器内建功能与插件本身并不直接相关，所以本手册不会深入探讨。没有计划会移除客户端端模拟器，如果使用服务器端方案不可行，你可以一直使用客户端端模拟器。这可能是在有老版本MySQL服务器或服务器端方案存在着不可接受的限制是时的案例的替代方案。

从应用程序的角度来说，两种实现几乎没有差别。下面是一些属性上的不同。

* 客户端端模拟，如同手册中展现的，使用易于比较的顺序数字来作为全局事务ID。多主库结构不做处理以保持手册的例子简单。
* 服务器端内建特性使用服务器标识符和顺序数字的混合体来作为全局事务ID。不能用简单的数字比较进行GTID比较。必须使用一个SQL函数进行比较。请参见MySQL参考手册来获得具体细节。
* 插件的全局事务ID统计只对客户端端模拟器生效，因为他们只监控模拟器。

> *分布式系统中的全局事务ID*
> 全局事务ID可以在分布式系统中，如数据库集群，进行服务。全局事务ID可以被用来，例如，系统级别事务标识，全局事务订单，心跳器和检测复制库的数据复制状态。
> PECL/mysqlnd_ms 一个客户端端的基于软件的驱动，专注于为可以在客户端处理的任务使用GTID，比如检查异步复制架构中的复制状态。

##### 22.9.6.5.12. 缓存集成

> *版本要求*
> 此特性需要使用 PECL/mysqlnd_ms 1.3.0-beta 及后续版本。同时需要使用PECL/mysqlnd_qc 1.1.0-alpha 及后续版本。PECL/mysqlnd_ms必须在编译时打开此特性支持。同时要求PHP 5.4.0 及后续版本

> *设置：扩展加载顺序*
> 如果使用共享扩展，PECL/mysqlnd_ms必须在PECL/mysqlnd_qc之前加载。

> *特性稳定性*
> 缓存整合特性还在Beta阶段

> *适合的MySQL集群*
> 本特性的特别针对使用MySQL Replication（主拷贝）的集群。目前，不支持其他种类的MySQL集群。这些集群的使用者如果对客户端端查询缓存感兴趣的话，他们必须手动的控制PECL/mysqlnd_qc

支持MySQL replication集群（异步主拷贝）是PECL/mysqlnd_ms的主要聚焦点。MySQL replication集群种的从库可能会，也可能不会映射主库的最后的更新。从库是异步的，并且与主库之间存在同步延迟。一个从从库的读操作从集群的角度来说是满足最终一致性的。

使用TTL（time to live）无效策略的本地缓存提供与之相同的一致性等级。最终，如果在缓存中查找的数据不可用，那么缓存的数据源需要可访问。

鉴于此，不论是MySQL Replication集群中的从库（异步次要）还是一个遵循TTL策略的本地缓存都会交付同样的服务水平。使用一个本地缓存来透明的替换一个远程数据库的访问以来提供更好的效果是可能的。【需要调整】

从PECL/mysqlnd_ms 1.3.0-beta开始，如果明确的允许了通过[mysqlnd_ms_set_qos]来设置一个期望的服务质量,那么插件具备透明的管理PECL/mysqlnd_ms 1.1.0-alpha及后续版本来缓存一个只读查询的能力。请检视[快速入门手册]来获得代码示例。两个插件都需要被安装，PECL/mysqlnd_ms必须被编译指定提供缓存特性支持，另外必须使用PHP 5.4.0 及后续版本。

如果需要，应用程序对缓存的使用拥有完全的控制权，并且可以在任何时间请求最新的数据。缓存的使用可以通过执行一个脚本来启用或关闭。如果[mysqlnd_ms_set_qos]将服务质量设置为最终一致性，并且开启了缓存使用，那么缓存特性会被使用。如果请求了一个更高的一致性水平，比如，会话一致性（读出你的写）缓存使用会被关闭。一旦服务质量要求降低到最终一致性，缓存变可以再次被使用。

如果缓存针对只读语句开启，PECL/mysqlnd_ms可能会注入SQL hint 以来通过PECL/mysqlnd_qc[控制缓存]。插件可能会更改从应用程序处获得的SQL语句。之后的SQL语句处理器应该忽略SQL hint。一个SQL hint 是一个SQL注释。举例来说，注释必须被数据库服务器忽略掉。

一个缓存条目的TTL会在每个语句的基础上进行计算。应用程序使用[mysqlnd_ms_set_qos]设定一个他希望取回数据的最大时间。这个时间的设定是一个数据返回可以比主库延迟的大约上限。

以下的逻辑被用来计算当缓存开启是实际的TTL。此逻辑会从库延迟的估计值置入帐户以用来选择TTL。比如说，如果有两个从库，分别又5秒和10秒的延迟，且最大允许延迟为60秒，那么TTL会被设置为50秒。请注意，设置的时间不会高于预估值。

* 检查语句是否为只读,如果不是,不进行缓存.
* 如果缓存特性开启，检查所有从库的延迟。如果当前没有从库链接或者使用了惰性链接，建立从库链接。
* 向所有从库发送 *SHOW SLAVE STATUS*。在向第二个从库发送指令之前并不等待第一个从库返回数据。客户端通常要为返回结果等待很长时间，所以我们在第二阶段获取数据之前一下子发送所有请求。
* 轮循所有从库。针对每一个从库等待其返回结果。在获得当前从库的返回结果之前不会开始检查其他的从库。检查Slave_IO_Running=Yes 和 Slave_SQL_Running=Yes是否为真。如果两个条件都为真，抓取Seconds_Behind_Master的数值。如果有任何错误或者有条件为假，在从库链接上面设置一个错误。在未来的链接过滤中跳过所有有错误的从库链接。
* 在所有之前从满足条件的从库中抓取的Seconds_Behind_Master数值中找到最大的值。用用户通过mysqlnd_ms_set_qos设置的最大延迟值减去这个数值。此结果作为一个TTL。
* 过滤器可能过滤掉了所有的从库。如果这样的话，预设的最大延迟值将作为TTL，因为找到的最大实际延迟等于0。这对于所有从库都被过滤掉的情况很有用。之后的动作由之后的过滤器来决定要做什么。内建的负载均衡过滤器会选择主库。
* 注入合适的SQL hint以开启PECL/mysqlnd_qc缓存。
* 继续处理其他链接过滤器,比如,应用负载均衡规则来挑选一个从库。
* PECL/mysqlnd_qc 被PHP 加载的顺序在 PECL/mysqlnd_ms 之后。所以，它可以看到PECL/mysqlnd_ms修饰的所有查询并且在被要求的情况下缓存这些查询。

这个算法看起来代价高昂，*SHOW SLAVE STATUS*是一个很快的操作。如果请求数量足够并且每秒的缓存命中次数够多，检查从库延迟的开销会被使用缓存带来的好处很容易的盖过。

关于更好的算法的建议总是被欢迎的。

##### 22.9.6.5.13. 支持的集群

不论使用何种MySQL集群的应用程序都面临着如下的任务：

* 判断节点是否具在满足需要的服务等级的情况下执行给定的语句的能力
* 在给定的备选服务器列表中进行负载均衡
* 如果需要的话,在备选服务器之间进行自动故障转移

插件为在一个经典的异步MySQL replication集群中只有一个主库且由很多从库（主拷贝）的环境下满足这些任务而优化的。当使用经典的，异步MySQL replication集群的时候上面列出的所有任务都需要在客户端端进行处理。

其他类型的MySQL集群可能对于应用程序端有着更低的要求。比如，集群中所有的节点都能够响应读请求和写请求，不需要进行读写分离（多主库，更新全部）。集群中所有的节点都是异步的，他们自动对外提供可能的最高的服务等级，这样选择节点就会变得更容易。在这个案例中，插件可能需要重新进行配置，禁用调一些特性，比如内建的读写分离特性之后再对应用提供服务。

> *文档关注点*
> 本文档聚焦在描述如何在一个经典的异步MySQL replication集群中（主拷贝）种使用该插件。为这种集群提供支持是当初的开发初衷。如何使用其他的集群在下面有简要的叙述。
> 请注意，这些仍然在改进中。

*主拷贝（MySQL Replication）*

这是插件的主要使用案例。按照每个功能的描述中给出的提示进行。

* 配置一主库，多余一个从库。[服务器配置细节]在设置章节被给出。
* 与[sticky]标识一起，使用随机负载均衡策略
* 如果你不计划使用[服务水平]API调用，添加[master on write]标识
* 请在自己添加[故障转移]测略之前先了解以下自动故障转移的相关特性
* 考虑只在主库使用[trx_stickiness]来执行事务。请在决定使用它之前仔细搞清楚它的具体工作原理

*示例 22.260. 开启插件（php.ini）*

```json
mysqlnd_ms.enable=1
mysqlnd_ms.config_file=/path/to/mysqlnd_ms_plugin.ini
```

*示例 22.261. 针对于MySQL Replication的基本插件配置（mysqlnd_ms_plugin.ini）*

```json
{
  "myapp": {
    "master": {
      "master_1": {
        "host": "localhost",
        "socket": "\/tmp\/mysql57.sock"
      }
    },
    "slave": {
      "slave_0": {
        "host": "127.0.0.1",
        "port": 3308
      },
      "slave_1": {
        "host": "192.168.2.28",
        "port": 3306
      }
    },
    "filters": {
      "random": {
        "sticky": "1"
      }
    }
  }
}
```

*多主的主拷贝（MMM－MySQL Multi Master）*

MySQL Replication允许你创建有着多个主库（primaries）的拓扑结构的集群。写－写冲突不会被复制系统处理。这事没有更新任何地方的设置。所以数据必须被手动分分区，并且客户端必须依照分区规则重定向查询。推荐的配置与下面的分片的设置相同。

*手动分片，可能要与主拷贝和多主想结合*

为使用数据分区但是将查询重定向交给客户端处理的集群使用SQL hint和节点组过滤器。配置示例展示了一个多主集群设置了2个分片。

*示例 22.262. 多主 - multi master (php.ini)*

```json
mysqlnd_ms.enable=1
mysqlnd_ms.config_file=/path/to/mysqlnd_ms_plugin.ini
mysqlnd_ms.multi_master=1
```

*示例 22.263. 多主主拷贝和分区*

```json
{
  "myapp": {
    "master": {
      "master_1": {
        "host": "localhost",
        "socket": "\/tmp\/mysql57.sock"
      }
      "master_2": {
        "host": "192.168.2.27",
        "socket": "3306"
      }
    },
    "slave": {
      "slave_1": {
        "host": "127.0.0.1",
        "port": 3308
      },
      "slave_2": {
        "host": "192.168.2.28",
        "port": 3306
      }
    },
    "filters": {
      "node_groups": {
        "Partition_A" : {
          "master": ["master_1"],
          "slave": ["slave_1"]
        },
        "Partition_B" : {
          "master": ["master_2"],
          "slave": ["slave_2"]
        }
      },
      "roundrobin": []
    }
  }
}
```

插件也可以用在与分片无关的松散集群种。对于这种集群，只配置多个主库并且禁用读写分离。因为集群种的节点既接受所在分区读请求也接受写请求，所以他们在插件配置文件种被叫做主库。

*使用如MySQL集群的同步更新集群*

MySQL集群是一个异步集群解决方案。所有集群几点都接受读和写请求。在插件的环境下，所有节点都被认为是主节点。

仅使用负载均衡和自动转移特性。

* 禁用插件[读写分离]。
* 只配置多个主库。
* 考虑一次随机负载均衡策略，这个策略是插件的默认策略，如果一次随机策略被使用，只有主库被配置并且不会有SQL hint 被使用用来强制使用某个节点，在一个web请求期间不会有连接切换发生。所以，不需要对事务进行任何特殊处理。插件会在PHP脚本开始的时候挑选一个主库节点，然后一直使用这个库指导脚本结束。
* 不要设置服务质量。所有节点都有所有的数据。这会向外提供可能的最高的服务质量（强一致性）。
* 不要启用客户端端全局事务注入。它既不会对服务器端故障转移有帮助也不会协助服务质量过滤器来选择一个合适的节点。

禁用内建的读写分离.

* 设置[mysqlnd_ms.multi_master=1]。
* 不要配置任何从库。
* 在插件配置文件中设置[failover=loop_before_master]来避免关于从库列表为空的警告，且让故障转移逻辑在抛出一个错误之前轮循所有已经配置了的主库。

请检视前面章节关于自动故障转移警告的相关内容。

*示例 22.264. 多主 - multi master (php.ini)*

```json
mysqlnd_ms.enable=1
mysqlnd_ms.config_file=/path/to/mysqlnd_ms_plugin.ini
mysqlnd_ms.multi_master=1
mysqlnd_ms.disable_rw_split=1
```

*示例 22.265. 同步更新集群*

```json
  "myapp": {
    "master": {
      "master_1": {
        "host": "localhost",
        "socket": "\/tmp\/mysql57.sock"
      },
      "master_2": {
        "host": "192.168.2.28",
        "port": 3306
      }
    },
    "slave": {
    },
    "filters": {
      "roundrobin": {
      }
    },
    "failover": {
      "strategy": "loop_before_master",
      "remember_failed": true
    }
  }
}
```

如果运行一个没有内建分区的同步集群来避免热点和高冲突率,考虑使用节点组过滤器来保持某个节点上的经常被读取的表的总是更新。这可以帮助你来降低冲突率，进而提升性能。
