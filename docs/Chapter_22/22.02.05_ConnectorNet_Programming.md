### 22.2.5. Connector/Net编程

[22.2.5.1. Connecting to MySQL Using Connector/Net][22.2.5.1]  
[22.2.5.2. Creating a Connector/Net Connection String][22.2.5.2]  
[22.2.5.3. Using MySqlCommand][22.2.5.3]  
[22.2.5.4. Using Connector/Net with Connection Pooling][22.2.5.4]  
[22.2.5.5. Using the Windows Native Authentication Plugin][22.2.5.5]  
[22.2.5.6. Writing a Custom Authentication Plugin][22.2.5.6]  
[22.2.5.7. Using Connector/Net with Table Caching][22.2.5.7]  
[22.2.5.8. Using the Connector/Net with Prepared Statements][22.2.5.8]  
[22.2.5.9. Accessing Stored Procedures with Connector/Net][22.2.5.9]  
[22.2.5.10. Handling BLOB Data With Connector/Net][22.2.5.10]  
[22.2.5.11. Using the Connector/Net Interceptor Classes][22.2.5.11]  
[22.2.5.12. Handling Date and Time Information in Connector/Net][22.2.5.12]  
[22.2.5.13. Using the MySqlBulkLoader Class][22.2.5.13]  
[22.2.5.14. Using the MySQL Connector/Net Trace Source Object][22.2.5.14]  
[22.2.5.15. Binary/Nonbinary Issues][22.2.5.15]  
[22.2.5.16. Character Set Considerations for Connector/Net][22.2.5.16]  
[22.2.5.17. Using Connector/Net with Crystal Reports][22.2.5.17]  
[22.2.5.18. ASP.NET Provider Model][22.2.5.18]  
[22.2.5.19. Working with Partial Trust / Medium Trust][22.2.5.19]  

Connector/Net包含几个用于连接数据库、执行查询语句和管理查询结果。

以下是Connector/Net的主要类： 
 
* _MySqlCommand_：代表一个用于针对执行一个MySQL数据库的SQL语句。
* _MySqlCommandBuilder_：自动生成单表命令用于调和一个数据集变化与相关的MySQL数据库。
* _MySqlConnection_：表示一个到MySQL服务器数据库的打开的连接。
* _MySqlDataAdapter_：表示一个数据命令集合与一个用于填充一个数据集合和更新一个MySQL数据库的数据库连接。
* _MySqlDataReader_：提供了一种方法来从一个MySQL数据库读取一个单向的流。
* _MySqlException_：当MySQL返回一个错误的时候，抛出该异常。
* _MySqlHelper_：使提供者更加容易的工作的辅助类。
* _MySqlTransaction_：表示一个数据库产生的SQL事物。

在以下章节，你会学到一些对于Connector/Net的一般用例，包括BLOB处理、数据处理和使用Connector/Net与形如Crystal报表的常见工具。

[22.2.5.1]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.1
#### 22.2.5.1. Connecting to MySQL Using Connector/Net

一个.net应用程序和MySQL服务器之间的交互是通过一个MySqlConnection对象来实现的。

你的应用程序能跟服务器交互之前，必须实例化、配置和打开一个MySqlConnection对象。

甚至当使用_MySqlHelper_类，使得一个_MySqlconnection_对象被辅助类所创建。

本章描述了如何使用MySqlConnection对象连接到MySQL。

[22.2.5.2]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.2
#### 22.2.5.2. 创建一个Connector/Net连接字符串

_MySqlConnection_对象使用一个连接字符串进行配置。一个连接字符串包含几个被分号隔开的键值对。在每一个键值对里，选项名和它对应的值用等号连接的。关于选项名列表在在字符串中的用法，参考[章节22.2.6, “Connector/Net连接字符串选项参考”](../Chapter_22/22.2.6_ConnectorNet_Connection_String_Options_Reference.md)

以下是一个连接字符串的例子：

	Server=127.0.0.1;Uid=root;Pwd=12345;Database=test;

在这个例子里，_MySqlConnection_对象被配置为连接到一个使用的用户名是_root_和密码是_12345_的在_127.0.0.1_上的MySQL服务。对于所有语句的默认数据库是_test_数据库。

>__注解__
>
虽然使用'?'这种老的模式仍然被支持，但是使用'@'符号来表示参数是现在首选的方法。为了避免冲突，当在用户变量的组合中使用'@'符号的时候，请参照[章节22.2.6, “Connector/Net连接字符串选项参考”][22.2.6]中的_容许用户变量_连接字符串选项。_Old Syntax_连接字符串选项已经不被赞成使用。

##### 22.2.5.2.1. 打开一个连接

一旦你已经创建了一个连接字符串，它能够用于打开一个到MySQL服务的连接。

以下的代码是用于创建一个_MySqlConnection_对象，指定连接字符串并且打开这个连接。

Connector/Net也能够使用本地Windows身份验证插件进行连接。详细参照[章节 22.2.5.5, “使用Windows本地身份验证插件”][22.2.5.5]。

你可以通过写自己的插件来进一步扩展验证机制。详细参照[章节 22.2.5.6, “编写一个客户端身份验证插件”][22.2.5.6]。

**Visual Basic示例**  

	Dim conn As New MySql.Data.MySqlClient.MySqlConnection
	Dim myConnectionString as String

	myConnectionString = "server=127.0.0.1;" _
	& "uid=root;" _
            & "pwd=12345;" _
            & "database=test;"

	Try
  	  conn.ConnectionString = myConnectionString
  	  conn.Open()

	Catch ex As MySql.Data.MySqlClient.MySqlException
	  MessageBox.Show(ex.Message)
	End Try

**C#示例**

	MySql.Data.MySqlClient.MySqlConnection conn;
	string myConnectionString;

	myConnectionString = "server=127.0.0.1;uid=root;" +
    	"pwd=12345;database=test;";

	try
	{
    	conn = new MySql.Data.MySqlClient.MySqlConnection();
    	conn.ConnectionString = myConnectionString;
    	conn.Open();
	}
	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
    	MessageBox.Show(ex.Message);
	}

你也可以把连接字符串传递到_MySqlConnection_类的构造函数中。

**Visual Basic示例**

	Dim myConnectionString as String

	myConnectionString = "server=127.0.0.1;" _
              & "uid=root;" _
              & "pwd=12345;" _
              & "database=test;"

	Try
    	Dim conn As New MySql.Data.MySqlClient.MySqlConnection(myConnectionString)
    	conn.Open()
	Catch ex As MySql.Data.MySqlClient.MySqlException
   		MessageBox.Show(ex.Message)
	End Try

**C#示例**

	MySql.Data.MySqlClient.MySqlConnection conn;
	string myConnectionString;

	myConnectionString = "server=127.0.0.1;uid=root;" +
    	"pwd=12345;database=test;";

	try
	{
    	conn = new MySql.Data.MySqlClient.MySqlConnection(myConnectionString);
    	conn.Open();
	}
	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
	    MessageBox.Show(ex.Message);
	}

一旦连接被打开，它就可以用于其他的Connector/Net类去和MySQL服务进行交流。

##### 22.2.5.2.2. 处理连接错误

因为连接一个外部服务是不可预知的，所以添加错误处理对于你的.NET应用程序是十分重要的。当有一个错误连接产生，_MySqlConnection_类就会返回一个_MySqlException_对象。这个当产生错误的时候的有趣的对象有两个属性：

* _Message_：一个描述当前异常的信息。
* _Number_：MySQL的错误代号。

当处理错误产生，你可以基于错误代号相应你的应用程序。当连接时，有如下两个最常见的错误代号：

* _0_：不能连接到服务。
* _1045_：无效的用户名或密码。

接下来的代码展示了如何适应基于实际错误的应用程序的相应：

**Visual Basic示例**

	Dim myConnectionString as String

	myConnectionString = "server=127.0.0.1;" _
          & "uid=root;" _
          & "pwd=12345;" _
          & "database=test;"

	Try
    	Dim conn As New MySql.Data.MySqlClient.MySqlConnection(myConnectionString)
    	conn.Open()
	Catch ex As MySql.Data.MySqlClient.MySqlException
    	Select Case ex.Number
        	Case 0
            	MessageBox.Show("Cannot connect to server. Contact administrator")
        	Case 1045
            	MessageBox.Show("Invalid username/password, please try again")
    	End Select
	End Try

**C#示例**

	MySql.Data.MySqlClient.MySqlConnection conn;
	string myConnectionString;

	myConnectionString = "server=127.0.0.1;uid=root;" +
    	"pwd=12345;database=test;";

	try
	{
    	conn = new MySql.Data.MySqlClient.MySqlConnection(myConnectionString);
    	conn.Open();
	}
    	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
    	switch (ex.Number)
    	{
        	case 0:
            	MessageBox.Show("Cannot connect to server.  Contact administrator");
            	break;
        	case 1045:
            	MessageBox.Show("Invalid username/password, please try again");
            	break;
    	}
	}

>重要提示  
注意如果你要是使用读语言数据库的话，就必须在连接字符串中指定字符集。如果你不指定字符集，连接就会默认为_latin1_字符集。你可以把指定字符集作为连接字符串的一部分，如下例:

	MySqlConnection myConnection = new MySqlConnection("server=127.0.0.1;uid=root;" +
	"pwd=12345;database=test;Charset=latin1;");

##### 22.2.5.2.3. Using GetSchema on a Connection

连接对象的_GetSchema()_方法可以用于取得关于数据库当前连接的schema信息。schema信息以_DataTable_的形式返回。这个schema信息被组织成一个数字集合。不同形式的_GetSchema()_方法可以根据信息请求被使用。这有三种形式的_GetSchema()_方法：

* _GetSchema()_ - 该调用会返回一个可用集合。
* _GetSchema(String)_ - 该调用会返回集合中指定字符串参数的信息。如果字符串“MetaDataCollections”被使用，那么一个所有可用集合的列表将被返回。这就跟调用没用任何参数的_GetSchema()_一样。
* _GetSchema(String, String[])_ - 在这个调用中第一个字符串参数代表集合名，并且第二个参数代表一个约束值的字符串数组。约束值限制将要返回的数据的量。约束值有更多详细的解释在[Microsoft .NET documentation](http://msdn.microsoft.com/en-us/library/ms254934(VS.80).aspx)里。

###### 22.2.5.2.3.1. 集合

集合可以被广泛的分为两类：通用于所有的数据提供者的集合和特定于一个特定的提供者的集合。

**普通的**

以下集合是通用于所有数据提供者的：

* MetaDataCollections
* DataSourceInformation
* DataTypes
* Restrictions
* ReservedWords

**特定于提供程序的**

以下是MySQL Connector/Net当前提供的除通用集合之上的集合：

* Databases
* Tables
* Columns
* Users
* Foreign Keys
* IndexColumns
* Indexes
* Foreign Key Columns
* UDF
* Views
* ViewColumns
* Procedure Parameters
* Procedures
* Triggers

***示例代码***

一个可用集合列表可以用下面的代码获得：

	using System;
	using System.Data;
	using System.Text;
	using MySql.Data;
	using MySql.Data.MySqlClient;

	namespace ConsoleApplication2
	{
    	class Program
    	{

        	private static void DisplayData(System.Data.DataTable table)
        	{
            	foreach (System.Data.DataRow row in table.Rows)
            	{
                	foreach (System.Data.DataColumn col in table.Columns)
                	{
                    	Console.WriteLine("{0} = {1}", col.ColumnName, row[col]);
                	}
                	Console.WriteLine("============================");
            	}
        	}

        	static void Main(string[] args)
        	{

            	string connStr = "server=localhost;user=root;database=world;port=3306;password=******;";
            	MySqlConnection conn = new MySqlConnection(connStr);

            	try
            	{
                	Console.WriteLine("Connecting to MySQL...");
                	conn.Open();

                	DataTable table = conn.GetSchema("MetaDataCollections");
                	//DataTable table = conn.GetSchema("UDF");
                	DisplayData(table);

                	conn.Close();
            	}
            	catch (Exception ex)
            	{
                	Console.WriteLine(ex.ToString());
            	}
            	Console.WriteLine("Done.");
        	}
    	}
	}

关于更多的_GetSchema()_方法和schema集合的信息可以再[Microsoft .NET documentation](http://msdn.microsoft.com/en-us/library/kcax58fh(VS.80).aspx)找到。

[22.2.5.3]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.3
#### 22.2.5.3. 使用MySqlCommand

一个_MySqlCommand_包含有与它关联的_CommandText_和_CommandType_属性。_CommandText_依赖于_CommandType_的设置进行不同的处理。_CommandType_可以是其中任意一个：

1. Text - 一个SQL文本命令(默认)
2. StoredProcedure - 一个存储过程的名称
3. TableDirect - 一个表名称(新出现在Connector/Net 6.2)

默认的_CommandType_和_Text_被用于查询和其他的SQL命令。关于这个的一些例子可以在[Section 22.2.4.1.2, “MySqlCommand对象”][22.2.4.1.2]。

[22.2.4.1.2]: ./docs/Chapter_22/22.2.4_ConnectorNet_Tutorials.md#22.2.4.1.2

如果_CommandType_被设置到_TableDirect_中，当你调用Execute方法时，所有的命名的表的行和列将被返回。实际上，这个命令在指定的表上执行一个_SELECT \*_。_CommandText_属性设置为表名来查询。这被以下代码片段说明：

	...
	MySqlCommand cmd = new MySqlCommand();
	cmd.CommandText = "mytable";
	cmd.Connection = someConnection;
	cmd.CommandType = CommandType.TableDirect;
	MySqlDataReader reader = cmd.ExecuteReader();
	while (reader.Read())
	{
		Console.WriteLn(reader[0], reader[1]...);
	}
	...

使用存储过程的CommandType的示例可以在[Section 22.2.5.9, “使用Connector/Net访问存储过程”][22.2.5.9]中找到。

命令可以有一个超时与它们相关联。如果你可能不想一个命令占用过多的时间，这是很有用的。超时可以通过_CommandTimeout_属性来设置。以下的代码片段设置了一个一分钟的超时。

	MySqlCommand cmd = new MySqlCommand();
	cmd.CommandTimeout = 60;

默认值是30秒。避免值为0，其表明一个不确定的等待。使用连接字符串_Default Command Timeout_来改变默认的命令超时。

在MySQL Connector/Net 6.2之前，_MySqlCommand.CommandTimeout_包括不涉及连接器的直接使用用户处理时间。通过一个在_CommandTimeout_秒后触发的.NET定时器来实现超时。该定时器消耗一个线程。

MySQL Connector/Net 6.2引入符合微软如何处理_SqlCommand.CommandTimeout_的超时。该属性是对于所有的在命令执行和结果处理之间的网络读写的积累超时。在第一行被返回之后，并且不包含用户处理时间，仅仅有IO操作，在_MySqlReader.Read_方法中仍然会发生一个超时。6.2的实现使用底层流超时设施，所以效率更高，因为它不要求额外的定时器线程作为使用优先实现的实例。

更多详细内容可以在有关的_微软文档_中找到。

[22.2.5.4]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.4
#### 22.2.5.4. 使用Connector/Net和连接池
Connector/Net支持连接池在数据库密集型应用程序上以获得更好的性能和可扩展性。这是默认启用的。你可以关掉它或者使用连接字符串选项_Pooling_,_Connection Reset_,_Connection Lifetime_,_Cache Server Properties_,_Max Pool Size_和_Min Pool Size_来调整它的性能特征。关于进一步信息请参照[章节22.2.5.2, “创建一个Connector/Net连接字符串”][22.2.5.2]

当客户端设置一个_MySqlConnection_的时，连接池通过保持本地连接到服务器生存。随后，如果一个新的_MySqlConnection_对象被打开，它将会从连接池中被创建，而不是创建一个新的本地连接。这就提高了性能。

**指南**

为了有计划的工作，最好让连接池系统来管理所有的连接。不创建一个全局的可访问的_MySqlConnection_示例，并且手动的打开和关闭它。随着这种方式的干扰池的运行，并且可能导致不可预知的结果，甚至异常。

一种简化方法是避免手动地创建一个_MySqlConnectionobject_对象。反而用把连接字符串作为参数的overloaded方法。使用这种方法，Connector/Net会自动地创建、打开、关闭和销毁连接，使用连接池系统的性能最好。

类型化数据集与_MembershipProvider_和_RoleProvider_类使用这种方法。大部分类拥有把_MySqlConnection_当做参数的方法，而且还有把一个连接字符串当做参数的方法。这个包括_MySqlDataAdapter_。

代替手动地创建_MySqlCommand_对象，你可以使用_MySqlHelper_类的静态方法。这些把一个连接字符串作为一个参数，并且它们完全支持连接池。

**资源使用**

启动MySQL Connector/Net 6.2，会有一个每运行三分钟就从池中删除超过三分钟而空闲的连接的后台作业。该池清理释放客户端和服务器端的资源。这是因为在客户端每个连接使用一个套接字，并且在服务器端每个连接使用一个套接字和一个线程。

在这个改变之前，连接绝对不会从池中删除，并且该池总是包含打开连接的峰值个数。例如，一个web应用程序达到1000个并发数据库连接就会消耗1000个线程，并且在服务器中有1000个打开的套接字，而不从连接池中释放那些资源。注意，如果在线程池中的连接数量少于或等于用_Min Pool Size_连接字符串参数设置的值，无论多么老的连接也不会关闭。

[22.2.5.5]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.5
#### 22.2.5.5. 使用Windows本地身份验证插件

自Connector/Net 6.4.4和MySQL 5.5.16/5.6.10起，Connector/Net可以使用Windows本地身份认证插件来认证一个MySQL服务器。已经登录到Windows的用户可以连接到MySQL客户端程序，因为服务器根据在它们环境中无需指定一个附加的密码的消息。关于身份验证插件的背景和使用信息，请参照[章节6.3.7.6, “Windows本地身份验证插件”](/Chapter06/6.3.7.6_The_Windows_Native_Authentication_Plugin#6.3.7.6)。

该接口与_MySql.Data.MySqlClient_对象相配。用_yes_或者_sspi_的值使能够传递_Integrated Security_到连接字符串。

传递一个用户ID是可选择的。当Windows身份验证被设置，一个MySQL用户被创建并且被配置为使用Windows身份验证。默认的情况下，这个用户被命名为_auth_windows_,但是可以被定义为其他的名字。如果默认名称被使用，那么从Connector/Net传递该用户ID到连接字符串是可选的，因为它将使用_auth_windows_这个用户。否则，名字必须使用标准用户ID元素传递到连接字符串。

[22.2.5.6]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.6
#### 22.2.5.6. 编写一个客户端身份验证插件

有特殊安全需求的高级用户可以为Connector/Net应用程序创建他们自己的身份验证插件。你可以扩展握手协议，添加自定义逻辑。该功能需要Connector/Net 6.6.3或者更高版本，且需要MySQL 5.5.16或者更高版本。关于MySQL的身份验证插件的背景和使用信息，请参见[章节23.2.3.7, “身份验证插件”](/docs/Chapter_23/23.2.3.7_Authentication_Plugins#23.2.3.7)和[章节23.2.4.9, “编写身份验证插件”](/docs/Chapter_23/23.2.4.9_Writing_Authentication_Plugins#23.2.4.9)。

要编写自定义的认证插件，您将需要一个MySql.Data.dll组件的引用。在命名空间_MySql.Data.MySqlClient.Authentication_中与编写身份验证插件有关的类是可利用的。

**自定义身份验证插件是怎么工作的**

握手期间在某些点上_MySqlAuthenticationPlugin_的内部方法

	void Authenticate(bool reset)

被调用。该方法轮流调用当前插件的几个可重写方法。

**创建身份验证插件类**

你把身份验证插件逻辑放进一个派生于_MySql.Data.MySqlClient.Authentication.MySqlAuthenticationPlugin_的新类。以下方法是可以被重写的。

	protected virtual void CheckConstraints()
	protected virtual void AuthenticationFailed(Exception ex)
	protected virtual void AuthenticationSuccessful()
	protected virtual byte[] MoreData(byte[] data)
	protected virtual void AuthenticationChange()
	public abstract string PluginName { get; }
	public virtual string GetUsername()
	public virtual object GetPassword()
	protected byte[] AuthData;

以下是对每个方法的简单说明：

	/// <summary>
	/// This method must check authentication method specific constraints in the 
	environment and throw an Exception
	/// if the conditions are not met. The default implementation does nothing.
	/// </summary>
	protected virtual void CheckConstraints()

	/// <summary>
	/// This method, called when the authentication failed, provides a chance to 
	plugins to manage the error
	/// the way they consider decide (either showing a message, logging it, etc.).
	/// The default implementation wraps the original exception in a MySqlException 
	with an standard message and rethrows it.
	/// </summary>
	/// <param name="ex">The exception with extra information on the error.</param>
	protected virtual void AuthenticationFailed(Exception ex)

	/// <summary>
	/// This method is invoked when the authentication phase was successful accepted 
	by the server.
	/// Derived classes must override this if they want to be notified of such 
	condition.
	/// </summary>
	/// <remarks>The default implementation does nothing.</remarks>
	protected virtual void AuthenticationSuccessful()

	/// <summary>
	/// This method provides a chance for the plugin to send more data when the 
	server requests so during the 
	/// authentication phase. This method will be called at least once, and more 
	than one depending upon whether the
	/// server response packets have the 0x01 prefix.
	/// </summary>
	/// <param name="data">The response data from the server, during the 
	authentication phase the first time is called is null, in 
	subsequent calls contains the server response.</param>
	/// <returns>The data generated by the plugin for server consumption.</returns>
	/// <remarks>The default implementation always returns null.</remarks>
	protected virtual byte[] MoreData(byte[] data)

	/// <summary>
	/// The plugin name.
	/// </summary>
	public abstract string PluginName { get; }

	/// <summary>
	/// Gets the user name to send to the server in the authentication phase.
	/// </summary>
	/// <returns>An string with the user name</returns>
	/// <remarks>Default implementation returns the UserId passed from the 
	connection string.</remarks>
	public virtual string GetUsername()

	/// <summary>
	/// Gets the password to send to the server in the authentication phase. This 
	can can be an string or a
	/// </summary>
	/// <returns>An object, can be byte[], string or null, with the password.
	</returns>
	/// <remarks>Default implementation returns null.</remarks>
	public virtual object GetPassword()

	/// <summary>
	/// The authentication data passed when creating the plugin. 
	/// For example in mysql_native_password this is the seed to encrypt the 
	password.
	/// </summary>
	protected byte[] AuthData;

**身份认证插件实例**

这里有个展示如何创建身份验证插件，然后用配置文件的方法启用它的例子。以下是这些步骤：

1.创建一个控制台应用程序，并添加一个参考_MySql.data.dll_。
2.设计如下主程序：

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using MySql.Data.MySqlClient;

	namespace AuthPluginTest
	{
		class Program
		{
			static void Main(string[] args)
			{
				// Customize the connection string as necessary.
				MySqlConnection con = new MySqlConnection("server=localhost; 
				database=test; user id=myuser; password=mypass");
				con.Open();
				con.Close();
			}
		}
	}	

3.创建你的插件类。在这个例子中，我们只要使用相同的代码从原来的插件添加一个本地密码插件的“供选择的”实现。我们把我们的类命名为_MySqlNativePasswordPlugin2_：

	using System.IO;
	using System;
	using System.Text;
	using System.Security.Cryptography;
	using MySql.Data.MySqlClient.Authentication;
	using System.Diagnostics;

	namespace AuthPluginTest
	{
		public class MySqlNativePasswordPlugin2 : MySqlAuthenticationPlugin
		{
			public override string PluginName
			{
				get { return "mysql_native_password"; }
			}

			public override object GetPassword()
			{
				Debug.WriteLine("Calling MySqlNativePasswordPlugin2.GetPassword");
				return Get411Password(Settings.Password, AuthData);
			}

			/// <summary>
			/// Returns a byte array containing the proper encryption of the 
			/// given password/seed according to the new 4.1.1 authentication scheme.
			/// </summary>
			/// <param name="password"></param>
			/// <param name="seed"></param>
			/// <returns></returns>
			private byte[] Get411Password(string password, byte[] seedBytes)
			{
				// if we have no password, then we just return 1 zero byte
				if (password.Length == 0) return new byte[1];

				SHA1 sha = new SHA1CryptoServiceProvider();

				byte[] firstHash = sha.ComputeHash(Encoding.Default.GetBytes(password));
				byte[] secondHash = sha.ComputeHash(firstHash);

				byte[] input = new byte[seedBytes.Length + secondHash.Length];
				Array.Copy(seedBytes, 0, input, 0, seedBytes.Length);
				Array.Copy(secondHash, 0, input, seedBytes.Length, secondHash.Length);
				byte[] thirdHash = sha.ComputeHash(input);

				byte[] finalHash = new byte[thirdHash.Length + 1];
				finalHash[0] = 0x14;
				Array.Copy(thirdHash, 0, finalHash, 1, thirdHash.Length);

				for (int i = 1; i < finalHash.Length; i++)
				  finalHash[i] = (byte)(finalHash[i] ^ firstHash[i - 1]);
				return finalHash;
			}
		}
	}

4.请注意，该插件实现仅重写_GetPassword_，并提供一个实现，使用4.1协议对密码进行加密。我们也把下面的一行放进_GetPassword_上：

	Debug.WriteLine("Calling MySqlNativePasswordPlugin2.GetPassword");

来提供确认该插进被有效地利用。（你也可以再该方法打一个断点。）

5.在配置文件中启用新插件：

	<?xml version="1.0"?>
	<configuration>
	<configSections>
		<section name="MySQL" type="MySql.Data.MySqlClient.MySqlConfiguration, 
		MySql.Data"/>
	</configSections>
	<MySQL>
		<AuthenticationPlugins>
			<add name="mysql_native_password" 
	type="AuthPluginTest.MySqlNativePasswordPlugin2, AuthPluginTest"></add>
		</AuthenticationPlugins> 
	</MySQL>
	<startup><supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0"/>
	</startup></configuration>

6.运行该应用程序。在Visual Studio中，你会在debug窗口看到_Calling MySqlNativePasswordPlugin2.GetPassword_的消息。

7.如果你有需要的话，可以重写更多的方法，继续增强身份验证逻辑。

[22.2.5.7]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.7
#### 22.2.5.7. 以表缓存的方式使用Connector/Net

这个特点存在于Connector/Net版本6.4和其以上版本。

表缓存是一种可以被用于客户端的缓存缓慢改变数据集的特点。这是对被设计使用阅读器的应用程序有益的，但是仍然希望减少服务器对缓慢改变表的访问。

这个特点对于应用程序是透明的，并且默认是禁用的。

**配置**

+ 为了能够使用表缓存，添加_'table cache = true'_到连接字符串。
+ 可选，指定_'Default Table Cache Age'_连接字符串选项，该选项代表一张表被缓存之前该缓存数据被丢弃的秒数。默认值是60。
+ 在运行时，你可以在每一个命令的基础上转换缓存的开和关并且设置缓存选项。

[22.2.5.8]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.8
#### 22.2.5.8. 以预处理语句方式使用Connector/Net

从MySQL 4.1起，允许以Connector/Net的方式使用预处理语句。使用预处理语句可以在一次以上的查询中提供显著的性能改进。

在语句执行一次以上的情况下,预处理执行比直接执行快，主要因为查询仅被解析一次。在直接执行的情况下，查询在每次执行的时候都被解析。预处理执行也可以使网络通信量减少，因为每次预处理语句的执行仅仅需要发送与参数有关的数据。

预处理语句的另一个优点是它使用一个二进制的协议在客户端与服务器之间进行更加有效率的数据的传输。

##### 22.2.5.8.1. Connector/Net中的预处理语句

为了准备一个语句，创建一个命令对象，并设置_.CommandText_属性到你的查询中。

在输入你的语句之后，调用_MySqlCommand_对象的_.Prepare_方法。在语句被准备好之后，在查询中为每个动态元素添加参数。

在你输入查询和参数之后，使用_.ExecuteNonQuery()_、_.ExecuteScalar()_或_.ExecuteReader_方法执行该语句。

对于并发的执行，你只需要修改变量的值并且再次调用执行方法，而不需要设置_.CommandText_属性或重新定义参数。

**Visual Basic示例**

	Dim conn As New MySqlConnection
	Dim cmd As New MySqlCommand

	conn.ConnectionString = strConnection

	Try
		conn.Open()
		cmd.Connection = conn

		cmd.CommandText = "INSERT INTO myTable VALUES(NULL, @number, @text)"
		cmd.Prepare()

		cmd.Parameters.AddWithValue("@number", 1)
		cmd.Parameters.AddWithValue("@text", "One")

		For i = 1 To 1000
			cmd.Parameters("@number").Value = i
			cmd.Parameters("@text").Value = "A string value"

			cmd.ExecuteNonQuery()
			Next
	Catch ex As MySqlException
		MessageBox.Show("Error " & ex.Number & " has occurred: " & ex.Message, "Error", MessageBoxButtons.OK, M
	End Try

**C#示例**

	MySql.Data.MySqlClient.MySqlConnection conn;
	MySql.Data.MySqlClient.MySqlCommand cmd;

	conn = new MySql.Data.MySqlClient.MySqlConnection();
	cmd = new MySql.Data.MySqlClient.MySqlCommand();

	conn.ConnectionString = strConnection;

	try
	{
		conn.Open();
		cmd.Connection = conn;

		cmd.CommandText = "INSERT INTO myTable VALUES(NULL, @number, @text)";
		cmd.Prepare();

		cmd.Parameters.AddWithValue("@number", 1);
		cmd.Parameters.AddWithValue("@text", "One");

		for (int i=1; i <= 1000; i++)
		{
			cmd.Parameters["@number"].Value = i;
			cmd.Parameters["@text"].Value = "A string value";

			cmd.ExecuteNonQuery();
		}
	}
	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
		MessageBox.Show("Error " + ex.Number + " has occurred: " + ex.Message,
			"Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
	}


[22.2.5.9]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.9
#### 22.2.5.9. 使用Connector/Net访问存储过程

MySQL server版本5和以上版本以SQL 2003存储过程语法支持存储过程。

一个存储过程是存储在服务器上的SQL语句集合。客户端使一个单一的调用存储过程，传递可以影响存储逻辑和查询条件的参数，而不是发出个别硬编码的SQL语句。

存储过程在以下的情形是特别有用的：

+ 存储过程可以作为一个API或抽象层，允许多客户端应用程序执行同一个数据库操作。这些应用程序可以写成不同的语言并且运行在不同的平台上。这些应用程序不需要硬编码表和列名，使查询复杂等。当在一个存储过程中你扩展并且完善这些查询，所有的应用程序自动地调用过程得到好处。
+ 当安全是最重要的时候，存储过程保持应用程序直接操作表，甚至知道如表名和列名之类的表的详细信息。例如，银行使用存储过程进行所有的一般操作。这提供一个一致的并且安全的环境，而且过程可以确保每个操作被正确地记入日志。在这样的一个设置中，应用程序和用户不会得到任何直接访问数据库表，但是可以仅仅执行特定的存储过程。

Connector/Net支持通过_MySqlCommand_对象进行存储过程的调用。数据可以通过_MySqlCommand.Parameters_集合的使用被传入和传出一个MySQL存储过程。

>**注解**  

>当你调用一个存储过程的时候，命令对象使一个额外的_SELECT_通知确定存储过程的参数。你必须确保用户调用该过程时，在_mysql.proc_ 表中有使他们能够校验参数的_SELECT_**[775]**特权。如果这样做失败的话，在调用过程的时候就会返回一个错误。

本章在创建存储过程方面不会提供更深的信息。对于这样的信息，请参照[http://dev.mysql.com/doc/mysql/en/stored-routines.html](http://dev.mysql.com/doc/mysql/en/stored-routines.html)。

一个展示如何使用Connector/Net使用存储过程的范例应用程序可以在你的Connector/Net安装目录下的_Samples_中找到。

##### 22.2.5.9.1. 使用Connector/Net中的存储例程

在MySQL中存储过程可以使用多种工具进行创建。第一种，可以使用_mysql_命令行客户端创建存储过程。第二种,可以使用MySQL工作台创建存储过程。最后一种，可以使用_MySqlCommand_对象的_.ExecuteNonQuery_方法创建存储过程。

不像命令行和GUI客户端，当在Connector/Net中创建存储过程的时候，你没有被要求指定一个特殊的定义符。

为了使用Connector/Net调用存储过程，你创建一个_MySqlCommand_对象，并且把存储过程名称作为_.CommandText_属性传递。然后把_.CommandType_属性设置到_CommandType.StoredProcedure_中。

在存储过程命名之后，为每个在该存储过程中的参数创建一个_MySqlCommand_参数。_IN_类型的参数定义为参数名加包含值的对象的形式，_OUT_类型的参数定义为参数名加希望返回的数据类型的形式。所有的参数都需要明确定义参数的方向。

定义过参数之后，你就可以使用_MySqlCommand.ExecuteNonQuery()_方法调用存储过程了。

一旦存储过程被调用，输出参数就会在_MySqlConnector.Parameters_集合的_.Value_属性中进行检索。

>注解

>当使用_MySqlCommand.ExecuteReader_调用一个存储过程，并且该存储过程有输出参数的时候，该输出参数只在_ExecuteReader_被关闭，_MySqlDataReader_返回之后被设置。

以下C#示例代码示范了存储过程的用法。假定'employees'数据库已经被创建：

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;

	using System.Data;
	using MySql.Data;
	using MySql.Data.MySqlClient;

	namespace UsingStoredRoutines
	{
		class Program
		{
			static void Main(string[] args)
			{
				MySqlConnection conn = new MySqlConnection();
				conn.ConnectionString = "server=localhost;user=root;database=employees;port=3306;password=******;";
				MySqlCommand cmd = new MySqlCommand();

				try
				{
					Console.WriteLine("Connecting to MySQL...");
					conn.Open();
					cmd.Connection = conn;
					cmd.CommandText = "DROP PROCEDURE IF EXISTS add_emp";
					cmd.ExecuteNonQuery();
					cmd.CommandText = "DROP TABLE IF EXISTS emp";
					cmd.ExecuteNonQuery();

					cmd.CommandText = "CREATE TABLE emp (empno INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY
					cmd.ExecuteNonQuery();
					cmd.CommandText = "CREATE PROCEDURE add_emp(" +
									"IN fname VARCHAR(20), IN lname VARCHAR(20), IN bday DATETIME, OUT empno 
									"BEGIN INSERT INTO emp(first_name, last_name, birthdate) " +
									"VALUES(fname, lname, DATE(bday)); SET empno = LAST_INSERT_ID(); END";

					cmd.ExecuteNonQuery();
				}
				catch (MySqlException ex)
				{
					Console.WriteLine ("Error " + ex.Number + " has occurred: " + ex.Message);
				}

				conn.Close();
				Console.WriteLine("Connection closed.");
				try
				{
					Console.WriteLine("Connecting to MySQL...");
					conn.Open();
					cmd.Connection = conn;

					cmd.CommandText = "add_emp";
					cmd.CommandType = CommandType.StoredProcedure;

					cmd.Parameters.AddWithValue("@lname", "Jones");
					cmd.Parameters["@lname"].Direction = ParameterDirection.Input;

					cmd.Parameters.AddWithValue("@fname", "Tom");
					cmd.Parameters["@fname"].Direction = ParameterDirection.Input;

					cmd.Parameters.AddWithValue("@bday", "1940-06-07");
					cmd.Parameters["@bday"].Direction = ParameterDirection.Input;

					cmd.Parameters.AddWithValue("@empno", MySqlDbType.Int32);
					cmd.Parameters["@empno"].Direction = ParameterDirection.Output;

					cmd.ExecuteNonQuery();

					Console.WriteLine("Employee number: "+cmd.Parameters["@empno"].Value);
					Console.WriteLine("Birthday: " + cmd.Parameters["@bday"].Value);
				}
				catch (MySql.Data.MySqlClient.MySqlException ex)
				{
					Console.WriteLine("Error " + ex.Number + " has occurred: " + ex.Message);
				}
				conn.Close();
				Console.WriteLine("Done.");
			}
		}
	}

以下代码是在Visual Basic中相同的应用程序：

	Imports System
	Imports System.Collections.Generic
	Imports System.Linq
	Imports System.Text
	
	Imports System.Data
	Imports MySql.Data
	Imports MySql.Data.MySqlClient
	
	Module Module1
	
	    Sub Main()
	        Dim conn As New MySqlConnection()
	        conn.ConnectionString = "server=localhost;user=root;database=world;port=3306;password=******;"
	        Dim cmd As New MySqlCommand()
	
	        Try
	            Console.WriteLine("Connecting to MySQL...")
	            conn.Open()
	            cmd.Connection = conn
	            cmd.CommandText = "DROP PROCEDURE IF EXISTS add_emp"
	            cmd.ExecuteNonQuery()
	            cmd.CommandText = "DROP TABLE IF EXISTS emp"
	            cmd.ExecuteNonQuery()
	            cmd.CommandText = "CREATE TABLE emp (empno INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY, first_name VARCHAR(20), last_name VARCHAR(20), birthdate DATE)"
	            cmd.ExecuteNonQuery()
	
	            cmd.CommandText = "CREATE PROCEDURE add_emp(" & "IN fname VARCHAR(20), IN lname VARCHAR(20), IN bday DATETIME, OUT empno INT)" & "BEGIN INSERT INTO emp(first_name, last_name, birthdate) " & "VALUES(fname, lname, DATE(bday)); SET empno = LAST_INSERT_ID(); END"
	
	            cmd.ExecuteNonQuery()
	        Catch ex As MySqlException
	            Console.WriteLine(("Error " & ex.Number & " has occurred: ") + ex.Message)
	        End Try
	        conn.Close()
	        Console.WriteLine("Connection closed.")
	        Try
	            Console.WriteLine("Connecting to MySQL...")
	            conn.Open()
	            cmd.Connection = conn
	
	            cmd.CommandText = "add_emp"
	            cmd.CommandType = CommandType.StoredProcedure
	
	            cmd.Parameters.AddWithValue("@lname", "Jones")
	            cmd.Parameters("@lname").Direction = ParameterDirection.Input
	
	            cmd.Parameters.AddWithValue("@fname", "Tom")
	            cmd.Parameters("@fname").Direction = ParameterDirection.Input
	
	            cmd.Parameters.AddWithValue("@bday", "1940-06-07")
	            cmd.Parameters("@bday").Direction = ParameterDirection.Input
	
	            cmd.Parameters.AddWithValue("@empno", MySqlDbType.Int32)
	            cmd.Parameters("@empno").Direction = ParameterDirection.Output
	
	            cmd.ExecuteNonQuery()
	
	            Console.WriteLine("Employee number: " & cmd.Parameters("@empno").Value)
	            Console.WriteLine("Birthday: " & cmd.Parameters("@bday").Value)
	        Catch ex As MySql.Data.MySqlClient.MySqlException
	            Console.WriteLine(("Error " & ex.Number & " has occurred: ") + ex.Message)
	        End Try
	        conn.Close()
	        Console.WriteLine("Done.")
	
	    End Sub
	
	End Module

[22.2.5.10]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.10
#### 22.2.5.10. 用Connector/Net处理BLOB数据

在_BLOB_列中的二进制数据存储是一种用于MySQL的公用块。MySQL支持四种不同的BLOB数据类型：_TINYBLOB_，_BLOB_，_MEDIUMBLOB_和_LONGBLOB_，所有都记述在[章节 11.4.3, “BLOB和TEXTT类型”](/Chapter11/11.4.3_The_BLOB_and_TEXT_Types#11.4.3)和[章节 11.6, “Data Type Storage Requirements”](/Chapter11/11.6.0_Data_Type_Storage_Requirements)中。

存储在一个_BLOB_列中的数据可以使用Connector/Net来进行访问，并且可以使用客户端代码进行操纵。对Connector/Net和_BLOB_一起使用没有什么特别的要求。

简单代码示例会在本章介绍，完整的应用程序示例可以在Connector/Net初期化的_Samples_目录中找到。

##### 22.2.5.10.1. Preparing the MySQL Server

第一步是使用MySQL的BLOB数据设置服务器。让我们从创建一个被访问的表开始。在我的文件表中，通常有四列：一个用于识别文件的主键的适当大小的_AUTO\_INCREMENT_列，一个存储文件名的_VARCHAR_列，一个存储文件大小的_UNSIGNED MEDIUMINT_列和一个文件自身的_MEDIUMBLOB_列。对此举例，我会用以下表定义：

	CREATE TABLE file(
	file_id SMALLINT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
	file_name VARCHAR(64) NOT NULL,
	file_size MEDIUMINT UNSIGNED NOT NULL,
	file MEDIUMBLOB NOT NULL);

在创建一张表后，你可能会需要修改系统变量_max_allowed_packet_。该变量决定一个多大的数据分组被发送到MySQL服务器。默认情况下，服务器只能接收客户端应用程序的最大1MB大小的文件。如果你打算传送超过1MB的文件，就要增加该数字。

_max\_allowed\_packet_选项可以使用MySQL工作台**Server Administration**界面进行修改。在the Networking tab to an appropriate setting的**Data / Memory size**节中调整允许的最大值选项。在调整过值之后，单击**Apply**按钮并且使用MySQL工作台的Startup / Shutdown界面重启服务器。你也可以在_my.cnf_文件（添加一行_max\_allowed\_packet=xxM_）中直接调整该值，或者使用MySQL中的_SET max\_allowed\_packet=xxM;_语法。

当尝试保守地设置_max\_allowed\_packet_时，BLOB数据的传输可以花费一些时间完成。如果需要的话，尝试设置一个有足够预期用途和增长值的值。

##### 22.2.5.10.2. 向数据库写入一个文件

为了向数据库写入一个文件，我们需要把它转换为字节数组，然后使用该字节数组作为参数放入一个_INSERT_查询中。

以下代码使用一个FileStream对象打开一个文件，把该文件读入到一个字节数组中，并插入到_file_表中：

**Visual Basic示例**

	Dim conn As New MySqlConnection
	Dim cmd As New MySqlCommand
	
	Dim SQL As String
	
	Dim FileSize As UInt32
	Dim rawData() As Byte
	Dim fs As FileStream
	
	conn.ConnectionString = "server=127.0.0.1;" _
	    & "uid=root;" _
	    & "pwd=12345;" _
	    & "database=test"
	
	Try
	    fs = New FileStream("c:\image.png", FileMode.Open, FileAccess.Read)
	    FileSize = fs.Length
	
	    rawData = New Byte(FileSize) {}
	    fs.Read(rawData, 0, FileSize)
	    fs.Close()
	
	    conn.Open()
	
	    SQL = "INSERT INTO file VALUES(NULL, @FileName, @FileSize, @File)"
	
	    cmd.Connection = conn
	    cmd.CommandText = SQL
	    cmd.Parameters.AddWithValue("@FileName", strFileName)
	    cmd.Parameters.AddWithValue("@FileSize", FileSize)
	    cmd.Parameters.AddWithValue("@File", rawData)
	
	    cmd.ExecuteNonQuery()
	
	    MessageBox.Show("File Inserted into database successfully!", _
	    "Success!", MessageBoxButtons.OK, MessageBoxIcon.Asterisk)
	
	    conn.Close()
	Catch ex As Exception
	    MessageBox.Show("There was an error: " & ex.Message, "Error", _
	        MessageBoxButtons.OK, MessageBoxIcon.Error)
	End Try

**C#示例**

	MySql.Data.MySqlClient.MySqlConnection conn;
	MySql.Data.MySqlClient.MySqlCommand cmd;
	
	conn = new MySql.Data.MySqlClient.MySqlConnection();
	cmd = new MySql.Data.MySqlClient.MySqlCommand();
	
	string SQL;
	UInt32 FileSize;
	byte[] rawData;
	FileStream fs;
	
	conn.ConnectionString = "server=127.0.0.1;uid=root;" +
	    "pwd=12345;database=test;";
	
	try
	{
	    fs = new FileStream(@"c:\image.png", FileMode.Open, FileAccess.Read);
	    FileSize = fs.Length;
	
	    rawData = new byte[FileSize];
	    fs.Read(rawData, 0, FileSize);
	    fs.Close();
	
	    conn.Open();
	
	    SQL = "INSERT INTO file VALUES(NULL, @FileName, @FileSize, @File)";
	
	    cmd.Connection = conn;
	    cmd.CommandText = SQL;
	    cmd.Parameters.AddWithValue("@FileName", strFileName);
	    cmd.Parameters.AddWithValue("@FileSize", FileSize);
	    cmd.Parameters.AddWithValue("@File", rawData);
	
	    cmd.ExecuteNonQuery();
	
	    MessageBox.Show("File Inserted into database successfully!",
	        "Success!", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
	
	    conn.Close();
	}
	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
	    MessageBox.Show("Error " + ex.Number + " has occurred: " + ex.Message,
	        "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
	}

_FileStream_对象的_Read_方法用于加载文件到一个大小由_FileStream_对象的_Length_属性决定的字符数组中。

在把字符数组赋值给_MySqlCommand_对象的变量之后，_ ExecuteNonQuery_被调用并且_BLOB_会被插入到_file_表中。

##### 22.2.5.10.3. Reading a BLOB from the Database to a File on Disk

一旦一个文件加载到_file_表中，我们就可以使用_MySqlDataReader_类去检索它了。

以下代码是从_file_表中检索一行数据，然后加载该数据到一个用于写到硬盘的_FileStream_对象中。

**Visual Basic示例**

	Dim conn As New MySqlConnection
	Dim cmd As New MySqlCommand
	Dim myData As MySqlDataReader
	Dim SQL As String
	Dim rawData() As Byte
	Dim FileSize As UInt32
	Dim fs As FileStream
	
	conn.ConnectionString = "server=127.0.0.1;" _
	    & "uid=root;" _
	    & "pwd=12345;" _
	    & "database=test"
	
	SQL = "SELECT file_name, file_size, file FROM file"
	
	Try
	    conn.Open()
	
	    cmd.Connection = conn
	    cmd.CommandText = SQL
	
	    myData = cmd.ExecuteReader
	
	    If Not myData.HasRows Then Throw New Exception("There are no BLOBs to save")
	
	    myData.Read()
	
	    FileSize = myData.GetUInt32(myData.GetOrdinal("file_size"))
	    rawData = New Byte(FileSize) {}
	
	    myData.GetBytes(myData.GetOrdinal("file"), 0, rawData, 0, FileSize)
	
	    fs = New FileStream("C:\newfile.png", FileMode.OpenOrCreate, FileAccess.Write)
	    fs.Write(rawData, 0, FileSize)
	    fs.Close()
	
	    MessageBox.Show("File successfully written to disk!", "Success!", MessageBoxButtons.OK, MessageBoxIcon.Asterisk)
	
	    myData.Close()
	    conn.Close()
	Catch ex As Exception
	    MessageBox.Show("There was an error: " & ex.Message, "Error", MessageBoxButtons.OK, MessageBoxIcon.Error)
	End Try

**C#示例**

	MySql.Data.MySqlClient.MySqlConnection conn;
	MySql.Data.MySqlClient.MySqlCommand cmd;
	MySql.Data.MySqlClient.MySqlDataReader myData;
	
	conn = new MySql.Data.MySqlClient.MySqlConnection();
	cmd = new MySql.Data.MySqlClient.MySqlCommand();
	
	string SQL;
	UInt32 FileSize;
	byte[] rawData;
	FileStream fs;
	
	conn.ConnectionString = "server=127.0.0.1;uid=root;" +
	    "pwd=12345;database=test;";
	
	SQL = "SELECT file_name, file_size, file FROM file";
	
	try
	{
	    conn.Open();
	
	    cmd.Connection = conn;
	    cmd.CommandText = SQL;
	
	    myData = cmd.ExecuteReader();
	
	    if (! myData.HasRows)
	        throw new Exception("There are no BLOBs to save");
	
	    myData.Read();
	
	    FileSize = myData.GetUInt32(myData.GetOrdinal("file_size"));
	    rawData = new byte[FileSize];
	
	    myData.GetBytes(myData.GetOrdinal("file"), 0, rawData, 0, (int)FileSize);
	
	    fs = new FileStream(@"C:\newfile.png", FileMode.OpenOrCreate, FileAccess.Write);
	    fs.Write(rawData, 0, (int)FileSize);
	    fs.Close();
	
	    MessageBox.Show("File successfully written to disk!",
	        "Success!", MessageBoxButtons.OK, MessageBoxIcon.Asterisk);
	
	    myData.Close();
	    conn.Close();
	}
	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
	    MessageBox.Show("Error " + ex.Number + " has occurred: " + ex.Message,
	        "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
	}

连接之后，_file_表的内容就被加载到一个_MySqlDataReader_对象中。_MySqlDataReader_的_GetBytes_方法被用于加载_BLOB_到一个字节数组中，该字节数组将使用_FileStream_对象写到硬盘中。

MySqlDataReader的_GetOrdinal_方法可以用于决定一个指定列的整型索引。如果_SELECT_查询的列顺序改变了，使用GetOrdinal方法可以防止错误产生。

[22.2.5.11]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.11
#### 22.2.5.11. 使用Connector/Net拦截器类

拦截器是一种软件设计模式，它提供了一个透明的方法来扩展或修改一段代码的某些方面，类似于一个用户退出。不需要重新编译。对于Connector/Net，拦截器可用与不可用是由更新连接字符串相关的实例化的拦截器类的不同的设置来决定。

Connector/Net包含以下拦截器类：

+ 当一个程序发出一个SQL命令的时候，_BaseCommandInterceptor_使你执行额外的操作。例如，你可以利用记录或调试目的检查该SQL语句，代替你自己的结果集去实现一个缓冲机制等等。根据用例，你的代码可以补充SQL命令或者完全替换它。  

	_BaseCommandInterceptor_类有下面这些方法可以重写：  

		public virtual bool ExecuteScalar(string sql, ref object returnValue);
		public virtual bool ExecuteNonQuery(string sql, ref int returnValue);`
		public virtual bool ExecuteReader(string sql, CommandBehavior behavior, ref MySqlDataReader returnValue);
		public virtual void Init(MySqlConnection connection);

	如果你的拦截器重写了_Execute..._方法中的一个，就会设置输出参数_returnValue_，并且如果你处理了该事件，那么就返回_true_，如果你没有处理该事件，那么就返回_false_。只有当所有的命令拦截器都返回_false_的时候，该SQL命令被正常地执行。

	传递到_Init_方法的连接到附属于这个拦截器的连接。

+ 当程序遇到一个SQL异常时，_BaseExceptionInterceptor_会执行额外的操作。异常拦截机制在Connector/J模式之后被模式化。你可以编写一个拦截器类并且把它连接到一个已经存在的未编译程序，而且当它们被创建的时候，拦截异常。然后你可以改变异常的类型并且随意地附加信息给它。这个功能使你无需在应用程序中做任何硬编码就可以打开或关闭记录和调试代码。这个技术应用于提高异常在SQL中的级别，达到不出现低级的系统或I/O错误的目的。

	你要开发一个异常拦截器，就必须要创建一个_BaseExceptionInterceptor_类的子类，并且必须重写_InterceptException()_方法。你也可以重写_Init()_方法做某些一次性初始化。

	每个异常拦截器都有2个方法：

		public abstract Exception InterceptException(Exception exception,
		  MySqlConnection connection);
		public virtual void Init(MySqlConnection connection);

	传递给_Init()_的连接被附加到这个拦截器上。

	每个拦截器都要求重写_InterceptException_并且返回一个异常。它会返回被赋给的异常，或者包装进一个新的异常里面。我们现在不提供抑制该异常的功能。

这有一些在连接字符串上使用FQN (fully qualified name)的例子：

	MySqlConnection c1 = new MySqlConnection(@"server=localhost;pooling=false;
	commandinterceptors=CommandApp.MyCommandInterceptor,CommandApp");
	
	MySqlConnection c2 = new MySqlConnection(@"server=localhost;pooling=false;
	exceptioninterceptors=ExceptionStackTraceTest.MyExceptionInterceptor,ExceptionStackTraceTest");

在这些例子中，命令拦截器被称作_CommandApp.MyCommandInterceptor_，并且存在于_CommandApp_ 集合中。异常拦截器被称作_ExceptionStackTraceTest.MyExceptionInterceptor_并且存在于_ExceptionStackTraceTest_集合中。

为了缩短连接字符串，你可以把你的异常拦截器记录在你的_app.config_或_web.config_文件中，就像这样：

	<configSections>
	<section name="MySQL" type="MySql.Data.MySqlClient.MySqlConfiguration, 
	MySql.Data"/>
	</configSections>
	<MySQL>
	<CommandInterceptors>
	  <add name="myC" type="CommandApp.MyCommandInterceptor,CommandApp" />
	</CommandInterceptors>
	</MySQL>
	
	<configSections>
	<section name="MySQL" type="MySql.Data.MySqlClient.MySqlConfiguration, 
	MySql.Data"/>
	</configSections>
	<MySQL>
	<ExceptionInterceptors>
	  <add name="myE" 
	type="ExceptionStackTraceTest.MyExceptionInterceptor,ExceptionStackTraceTest" />
	</ExceptionInterceptors>
	</MySQL>

一旦你那样做了，你的连接字符串就会看起来像下面一样：

	MySqlConnection c1 = new MySqlConnection(@"server=localhost;pooling=false;
	commandinterceptors=myC");
	
	MySqlConnection c2 = new MySqlConnection(@"server=localhost;pooling=false;
	exceptioninterceptors=myE");

[22.2.5.12]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.12
#### 22.2.5.12. 处理Connector/Net中的日期和时间信息

MySQL和.NET语言处理日期和时间信息的不同之处，MySQL允许数据可以不使用一个.NET数据类型来表示，例如'0000-00-00 00:00:00'。如果不适当地处理，这些不同之处就会引起问题。

以下章节演示了在使用Connector/Net时，如何适当地处理日期和时间信息。

##### 22.2.5.12.1. 小数秒

Connector/Net 6.5和更高版本支持分数秒特性在MySQL 5.6.4.中有介绍，小数秒总是能够被指定为一个日期文字或作为参数和返回值向后和向前传递，但是当存储在一张表的列中的时候，小数部分总是被去除的。在MySQL 5.6.4以及更高版本中，现在小数部分被保存在数据存储中并通过SQL检索。在MySQL 5.6.4以及更高版本中，关于小数秒的处理请参看[章节11.3.6, “时间值小数秒”](/Chapter11/11.3.6_Fractional_Seconds_in_Time_Values#11.3.6)。在MySQL 5.6.4之前，关于小数秒的表现请参看[时间值小数秒](/Chapter11/11.3.6_Fractional_Seconds_in_Time_Values#11.3.6)。

为了使用更加精确的日期和时间类型，当创建表的列使，需要指定一个从1到6的值。例如_TIME(3)_或_DATETIME(6)_，代表小数点后的数字精度的位数。指定精度为0就是完全没有小数部分。在你的C#或Visual Basic代码中，参考_Millisecond_成员从_GetMySqlDateTime_函数返回的_MySqlDateTime_对象中检索小数秒的值。由_GetDateTime_函数返回的_DateTime_对象包含小数的值，但是仅有数字的前3位。

对于涉及到代码的例子，请参看以下博客的帖子：[https://blogs.oracle.com/MySqlOnWindows/entry/milliseconds_value_support_on_datetime](https://blogs.oracle.com/MySqlOnWindows/entry/milliseconds_value_support_on_datetime)

##### 22.2.5.12.2. 使用无效日期的时候的问题

在日期处理中的差异会对使用无效日期的开发者引起问题。无效的MySQL日期（包括_NULL_日期）不会被加载到本地的.NET_DateTime_对象中。

由于这个问题，.Net的_DataSet_对象不能被_MySqlDataAdapter_类的_Fill_方法填充，因为无效日期会引发一个_System.ArgumentOutOfRangeException_异常。

##### 22.2.5.12.3. 约束无效日期

对于日期问题的最好解决方案是从无效日期的输入开始约束用户。这个在客户端或服务器端做都可以。

在客户端约束无效日期只要简单地使用.NET的_DateTime_类去处理日期。_DateTime_类只允许有效的日期，以确保该值在你的数据库中也是有效的。它的缺点是不能用于.NET和非.NET代码来操作数据库的混合环境，因为每个应用程序必须执行它自己的日期验证。

MySQL 5.0.2和更高版本的用户可以使用新的_traditional_SQL模式来约束无效日期值。关于使用_traditional_SQL模式的信息，请参看[章节5.1.7, “服务器SQL模式”]()。

##### 22.2.5.12.4. 处理无效日期

虽然强烈建议你避免在.NET应用程序中使用无效日期，但是靠_MySqlDateTime_数据类型的方法还是可以使用无效日期的。

_MySqlDateTime_数据类型支持被MySQL服务支持的相同的日期值。Connector/Net的默认行为是对于有效日期值返回一个.NET DateTime对象，而对于无效日期返回一个错误。该默认可以被修改成对于无效日期引发Connector/Net返回_MySqlDateTime_对象。

为了通知Connector/Net返回一个关于无效日期的_MySqlDateTime_对象，附加下面一行到你的连接字符串：

	Allow Zero Datetime=True

请注意_MySqlDateTime_类的使用仍会有问题。以下是某些已知的问题：

1. 无效日期的数据绑定仍会引发错误（像0000-00-00的零日期不像是有这种问题）。
2. _ToString_方法返回一个以标准MySQL格式（例如：_2005-02-23 08:50:25_）被格式化的日期。这与.NET DateTime类的_ToString_行为不同。
3. _MySqlDateTime_类支持NULL日期，而.NET DateTime类不支持。当你试图把MySQLDateTime转换成DateTime的时候，如果不先验证NULL值，这就会引发错误。

因为已知问题，最好的建议是在你的应用程序中仍只使用有效日期。

##### 22.2.5.12.5. 处理NULL日期

.NET_DateTime_数据类型不能处理_NULL_值。例如，当从一个查询给一个_DateTime_变量赋值时，你必须首先验证这个值是否实际为_NULL_。

当使用_MySqlDataReader_的时候，在赋值之前使用_.IsDBNull_方法来检查是否为NULL值：

**Visual Basic示例**

	If Not myReader.IsDBNull(myReader.GetOrdinal("mytime")) Then
	    myTime = myReader.GetDateTime(myReader.GetOrdinal("mytime"))
	Else
	    myTime = DateTime.MinValue
	End If

**C#示例**

	if (! myReader.IsDBNull(myReader.GetOrdinal("mytime")))
	    myTime = myReader.GetDateTime(myReader.GetOrdinal("mytime"));
	else
	    myTime = DateTime.MinValue;

_NULL_值将插入到一个数据集合中并会被绑定到无特殊处理的表格控件。

[22.2.5.13]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.13
#### 22.2.5.13. 使用_MySqlBulkLoader_类

MySQL Connector/Net以一个大块加载类为特色，该类包装了MySQL语句[LOAD DATA INFILE](../Chapter13/13.02.06_LOAD_DATA_INFILE_Syntax#13.2.6)。这个授予MySQL Connector/Net了从本地或远程主机加载一个数据文件到服务器的能力。该有关的类是_MySqlBulkLoader_。这个类有各种各样的方法，其中主要的一个是_load_，它用于引发被指定的文件加载到服务器。各种类型的参数会被设置为控制如何处理数据文件。这是通过设置各种各样的该类的属性来完成的。例如，使用像逗号或制表符的字段分隔符，连同像换行符一样的记录终止子都可以被指定。

以下代码展示了一个使用_MySqlBulkLoader_类的简单例子。在这个例子中，首先需要在_test_数据库中创建一个空表：

	CREATE TABLE Career (
	       Name VARCHAR(100) NOT NULL,
	       Age INTEGER,
	       Profession VARCHAR(200)
	);

创建一个简单的以制表符分隔的数据文件（可以使用其他任何字段分隔符，例如逗号）：

	Table Career in Test Database
	Name  Age  Profession
	
	Tony  47  Technical Writer
	Ana  43  Nurse
	Fred  21  IT Specialist
	Simon  45  Hairy Biker

注意，对于这个测试文件的前三行会被忽略，因为它们不包含表数据。这会使用_NumberOfLinesToSkip_属性完成。这个文件仍会被加载并用于填入_test_数据库中的_Career_表中：

	using System;
	using System.Text;
	using MySql.Data;
	using MySql.Data.MySqlClient;
	
	namespace ConsoleApplication1
	{
	    class Program
	    {
	        static void Main(string[] args)
	        {
	
	            string connStr = "server=localhost;user=root;database=test;port=3306;password=******;";
	            MySqlConnection conn = new MySqlConnection(connStr);
	
	            MySqlBulkLoader bl = new MySqlBulkLoader(conn);
	            bl.TableName = "Career";
	            bl.FieldTerminator = "\t";
	            bl.LineTerminator = "\n";
	            bl.FileName = "c:/career_data.txt";
	            bl.NumberOfLinesToSkip = 3;
	
	            try
	            {
	                Console.WriteLine("Connecting to MySQL...");
	                conn.Open();
	
	                // Upload data from file
	                int count = bl.Load();
	                Console.WriteLine(count + " lines uploaded.");
	
	                string sql = "SELECT Name, Age, Profession FROM Career";
	                MySqlCommand cmd = new MySqlCommand(sql, conn);
	                MySqlDataReader rdr = cmd.ExecuteReader();
	
	                while (rdr.Read())
	                {
	                    Console.WriteLine(rdr[0] + " -- " + rdr[1] + " -- " + rdr[2]);
	                }
	
	                rdr.Close();
	
	                conn.Close();
	            }
	            catch (Exception ex)
	            {
	                Console.WriteLine(ex.ToString());
	            }
	            Console.WriteLine("Done.");
	        }
	    }
	}

关于_LOAD DATA INFILE_的进一步的信息可以在[章节13.2.6, “LOAD DATA INFILE Syntax”]()中找到。关于_MySqlBulkLoader_的进一步的信息可以在包含你的连接器的相关文档中找到。

[22.2.5.14]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.14
#### 22.2.5.14

MySQL Connector/Net 6.2引入了使用_TraceSource_对象的支持跟.NET 2.0兼容的跟踪。

.NET 2.0跟踪结构由4个主要部分组成：

+ _Source_ - 这是跟踪信息的发起人。该Source用于发送跟踪消息。由MySQL Connector/Net提供的该source的名称是_mysql_。

+ _Switch_ - 这个定义了发出跟踪信息的等级。典型地来说，这是在_app.config_文件中被指定，所以不需要重新编译一个应用程序来改变跟踪等级。

+ _ Listener_ - 跟踪监听器定义在跟踪信息被写入的地方。支持的监听器包括，如Visual Studio Output窗口，Windows Event Log和控制台等。

+ _Filter_ - 过滤器可以附加到监听器上。过滤器决定跟踪信息写入的等级。当一个交换器定义信息等级的时候，会被写入到所有的监听器，而一个过滤器可以被应用在a per-listener basis，给予更细粒度的跟踪信息的控制。

为了使用跟踪，搜西安需要创建一个_TraceSource_对象。要在MySQL Connector/Net中创建一个_TraceSource_对象，你就要使用类似以下的代码：

	TraceSource ts = new TraceSource("mysql");

为了使跟踪信息可用，需要配置一个跟踪交换器。有3个主要的交换器类，_BooleanSwitch_，_SourceSwitch_ 和 _TraceSwitch_。跟踪交换器也与跟踪等级枚举有关，这些枚举有_off_ ，_Error_，_Warning_ 和_Verbose_。以下代码片段阐明了一个交换器的创建：

	ts.Switch = new SourceSwitch("MySwitch", "Verbose");

这里创建一个_SourceSwitch_，然后调用_MySwitch_，并且设置 _Verbose_ 的等级，意味着所有的跟踪消息都会被写入。

很方便的无需重新编译代码就可以改变跟踪等级。这是依靠在应用程序配置文件_app.config_ 中指定跟踪等级来完成的。然后你只需要在配置文件中简单地指定你想要的跟踪等级，并重新启动应用程序。跟踪源被配置在文件的_system.diagnostics_部分。用以下XML片段举例说明：

	<configuration>
	  ...
	  <system.diagnostics>
	    <sources>
	      <source name="mysql" switchName="MySwitch"
	              switchType="System.Diagnostics.SourceSwitch" />
	      ...
	    </sources>
	    <switches>
	      <add name="MySwitch" value="Verbose"/>
	      ...
	    </switches>
	  </system.diagnostics>
	  ...
	</configuration>

默认地，跟踪信息被写在Microsoft Visual Studio的输出窗口。有一个广泛的监听器可以被附加到跟踪源，因此跟踪消息可以被写到各种目标中。你也可以创建一个自定义监听器用于允许跟踪消息被写到其他的目标，比如移动设备和网络服务中。一个一般的监听器的用例是_ConsoleTraceListener_，它把跟踪消息写到控制台。

在执行时间添加一个监听器，使用类似下面的代码：

	ts.Listeners.Add(new ConsoleTraceListener());

然后调用跟踪源对象上面的方法来生成跟踪信息。例如，_TraceInformation()_，_TraceEvent()_，或 _TraceData()_ 方法能够被使用。

_TraceInformation()_方法简单地打印了一个作为参数传递的字符串。_TraceEvent()_方法就像可选信息字符串一样，需要把一个_TraceEventType_值传递给表示跟踪消息的类型，并且它也是一个应用程序的特殊ID。_TraceEventType_的值可以是_Verbose_， _Information_， _Warning_， _Error_ 和 _Critical_ 。使用_TraceData()_ 方法可以传递任何对象来代替一个消息，例如一个异常对象。为了确保这些生成的跟踪消息从跟踪源缓冲区获得充足的监听器，需要调用 _Flush()_ 方法。当你完成了一个跟踪源的使用，就调用 _Close()_ 方法。_Close()_ 方法首先会调用 _Flush()_ 来确保任何剩余的数据被写出。然后就会空出资源，并且关闭与跟踪源有关的监听器。

	ts.TraceInformation("Informational message");
	ts.TraceEvent(TraceEventType.Error, 3, "Optional error message");
	ts.TraceData(TraceEventType.Error, 3, ex); // pass exception object
	ts.Flush();
	...
	ts.Close();

##### 22.2.5.14.1. 查看MySQL跟踪信息

本章描述了如何设置你的应用程序来查看MySQL跟踪信息。

你首先要做的是为你的应用程序创建一个适当的 _app.config_ 文件。一个示例如下代码所示：

	<?xml version="1.0" encoding="utf-8" ?>
	<configuration>
	  <system.diagnostics>
	    <sources>
	      <source name="mysql" switchName="SourceSwitch"
	        switchType="System.Diagnostics.SourceSwitch" >
	        <listeners>
	          <add name="console" />
	          <remove name ="Default" />
	        </listeners>
	      </source>
	    </sources>
	    <switches>
	      <!-- You can set the level at which tracing is to occur -->
	      <add name="SourceSwitch" value="Verbose" />
	      <!-- You can turn tracing off -->
	      <!--add name="SourceSwitch" value="Off" -->
	    </switches>
	    <sharedListeners>
	      <add name="console"
	        type="System.Diagnostics.ConsoleTraceListener"
	        initializeData="false"/>
	    </sharedListeners>
	  </system.diagnostics>
	</configuration>

这确保了一个伴随一个交换器的合适的跟踪源被创建。该交换器等级在这个例子中是设置在 _Verbose_ 中来显示信息的最大量。

在该应用程序中，只有其他步骤要求添加 _logging=true_ 到连接字符串中。以下是一个应用程序示例：

	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Diagnostics;
	using MySql.Data;
	using MySql.Data.MySqlClient;
	using MySql.Web;
	
	
	namespace ConsoleApplication1
	{
	    class Program
	    {
	        static void Main(string[] args)
	        {
	
	            string connStr = "server=localhost;user=root;database=world;port=3306;password=******;logging=true;";
	            MySqlConnection conn = new MySqlConnection(connStr);
	            try
	            {
	                Console.WriteLine("Connecting to MySQL...");
	                conn.Open();
	
	                string sql = "SELECT Name, HeadOfState FROM Country WHERE Continent='Oceania'";
	                MySqlCommand cmd = new MySqlCommand(sql, conn);
	                MySqlDataReader rdr = cmd.ExecuteReader();
	
	                while (rdr.Read())
	                {
	                    Console.WriteLine(rdr[0] + " -- " + rdr[1]);
	                }
	
	                rdr.Close();
	
	                conn.Close();
	            }
	            catch (Exception ex)
	            {
	                Console.WriteLine(ex.ToString());
	            }
	            Console.WriteLine("Done.");
	        }
	    }
	}

这个简单的应用程序会生成以下的输出：

	Connecting to MySQL...
	mysql Information: 1 : 1: Connection Opened: connection string = 'server=localhost;User Id=root;database=world;port=3306
	;password=******;logging=True'
	mysql Information: 3 : 1: Query Opened: SHOW VARIABLES
	mysql Information: 4 : 1: Resultset Opened: field(s) = 2, affected rows = -1, inserted id = -1
	mysql Information: 5 : 1: Resultset Closed. Total rows=272, skipped rows=0, size (bytes)=7058
	mysql Information: 6 : 1: Query Closed
	mysql Information: 3 : 1: Query Opened: SHOW COLLATION
	mysql Information: 4 : 1: Resultset Opened: field(s) = 6, affected rows = -1, inserted id = -1
	mysql Information: 5 : 1: Resultset Closed. Total rows=127, skipped rows=0, size (bytes)=4102
	mysql Information: 6 : 1: Query Closed
	mysql Information: 3 : 1: Query Opened: SET character_set_results=NULL
	mysql Information: 4 : 1: Resultset Opened: field(s) = 0, affected rows = 0, inserted id = 0
	mysql Information: 5 : 1: Resultset Closed. Total rows=0, skipped rows=0, size (bytes)=0
	mysql Information: 6 : 1: Query Closed
	mysql Information: 10 : 1: Set Database: world
	mysql Information: 3 : 1: Query Opened: SELECT Name, HeadOfState FROM Country WHERE Continent='Oceania'
	mysql Information: 4 : 1: Resultset Opened: field(s) = 2, affected rows = -1, inserted id = -1
	American Samoa -- George W. Bush
	Australia -- Elisabeth II
	...
	Wallis and Futuna -- Jacques Chirac
	Vanuatu -- John Bani
	United States Minor Outlying Islands -- George W. Bush
	mysql Information: 5 : 1: Resultset Closed. Total rows=28, skipped rows=0, size (bytes)=788
	mysql Information: 6 : 1: Query Closed
	Done.
	mysql Information: 2 : 1: Connection Closed

在跟踪消息中第一个编号显示了符合的MySQL事件类型：

<table border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Event</th><th scope="col">Description</th></tr></thead><tbody><tr><td scope="row">1</td><td>ConnectionOpened: connection string</td></tr><tr><td scope="row">2</td><td>ConnectionClosed:</td></tr><tr><td scope="row">3</td><td>QueryOpened: mysql server thread id, query text</td></tr><tr><td scope="row">4</td><td>ResultOpened: field count, affected rows (-1 if select), inserted id (-1
                if select)</td></tr><tr><td scope="row">5</td><td>ResultClosed: total rows read, rows skipped, size of resultset in bytes</td></tr><tr><td scope="row">6</td><td>QueryClosed:</td></tr><tr><td scope="row">7</td><td>StatementPrepared: prepared sql, statement id</td></tr><tr><td scope="row">8</td><td>StatementExecuted: statement id, mysql server thread id</td></tr><tr><td scope="row">9</td><td>StatementClosed: statement id</td></tr><tr><td scope="row">10</td><td>NonQuery: [varies]</td></tr><tr><td scope="row">11</td><td>UsageAdvisorWarning: usage advisor flag. NoIndex = 1, BadIndex = 2,
                SkippedRows = 3, SkippedColumns = 4, FieldConversion =
5.</td></tr><tr><td scope="row">12</td><td>Warning: level, code, message</td></tr><tr><td scope="row">13</td><td>Error: error number, error message</td></tr></tbody></table>

在跟踪消息中第二个编号显示了连接数。

虽然这个例子用的是 _ConsoleTraceListener_ ，但是任何其它标准的监听器都可以被使用。另一种可能性是创建一个使用 _TraceEvent_ 方法进行信息传递的自定义监听器。例如，一个自定义跟踪监听器可以执行MySQL时间消息的主动监视来创建，甚至把这些简单地写入到一个输出设备。

它也可以在运行时间添加监听器到MySQL跟踪源。这可以使用以下代码实现：

	MySqlTrace.Listeners.Add(new ConsoleTraceListener());

MySQL Connector/Net 6.3.2引入了在运行时间开启和关闭交换器跟踪的功能。这个可以调用 _MySqlTrace.EnableQueryAnalyzer(string host, int postInterval)_ 和 _MySqlTrace.DisableQueryAnalyzer()_ 来完成。参数 _host_ 是用于监控MySQL企业监控服务器的URL。参数 _postInterval_ 表示以每秒为单位多久会路由数据到MySQL企业监控服务器。

##### 22.2.5.14.2. 建立自定义监听器

为了建立和MySQL Connector/Net跟踪源一起工作的自定义监听器，需要明白key方法的使用和时间数据格式的使用。

包括传递跟踪消息的主要方法是 _TraceSource.TraceEvent_ 方法。以下是原型：

	public void TraceEvent(
	    TraceEventType eventType,
	    int id,
	    string format,
	    params Object[] args
	)

这个跟踪源方法将会加工附加的监听器的列表和调用监听器的 _TraceListener.TraceEvent_ 方法。_TraceListener.TraceEvent_ 方法的原型如下：

	public virtual void TraceEvent(
	    TraceEventCache eventCache,
	    string source,
	    TraceEventType eventType,
	    int id,
	    string format,
	    params Object[] args
	)

前三个参数以[defined by Microsoft.](http://msdn.microsoft.com/en-us/library/d193webf.aspx)的标准来使用。后三个参数包含MySQL指定跟踪信息。现在对这些参数逐个做更加详细的讨论。

_int id_

这个是MySQL指定的标示符。它识别已经发成的MySQL事件类型，导致在一个跟踪消息被生成。这个值由包含在MySQL Connector/Net代码中的 _MySqlTraceEventType_ 公有枚举所定义：

	public enum MySqlTraceEventType : int
	{
	    ConnectionOpened = 1,
	    ConnectionClosed,
	    QueryOpened,
	    ResultOpened,
	    ResultClosed,
	    QueryClosed,
	    StatementPrepared,
	    StatementExecuted,
	    StatementClosed,
	    NonQuery,
	    UsageAdvisorWarning,
	    Warning,
	    Error
	}

该MySQL事件类型也决定了使用参数 _params Object[] args_ 来传递的内容。_args_ 参数的本质在接下来的资料中更加详细的描述。

_string format_

这是包含0到多个格式项目的格式字符串，它符合于在args数组中的对象。这可以被像 _ConsoleTraceListener_ 一样的监听器所使用，把一个消息写到输出设备。

_params Object[] args_

这是一个依赖于MySQL事件类型的对象列表，_id_。然而，第一个参数使用一直是驱动器id的列表传递。该驱动器id是唯一的数字，它会在每次连接器打开的时候增长。这使在相同的连接上定义的查询组可用。这些参数遵循依赖于MySQL事件id的驱动器id，如下所示：

<table border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">MySQL-specific event type</th><th scope="col">Arguments (params Object[] args)</th></tr></thead><tbody><tr><td scope="row">ConnectionOpened</td><td>Connection string</td></tr><tr><td scope="row">ConnectionClosed</td><td>No additional parameters</td></tr><tr><td scope="row">QueryOpened</td><td>mysql server thread id, query text</td></tr><tr><td scope="row">ResultOpened</td><td>field count, affected rows (-1 if select), inserted id (-1 if select)</td></tr><tr><td scope="row">ResultClosed</td><td>total rows read, rows skipped, size of resultset in bytes</td></tr><tr><td scope="row">QueryClosed</td><td>No additional parameters</td></tr><tr><td scope="row">StatementPrepared</td><td>prepared sql, statement id</td></tr><tr><td scope="row">StatementExecuted</td><td>statement id, mysql server thread id</td></tr><tr><td scope="row">StatementClosed</td><td>statement id</td></tr><tr><td scope="row">NonQuery</td><td>Varies</td></tr><tr><td scope="row">UsageAdvisorWarning</td><td>usage advisor flag. NoIndex = 1, BadIndex = 2, SkippedRows = 3,
SkippedColumns = 4, FieldConversion = 5.</td></tr><tr><td scope="row">Warning</td><td>level, code, message</td></tr><tr><td scope="row">Error</td><td>error number, error message</td></tr></tbody></table>

这个信息允许你创建自定义跟踪监听器，它可以主动地监视MySQL指定事件。

[22.2.5.15]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.15
#### 22.2.5.15. 二进制/非二进制问题

MySQL必然会返回一到多列不正确的元数据。更具体地说，当它不是且相反的情况下，服务器有时会以二进制描述一个列。在这些情况下，连接器正确地识别正确的元数据实际上已经成为不可能。

以下是一些可能返回不正确的元数据的情形的例子：

+ [SHOW PROCESSLIST](/docs/Chapter_13/13.7.5.30_SHOW_PROCESSLIST_Syntax#13.7.5.30)的执行。某些列将返回二进制，即使他们只持有字符串数据。

+ 当一个临时表被用来处理一个结果集，某些列会返回不正确的二进制标志。

+ 某些服务器功能，像 _DATE\_FORMAT_ 会不正确地返回二进制列。

根据 _BINARY_ 和 _VARBINARY_ 数据类型的可用性，我们遵守由服务器返回的元数据是很重要的。然而，据我们所知一些攒在的应用程序可能由于这些改变而破坏，因此，我们创建一个连接字符串选项使其可用或不可用。默认地，Connector/Net 5.1遵守由服务器返回的二进制标志。你肯能需要对你的应用程序做一点改变以适应这个改变。

在该事件中，要求你的应用程序的改变会非常大，添加 _'respect binary flags=false'_ 到你的连接字符串导致连接器使用前置行为：任意列都被作为字符串，不管二进制标志，而作为字符串被返回。仅仅特别地标记为一个 _BLOB_ 的列会被作为 _BLOB_ 返回。

[22.2.5.16]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.16
#### 22.2.5.16. Character Set Considerations for Connector/Net
***Treating Binary Blobs As UTF8***

MySQL现在不支持4字节UTF8序列。这使得很难表示像日语一样的某些多自己语言。为了尝试并缓和这个问题，现在Connector/Net支持可以被视为字符串的binary blobs模式。

为了达到这样的效果，你需要设置 _'Treat Blobs As UTF8'_ 连接字符串关键字为 _yes_。为了使所有的binary blobs能够转换成UTF8字符串，这是所有的情况都要做的。仅要转换某些BLOB列的话，你可以使用 _'BlobAsUTF8IncludePattern'_ 和 _'BlobAsUTF8ExcludePattern'_ 关键字。把这些设置到一个正则表达式模式，分别地匹配列名来实现包含或不包含。

当正则表达式模式都匹配单个列，包含模式在不包含模式之前被应用。在这种情况下，结果将不包含该列。而且，请注意这个模式不能应用到 _BINARY_ 或 _VARBINARY_ 类型的列，并且也不能应用到非二进制 _BLOB_ 列。

目前，这种模式只适用于在MySQL之外读取字符串。要插入4字节UTF8字符串到blob列，需要使用.NET的 _Encoding.GetBytes_ 函数来转换字符串到一系列的字节。然后，你可以把这个自己数组作为一个与 _BLOB_ 列对应的参数进行设置。

[22.2.5.17]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.17
#### 22.2.5.17. Using Connector/Net with Crystal Reports

水晶报表是一个Windows应用程序开发者的常用工具，它执行报告和文档生成。在本章节我们景展示如何在MySQL和Connector/Net中使用Crystal Reports XI。

##### 22.2.5.17.1. 创建一个数据源

当在Crystal Reports中创建一个报表时，there are two options for accessing the MySQL data while designing your report.

第一个选项是当设计你的报表时把Connector/ODBC作为一个ADO数据源使用。你将可以浏览你的数据库并选择表和字段用于拖动和放弃建立你的报表。这个方法的缺点是在你的应用程序中使用你的报表生成一个匹配所期望的数据集合这个额外的工作必须被执行。

第二个选项是在VB.NET中创建一个数据集合并保存为XML。那么这个XML文件就可以用于设计一个报表。当在你的应用程序中展示报表的时候，这个工作相当好，但是它在设计次数方面缺少通用性，因为当你创建数据集合的时候，必须选择所有有关的列。如果你忘了一列，那么你就必须在该列被加到列表之前重新创建该数据集合。

以下代码可以用于从一个检索中创建一个数据集合并把它写入到硬盘：

**Visual Basic示例**

	Dim myData As New DataSet
	Dim conn As New MySqlConnection
	Dim cmd As New MySqlCommand
	Dim myAdapter As New MySqlDataAdapter
	
	conn.ConnectionString = "server=127.0.0.1;" _
	    & "uid=root;" _
	    & "pwd=12345;" _
	    & "database=world"
	
	Try
	    conn.Open()
	    cmd.CommandText = "SELECT city.name AS cityName, city.population AS CityPopulation, " _
	        & "country.name, country.population, country.continent " _
	        & "FROM country, city ORDER BY country.continent, country.name"
	    cmd.Connection = conn
	
	    myAdapter.SelectCommand = cmd
	    myAdapter.Fill(myData)
	
	    myData.WriteXml("C:\dataset.xml", XmlWriteMode.WriteSchema)
	Catch ex As Exception
	    MessageBox.Show(ex.Message, "Report could not be created", MessageBoxButtons.OK, MessageBoxIcon.Error)
	End Try

**C#示例**

	DataSet myData = new DataSet();
	MySql.Data.MySqlClient.MySqlConnection conn;
	MySql.Data.MySqlClient.MySqlCommand cmd;
	MySql.Data.MySqlClient.MySqlDataAdapter myAdapter;
	
	conn = new MySql.Data.MySqlClient.MySqlConnection();
	cmd = new MySql.Data.MySqlClient.MySqlCommand();
	myAdapter = new MySql.Data.MySqlClient.MySqlDataAdapter();
	
	conn.ConnectionString = "server=127.0.0.1;uid=root;" +
	  "pwd=12345;database=test;";
	
	try
	{
	  cmd.CommandText = "SELECT city.name AS cityName, city.population AS CityPopulation, " +
	  "country.name, country.population, country.continent " +
	  "FROM country, city ORDER BY country.continent, country.name";
	  cmd.Connection = conn;
	
	  myAdapter.SelectCommand = cmd;
	  myAdapter.Fill(myData);
	
	  myData.WriteXml(@"C:\dataset.xml", XmlWriteMode.WriteSchema);
	}
	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
	  MessageBox.Show(ex.Message, "Report could not be created",
	  MessageBoxButtons.OK, MessageBoxIcon.Error);
	}

当设计你的报表的时候，这个产生的XML文件能够被用作一个ADO.NET XML数据源。

如果你选择用Connector/ODBC设计你的报表，它可以从[dev.mysql.com](http://dev.mysql.com/downloads/connector/odbc/3.51.html)下载。

##### 22.2.5.17.2. 创建报表

对于大多数用途来说，标准的报表向导帮助一个报表的初始化创建。要开始该向导，需要打开Crystal Reports并从文件菜单中选择 **New > Standard Report** 选项。

该向导首先做一个关于数据源的提示。如果你把Connector/ODBC作为你的数据源使用，那么为了当选择数据源的时候，ODBC选项从OLE DB (ADO)树代替ODBC (RDO)树需要使用OLEDB提供器。如果使用一个①保存的数据集合，那么选择ADO.NET (XML)选项并浏览你的保存的数据集合。

报表创建进程的剩余部分由向导自动完成。

在报表创建之后，选择报表选项（文件菜单的条目）。使用报表选项无检查保存数据。这个防止在我们的应用程序中保存的数据与数据加载冲突。

##### 22.2.5.17.3. 展示报表

为了展示一个报表，我们首先要用该报表所需的数据填充一个数据集合，然后加载该报表并把它绑定到该数据集合。最后，我们把该报表传递给crViewer控件来展示给用户。

在一个展示报表的工程中，以下参照是被需要的：

+ CrystalDecisions.CrystalReports.Engine
+ CrystalDecisions.ReportSource
+ CrystalDecisions.Shared
+ CrystalDecisions.Windows.Forms

以下代码假定你使用一个数据集合保存你创建的报表（使用的代码展示在[章节 22.2.5.17.1, “Creating a Data Source”]()中），并且在你的名为 _myViewer_ 的表单上存在一个crViewer控件。

**Visual Basic示例**

	Imports CrystalDecisions.CrystalReports.Engine
	Imports System.Data
	Imports MySql.Data.MySqlClient
	
	Dim myReport As New ReportDocument
	Dim myData As New DataSet
	Dim conn As New MySqlConnection
	Dim cmd As New MySqlCommand
	Dim myAdapter As New MySqlDataAdapter
	
	conn.ConnectionString = _
	    "server=127.0.0.1;" _
	    & "uid=root;" _
	    & "pwd=12345;" _
	    & "database=test"
	
	Try
	    conn.Open()
	
	    cmd.CommandText = "SELECT city.name AS cityName, city.population AS CityPopulation, " _
	        & "country.name, country.population, country.continent " _
	        & "FROM country, city ORDER BY country.continent, country.name"
	    cmd.Connection = conn
	
	    myAdapter.SelectCommand = cmd
	    myAdapter.Fill(myData)
	
	    myReport.Load(".\world_report.rpt")
	    myReport.SetDataSource(myData)
	    myViewer.ReportSource = myReport
	Catch ex As Exception
	    MessageBox.Show(ex.Message, "Report could not be created", MessageBoxButtons.OK, MessageBoxIcon.Error)
	End Try

**C#示例**

	using CrystalDecisions.CrystalReports.Engine;
	using System.Data;
	using MySql.Data.MySqlClient;
	
	ReportDocument myReport = new ReportDocument();
	DataSet myData = new DataSet();
	MySql.Data.MySqlClient.MySqlConnection conn;
	MySql.Data.MySqlClient.MySqlCommand cmd;
	MySql.Data.MySqlClient.MySqlDataAdapter myAdapter;
	
	conn = new MySql.Data.MySqlClient.MySqlConnection();
	cmd = new MySql.Data.MySqlClient.MySqlCommand();
	myAdapter = new MySql.Data.MySqlClient.MySqlDataAdapter();
	
	conn.ConnectionString = "server=127.0.0.1;uid=root;" +
	    "pwd=12345;database=test;";
	
	try
	{
	    cmd.CommandText = "SELECT city.name AS cityName, city.population AS CityPopulation, " +
	        "country.name, country.population, country.continent " +
	        "FROM country, city ORDER BY country.continent, country.name";
	    cmd.Connection = conn;
	
	    myAdapter.SelectCommand = cmd;
	    myAdapter.Fill(myData);
	
	    myReport.Load(@".\world_report.rpt");
	    myReport.SetDataSource(myData);
	    myViewer.ReportSource = myReport;
	}
	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
	    MessageBox.Show(ex.Message, "Report could not be created",
	        MessageBoxButtons.OK, MessageBoxIcon.Error);
	}

使用相同查询生成的一个新的数据集合用于生成事先保存的数据集合。一旦该数据集合被填充，一个报表文档会被用于加载该报表文件并把它绑定到该数据集合。该报表文档是作为crViewer的报表源进行传递的。

当一个报表使用Connector/ODBC从一个单表中被创建时，采取相同的方法。数据集合代替该表在该报表中使用，并且该报表被恰当地展示。

当一个报表从多表中使用Connector/ODBC被创建，一个与多表关联的数据集合必须在我们的应用程序中被创建。这使得在该报表数据源中的每张表被在该数据集合中的一个报表所替换。

我们使用在我们的MySqlCommand对象中由多个[SELECT](/docs/Chapter_13/13.2.9_SELECT_Syntax#13.2.9)语句提供的多表来填充一个数据集合。在Database menu's Show SQL Query选项中，这些[SELECT](/docs/Chapter_13/13.2.9_SELECT_Syntax#13.2.9)语句是基于展示在Crystal Reports报表中的SQL查询。假定有以下查询：

	SELECT `country`.`Name`, `country`.`Continent`, `country`.`Population`, `city`.`Name`, `city`.`Population`
	FROM `world`.`country` `country` LEFT OUTER JOIN `world`.`city` `city` ON `country`.`Code`=`city`.`CountryCode`
	ORDER BY `country`.`Continent`, `country`.`Name`, `city`.`Name`

这个查询被转换为两个[SELECT](/docs/Chapter_13/13.2.9_SELECT_Syntax#13.2.9)查询，并且用以下代码展示：

**Visual Basic示例**

	Imports CrystalDecisions.CrystalReports.Engine
	Imports System.Data
	Imports MySql.Data.MySqlClient
	
	Dim myReport As New ReportDocument
	Dim myData As New DataSet
	Dim conn As New MySqlConnection
	Dim cmd As New MySqlCommand
	Dim myAdapter As New MySqlDataAdapter
	
	conn.ConnectionString = "server=127.0.0.1;" _
	    & "uid=root;" _
	    & "pwd=12345;" _
	    & "database=world"
	
	Try
	    conn.Open()
	    cmd.CommandText = "SELECT name, population, countrycode FROM city ORDER BY countrycode, name; " _
	        & "SELECT name, population, code, continent FROM country ORDER BY continent, name"
	    cmd.Connection = conn
	
	    myAdapter.SelectCommand = cmd
	    myAdapter.Fill(myData)
	
	    myReport.Load(".\world_report.rpt")
	    myReport.Database.Tables(0).SetDataSource(myData.Tables(0))
	    myReport.Database.Tables(1).SetDataSource(myData.Tables(1))
	    myViewer.ReportSource = myReport
	Catch ex As Exception
	    MessageBox.Show(ex.Message, "Report could not be created", MessageBoxButtons.OK, MessageBoxIcon.Error)
	End Try

**C#示例**

	using CrystalDecisions.CrystalReports.Engine;
	using System.Data;
	using MySql.Data.MySqlClient;
	
	ReportDocument myReport = new ReportDocument();
	DataSet myData = new DataSet();
	MySql.Data.MySqlClient.MySqlConnection conn;
	MySql.Data.MySqlClient.MySqlCommand cmd;
	MySql.Data.MySqlClient.MySqlDataAdapter myAdapter;
	
	conn = new MySql.Data.MySqlClient.MySqlConnection();
	cmd = new MySql.Data.MySqlClient.MySqlCommand();
	myAdapter = new MySql.Data.MySqlClient.MySqlDataAdapter();
	
	conn.ConnectionString = "server=127.0.0.1;uid=root;" +
	    "pwd=12345;database=test;";
	
	try
	{
	    cmd.CommandText = "SELECT name, population, countrycode FROM city ORDER " +
	        "BY countrycode, name; SELECT name, population, code, continent FROM " +
	        "country ORDER BY continent, name";
	    cmd.Connection = conn;
	
	    myAdapter.SelectCommand = cmd;
	    myAdapter.Fill(myData);
	
	    myReport.Load(@".\world_report.rpt");
	    myReport.Database.Tables(0).SetDataSource(myData.Tables(0));
	    myReport.Database.Tables(1).SetDataSource(myData.Tables(1));
	    myViewer.ReportSource = myReport;
	}
	catch (MySql.Data.MySqlClient.MySqlException ex)
	{
	    MessageBox.Show(ex.Message, "Report could not be created",
	        MessageBoxButtons.OK, MessageBoxIcon.Error);
	}

将SELECT[SELECT](/docs/Chapter_13/13.2.9_SELECT_Syntax#13.2.9)查询进行字典排序很重要，因为这是报表所期望其源表的输入顺序。在该报表中的每张表都需要一个SetDataSource语句。

这个方法会引发性能问题，因为水晶报表必须在客户端把这些表绑定到一起，这会比使用一个事先保存的数据集合要慢。

[22.2.5.18]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.18
#### 22.2.5.18. ASP.NET提供者模型

MySQL Connector/Net提供了支持 ASP.NET 2.0提供器模型。这个模型使应用程序开发者能够集中到他们的应用程序的业务逻辑上，而不是必须为了成员资格和角色支持而再创建标准文本项目。

MySQL Connector/Net提供了以下的提供器：

+ 成员资格提供器
+ 角色提供器
+ Profile Provider
+ Session状态提供器 (MySQL Connector/Net 6.1和之后的版本)

以下的表展示了支持的提供器，有默认提供器和符合MySQL的提供器。

***Membership Provider***

<table border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Default Provider</th><th scope="col">MySQL Provider</th></tr></thead><tbody><tr><td scope="row">System.Web.Security.SqlMembershipProvider</td><td>MySql.Web.Security.MySQLMembershipProvider</td></tr></tbody></table>

***Role Provider***

<table border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Default Provider</th><th scope="col">MySQL Provider</th></tr></thead><tbody><tr><td scope="row">System.Web.Security.SqlRoleProvider</td><td>MySql.Web.Security.MySQLRoleProvider</td></tr></tbody></table>


***Profile Provider***

<table border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Default Provider</th><th scope="col">MySQL Provider</th></tr></thead><tbody><tr><td scope="row">System.Web.Profile.SqlProfileProvider</td><td>MySql.Web.Profile.MySQLProfileProvider</td></tr></tbody></table>

***SessionState Provider***

<table border="1"><colgroup><col><col></colgroup><thead><tr><th scope="col">Default Provider</th><th scope="col">MySQL Provider</th></tr></thead><tbody><tr><td scope="row">System.Web.SessionState.InProcSessionStateStore</td><td>MySql.Web.SessionState.MySqlSessionStateStore</td></tr></tbody></table>

> **注意**
> MySQL Session状态提供器在类名上与其它的MySQL提供器相比使用略有不同的capitalization。

***安装提供器***

Connector/Net 5.1或之后的版本的安装方式会在你的机器的.NET配置文件 _machine.config_ 中安装这些提供器并注册它们。额外的条目被创建会导致 _system.web_ 章节表现为类似下面的代码：

	<system.web>
	  <processModel autoConfig="true" />
	  <httpHandlers />
	  <membership>
	    <providers>
	      <add name="AspNetSqlMembershipProvider" type="System.Web.Security.SqlMembershipProvider, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" connectionStringName="LocalSqlServer" enablePasswordRetrieval="false" enablePasswordReset="true" requiresQuestionAndAnswer="true" applicationName="/" requiresUniqueEmail="false" passwordFormat="Hashed" maxInvalidPasswordAttempts="5" minRequiredPasswordLength="7" minRequiredNonalphanumericCharacters="1" passwordAttemptWindow="10" passwordStrengthRegularExpression="" />
	      <add name="MySQLMembershipProvider" type="MySql.Web.Security.MySQLMembershipProvider, MySql.Web, Version=6.1.1.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d" connectionStringName="LocalMySqlServer" enablePasswordRetrieval="false" enablePasswordReset="true" requiresQuestionAndAnswer="true" applicationName="/" requiresUniqueEmail="false" passwordFormat="Clear" maxInvalidPasswordAttempts="5" minRequiredPasswordLength="7" minRequiredNonalphanumericCharacters="1" passwordAttemptWindow="10" passwordStrengthRegularExpression="" />
	    </providers>
	  </membership>
	  <profile>
	    <providers>
	      <add name="AspNetSqlProfileProvider" connectionStringName="LocalSqlServer" applicationName="/" type="System.Web.Profile.SqlProfileProvider, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	      <add name="MySQLProfileProvider" type="MySql.Web.Profile.MySQLProfileProvider, MySql.Web, Version=6.1.1.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d" connectionStringName="LocalMySqlServer" applicationName="/" />
	    </providers>
	  </profile>
	  <roleManager>
	    <providers>
	      <add name="AspNetSqlRoleProvider" connectionStringName="LocalSqlServer" applicationName="/" type="System.Web.Security.SqlRoleProvider, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	      <add name="AspNetWindowsTokenRoleProvider" applicationName="/" type="System.Web.Security.WindowsTokenRoleProvider, System.Web, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
	      <add name="MySQLRoleProvider" type="MySql.Web.Security.MySQLRoleProvider, MySql.Web, Version=6.1.1.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d" connectionStringName="LocalMySqlServer" applicationName="/" />
	    </providers>
	  </roleManager>
	</system.web>

每种提供器类型可以有多种提供器的实现。默认提供器也可以在这使用 _defaultProvider_ 属性来设置，但是通常会手动地或用ASP.NET配置工具设置在 _web.config_ 文件中。

在编写时，MySqlSessionStateStore没有被添加到在安装中的machine.config，而是添加以下代码：

	<sessionState>
	  <providers>
	    <add name="MySqlSessionStateStore" type="MySql.Web.SessionState.MySqlSessionStateStore, MySql.Web, Version=6.1.1.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d" connectionStringName="LocalMySqlServer" applicationName="/" />
	  </providers>
	</sessionState>

会话状态提供器使用 _customProvider_ 属性，而不是 _defaultProvider_ 作为默认项来设置提供器。一个典型的 _web.config_ 文件可以包含：

	<system.web>
	        <membership defaultProvider="MySQLMembershipProvider" />
	        <roleManager defaultProvider="MySQLRoleProvider" />
	        <profile defaultProvider="MySQLProfileProvider" />
	        <sessionState customProvider="MySqlSessionStateStore" />
	        <compilation debug="false">
	          ...

这里设置MySQL提供器作为默认值在这个web应用程序中使用。

这些提供器在文件 _mysql.web.dll_ 中被实现，并且该文件可以在你的MySQL Connector/Net安装文件夹中找到。没有必要运行任何类型的SQL脚本来设置数据库schema，因为提供器会自动地创建并维护合适的schema。

***使用提供器***

启用这些提供器的最简单的方法是使用ASP.NET配置工具，当你有一个网站工程被加载的时候，它在资源管理器工具栏上是可用的。

在打开的网页中，你可以靠选择一个自定义提供器为每个区域选择MySQL成员资格和角色提供器。

当提供器被安装时，会创建一个名为 _LocalMySqlServer_ 假的连接字符串。虽然这是必须做的以便于提供器工作在ASP.NET配置工具上，但是你需要重载你的 _web.config_ 文件中的这个连接字符串。为此，首先要移除假的连接字符串，然后添加一个适合的连接字符串，如以下例子所示：

	<connectionStrings>
	  <remove name="LocalMySqlServer"/>
	  <add name="LocalMySqlServer" connectionString="server=xxx;uid=xxx;pwd=xxx;database=xxx;"/>
	</connectionStrings>

注意，用于连接的数据库必须被指定。

比起手动的编辑配置文件，可以考虑使用MySQL Website Configuration工具来配置你想要的提供器设置。从MySQL Connector/Net 6.1.1向前的版本开始，所有的提供器都可以从这个向导中选择和配置。该工具修改你的 _website.config_ 文件成为想要的配置。这样做的一个教程是在[章节 22.2.3.12, “MySQL Website Configuration Tool”](/docs/Chapter_22/22.02.03_ConnectorNet_Visual_Studio_Integration.md #22.2.3.12)中。

一个演示如何使用成员资格和角色提供器的教程可以在[章节 22.2.4.2, “Tutorial: MySQL Connector/Net ASP.NET Membership and Role Provider”](/docs/Chapter_22/22.02.04_ConnectorNet_Tutorials.md#22.2.4.2)中找到。

***展开***

为了在一个生产服务器上使用这些提供器，分配 _MySql.Data_ 和 _MySql.Web_ 集合，并且在远程系统Global Assembly Cache上注册它们或者在你的应用程序的 _bin/_ 目录下隐藏它们。

[22.2.5.19]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.19
#### 22.2.5.19. 使用部分托管/半托管工作

.NET应用程序运行在一个给定的托管级别。一般的桌面应用程序运行在全托管的状态下，而web应用程序寄宿在共享环境下运行在局部的托管等级（也叫做“半托管”）。某些宿主提供器在它们自己的应用线程池中主持共享环境，并且允许该应用程序运行在全托管下，但是这种配置相对的稀少。Connector/Net支持部分托管改善，随着时间的推移，为宿主提供器简化配置和部署进程。

##### 22.2.5.19.1. 部分托管支持的演变贯穿Connector/Net整个版本

部分托管支持Connector/Net通过6.5.x 和 6.6.x版本已经得到迅速地改善。最新的改进需要一些配置改变现有的部署。这是对每个版本的变化的概要。

**6.6.4 以及之上的版本: 库可以在GAC的里面或外面**

现在你可以依[Section 22.2.5.19.2, “Configuring Partial Trust with Connector/Net Library Installed in GAC”][22.2.5.19.2]中的说明，在Global Assembly Cache (GAC)中安装 _MySql.Data.dll_ 库，或者依[Section 22.2.5.19.3, “Configuring Partial Trust with Connector/Net Library Not Installed in GAC”][22.2.5.19.3]中的说明，在在工程或解决方案内部的一个 _bin_ 或 _lib_ 文件夹中安装。如果该库不在GAC中，则唯一支持的协议是TCP/IP。

**6.5.1 以及之上的版本: 部分托管要求库在GAC中**

当该库被安装在Global Assembly Cache (GAC)中时，Connector/Net 6.5充分地使我们的提供器能够运行在一个部分托管的环境中。新的 _MySqlClientPermission_ 类源于.NET的 _DBDataPermission_ 类，帮助简化许可设置。

**5.0.8/5.1.3 以及之上的版本: 部分托管要求套接字许可**

从这些版本开始，Connector/Net可以用在已经被修改成允许使用套接字进行通信的部分托管宿主下使用。默认的情况下，部分托管不包括 _SocketPermission_。
Connector/Net 使用套接字与MySQL服务器交谈，因此宿主提供器必须创建一个新的精确克隆部分托管的托管等级，但是有以下许可添加：

+ _System.Net.SocketPermission_

+ _System.Security.Permissions.ReflectionPermission_

+ _System.Net.DnsPermission_

+ _System.Security.Permissions.SecurityPermission_

**在5.0.8/5.1.3版本之前: 不支持部分托管**

在5.0.8和5.1.3版本之前，Connector/Net不兼容部分托管宿主

[22.2.5.19.2]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.19.2
##### 22.2.5.19.2. Configuring Partial Trust with Connector/Net Library Installed in GAC

如果该库在GAC中安装，你必须在你的连接字符串中包含连接选项 _includesecurityasserts=true_。这是Connector/Net 6.6.4的一个新的要求。

以下列表展示了步骤和代码片段需要在一个部分托管环境中运行一个Connector/Net应用程序。出于演示目的，我们在这个例子中使用管道连接协议：

1. 安装Connector/Net：版本6.6.1或更高版本，或者6.5.4或更高版本。
2. 在安装完库后，做以下配置的改变：

在 _SecurityClasses_ 部分，为 _MySqlClientPermission_ 类添加一个定义，包括使用的版本。

	<configuration>
	  <mscorlib>
	    <security>
	      <policy>
	        <PolicyLevel version="1">
	          <SecurityClasses>
	            ....
	            <SecurityClass Name="MySqlClientPermission" Description="MySql.Data.MySqlClient.MySqlClientPermission, MySql.Data, Version=6.6.4.0, Culture=neutral, PublicKeyToken=c5687fc88969c44d" />

下滚至 _ASP.Net_ 部分：

	<PermissionSet  class="NamedPermissionSet"  version="1"  Name="ASP.Net">

为 _MySqlClientPermission_ 类的详细配置添加一个新的条目：

	<IPermission class="MySqlClientPermission" version="1" Unrestricted="true"/>

注意：这个配置是最广义的方式,包括所有的关键词。

3.在命令行上追加 _--enable-named-pipe_ 选项来配置MySQL服务器使其接收管道连接。如果你需要更多关于这方面的信息，请参看[章节 2.3, “Installing MySQL on Microsoft Windows”]()。

4.确认宿主提供器已经在GAC中安装Connector/Net库(_MySql.Data.dll_)。

5.视需要，靠在托管策略中使用新的 _MySqlClientPermission_ 类，宿主提供器可以避免全局地授予许可。（替代方法是全局启用权限 _System.Net.SocketPermission, System.Security.Permissions.ReflectionPermission_ ，_System.Net.DnsPermission_ 和 _System.Security.Permissions.SecurityPermission_。）

6.使用Visual Studio 2010创建一个简单的web应用程序。

7.在你的应用程序中为 _MySql.Data.MySqlClient_ 库添加索引。

8.编辑你的 _web.config_ 文件，使你的应用程序使用一个半托管等级运行：

	<system.web>
	  <trust level="Medium"/>
	</system.web>

9.添加 _MySql.Data.MySqlClient_ 命名空间到你的服务器代码页面。

10.在依赖于Connector/Net版本而稍微不同的方法中，定义连接字符串。

***仅对版本6.6.4或之后：***为了使用连接内部的web应用程序，使其在办托管中运行，需要添加新的 _includesecurityasserts_ 选项到连接字符串中。_includesecurityasserts=true_ 使库请求以下许可，当需要的时候： _SocketPermissions, ReflectionPermissions_ ， _DnsPermissions_ ， _SecurityPermissions_ 之外的在半托管等级中没有被授权。

***对Connector/Net 6.6.3或之前：***在连接字符串中不需要特别的安全设定。

	MySqlConnectionStringBuilder myconnString = new MySqlConnectionStringBuilder("server=localhost;User Id=root;database=test;");
	myconnString.PipeName = "MySQL55";
	myconnString.ConnectionProtocol = MySqlConnectionProtocol.Pipe;
	// Following attribute is a new requirement when the library is in the GAC.
	// Could also be done by adding includesecurityasserts=true; to the string literal
	// in the constructor above.
	// Not needed with Connector/Net 6.6.3 and earlier.
	<B>myconnString.IncludeSecurityAsserts = true;</B>

11.定义 _MySqlConnection_ 使用：

	MySqlConnection myconn = new MySqlConnection(myconnString.ConnectionString);
	myconn.Open();

12.从你的表中检索某些数据：

	MySqlCommand cmd = new MySqlCommand("Select * from products", myconn);
	MySqlDataAdapter da = new MySqlDataAdapter(cmd);
	DataSet1 tds = new DataSet1();
	da.Fill(tds, tds.Tables[0].TableName);
	GridView1.DataSource = tds;
	GridView1.DataBind();
	myconn.Close()

13.运行该程序。没有要求任何特殊的代码或者遇到任何安全问题的情况下，应该会执行成功。

[22.2.5.19.3]: ./docs/Chapter_22/22.02.05_ConnectorNet_Programming.md#22.2.5.19.3
##### 22.2.5.19.3. 不在GAC上安装，而使用Connector/Net库来配置部分托管

当开发一个web应用程序到一个共享托管环境（这个环境被配置为在一个部分或者半托管等级下运行所有它们的.NET应用程序）的时候，你可能不可以在GAC中安装Connector/Net。反之，你可以设置一个索引到在 _bin_ 或 _lib_ 文件夹中的内部的工程或解决方案的库。在这种情况下，比起库在GAC中，你使用一个不同的方法配置安全性。

Connector/Net通常被运行在默认的交互协议是套接字或TCP/IP的Windows环境中的应用程序所使用。对于这个协议的操作需要在web配置文件中有请求套接字许可的存在，如下：

1.打开半托管策略web配置文件，该文件应该在以下文件夹：

	%windir%\Microsoft.NET\Framework\{version}\CONFIG\web_mediumtrust.config

如果你使用了一个64位安装框架的话，请在路径中使用 _Framework64_ 代替 _Framework_。

2.位于 _SecurityClasses_ 的标签：

	<SecurityClass Name="SocketPermission" 
	Description="System.Net.SocketPermission, System, Version=4.0.0.0, 
	Culture=neutral, PublicKeyToken=b77a5c561934e089"/>

3.向下滚动并查看以下 _PermissionSet_：

	<PermissionSet version="1" Name="ASP.Net">

4.在 _PermissionSet_ 内部添加以下部分：

	<IPermission class="SocketPermission" version="1" Unrestricted="true" />  

这个配置使你没有任何安全问题的用默认的Windows的TCP/IP协议来使用驱动。这种方法仅仅支持TCP/IP协议，因此你不能使用任何其它类型的连接。

而且，如果 _MySQLClientPermissions_ 类不添加到半托管策略中，你就不能使用它。为了用Connector/Net工作而不用GAC，这个配置是最低需求。