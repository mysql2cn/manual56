## 22.8.7. C API函数描述 **NULL** 
在本节中，参数或者返回值为 **NULL** ，是指其意义为C语言中的 **NULL** ，而不是MySQL中的 **NULL** 值。

有返回值的函数通常是返回一个指针类型值或者整型值。除非特别说明，返回值为指针类型的的函数如果返回了非 **NULL** 值则表示调用成功，返回 **NULL** 值表示失败，返回值为整型的函数返回0表示成功，返回非0表示失败。注意所谓非0就是指除0外的所有值，所以除非特别说明，不要以非0值来检查返回值。

```c
if (result)                   /* correct */
    ... error ...

if (result < 0)               /* incorrect */
    ... error ...

if (result == -1)             /* incorrect */
    ... error ...
```

当一个函数返回返回了错误，函数描述的 **错误** 子节会列出可能的错误类型。通过调用 *mysql_errno()* 来确定是哪一种错误。也可以调用 *mysql_error()* 来获取字符串形式的错误信息。

**22.8.7.1.**  *mysql_affected_rows()*

> *my_ulonglong mysql_affected_rows(MYSQL *mysql)*

**描述**

> *mysql_affected_rows()* 可以在调用 *mysql_query()* 或者 *mysql_real_query()* 执行一个语句之后立即被调用。如果上一个语句是 **UPDATE** ， **DELETE** 或者 **INSERT** ,该调用会返回相应的被修改，删除或者插入的行数。对于 **SELECT** 语句，该调用的作用跟 *mysql_num_rows()* 一样。
 
> 对于 **UPDATE** 语句，被影响行数默认是指事实被修改的行数。使用 *mysql_real_connect()* 调用连接 *mysqld* 时，如果设置了 **CLIENT_FOUND_ROWS** 标记，则被影响行数则是指被“发现”的行数，也就是匹配 **WHERE** 从句的行数。
 
> 对于 **REPLACE** 语句，如果是一条新行替换了一条旧行，则受影响行数为2，因为在此情况下是先删除旧行再插入新行。
 
> 对于 **INSERT ... ON DUPLICATE KEY UPDATE** 语句，如果是插入了新行则受影响行数1，如果是更新已有行则受影响行数是2，如果对某行更新的目标值和当前值一样则受影响行数是0，但是如果此时设置了 **CLIENT_FOUND_ROWS** 标记，那么受影响行数就为1了。
 
> 在使用 **CALLL** 语句调用了一个存储过程之后，该函数的返回值表示的是存储过程中最后一条语句的影响行数，要是那条语句执行失败则其值为0。在存储过程内部，你可以调用SQL层面的 **ROW_COUNT()** 来获取每一单条语句的影响行数。
 
> 在MySQL 5.6中，该函数可以为更广泛的语句返回有意义的值。详细请参考 [12.14，信息函数]() 中对 **ROW_COUNT()** 的描述。
 
**返回值**

>大于0的整数表示受影响或者返回的行数。0表示没有记录被修改，或者 **WHERE** 未被匹配，或者根本没有执行任何查询。-1表示该函数出错了，或者是因为对于 **SELECT** 语句，在调用 *mysql_store_result()* 之前调用了 *mysql_affected_rows()* 。

> 因为 *mysql_affected_rows()* 返回值是无符号整数，通过将返回值与 *(my_ulonglong)-1* 或者 *(my_ulonglong)~0* 比较来确定是否返回了-1。

**错误**

>无。

**范例**
```c
char *stmt = "UPDATE products SET cost=cost*1.25
              WHERE group=10";
mysql_query(&mysql,stmt);
printf("%ld products updated",
       (long) mysql_affected_rows(&mysql));
```

**22.8.7.2.**  *mysql_autocommit()*

> *my_bool mysql_autocommit(MYSQL *mysql, my_bool mode)*

**描述**

> 如果mode参数是1则打开autocommit模式，如果mode参数是0则关闭该模式。

**返回值**

> 成功则返回0，发生错误时返回非0。

**错误**

> 无。

**22.8.7.3.**  *mysql_change_user()*

> *my_bool mysql_change_user(MYSQL *mysql, const char *user, const char, *password, const char *db)*

**描述**

> 改变 *mysql* 所表示连接上的用户，以及默认数据库。在后续的查询中，如果对表的引用没有指定数据库，则默认为 *db* 参数所指定的数据库。

> 如果当前连接用户无法认证或者没有访问 *db* 指定数据库的权限， *mysql_change_user()* 将会失败。在此情况下，当前连接上的用户和默认数据库都不会改变。

> 这个命令会重置状态，效果跟全新的连接一样。（参考 [22.8.16，控制自动重连行为]() ）它会回滚连接上所有的活跃事物，关闭以及丢弃所有的临时表，解锁所有被锁住的表。该会话系统变量全部被重置为相应的全局系统变量。预处理语句会被释放， **HANDLER** 变量会被关闭。以 **GET_LOCK()** 获取的锁也会被释放。哪怕用户没有更改，也会产生这些效果。

**返回值**

> 成功则返回0，发生错误时返回非0。

**错误**
> 错误信息跟 *mysql_real_connect()* 一样。

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。
	
> * ER_UNKNOWN_COM_ERROR

> 	MySQL未实现该命令（可能因为版本较老）。
	
> * ER_ACCESS_DENIED_ERROR

> 	用户名或者密码错误。
	
> * ER_BAD_DB_ERROR
	
> 	数据库不存在。
	
> * ER_DBACCESS_DENIED_ERROR
	
> 	无访问该数据库的权限。
	
> * ER_WRONG_DB_NAME

> 	数据库名过长。
	
**范例**

```c
if (mysql_change_user(&mysql, "user", "password", "new_database"))
{
   fprintf(stderr, "Failed to change user.  Error: %s\n",
           mysql_error(&mysql));
}
```

**22.8.7.4.**  *mysql_character_set_name()*

> *const char *mysql_character_set_name(MYSQL *mysql)*

**描述**
> 返回当前连接上的默认字符集。

**返回值**

> 默认字符集名称。

**错误**

> 无。

**22.8.7.5.**  *mysql_close()*

> *void mysql_close(MYSQL *mysql)*

**描述**

> 关闭连接。如果 *mysql* 指向的句柄是通过 *mysql_init()* 或者 *mysql_connect()* 自动分配的， *mysql_close()* 会释放掉该连接句柄。

**返回值**

> 无。

**错误**

> 无。

**22.8.7.6.**  *mysql_commit()*

> *my_bool mysql_commit(MYSQL *mysql)*

**描述**

> 提交当前事物。

> 这个函数的行为跟 *completion_type* 系统变量有关。尤其当该变量为 **RELEASE** （或者2）的时候，服务端在终止事物之后会执行释放并且关闭客户端连接。在客户端调用 *mysql_close()* 来从客户端关闭连接。

**22.8.7.7.**  *mysql_connect()*

> *MYSQL *mysql_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd)*

**描述**

> 该函数已被废弃。使用 *mysql_real_connect()* 代替。

> 该函数会尝试建立一条连接，目标为 *host* 指定的主机上运行的的数据库引擎。在调用除了 *mysql_get_client_info()* 之外的所有API函数之前，必须确保先调用了该函数并且执行成功了。

> 各参数的意义跟 *mysql_real_connect()* 相同，除了connection可以为 **NULL** 。在此情况下，C API会为该结构自动分配内存，同时在 *mysql_close()* 被调用的时候将其释放。这一方式的一个缺点是如果连接失败，你无法获得错误信息。（因为如果要通过 *mysql_errno()* 或者 *mysql_error()* 来获取错误信息，必须提供一个有效的 **MYSQL** 指针。）

**返回值**

> 跟 *mysql_real_connect()* 一样

**错误**

> 跟 *mysql_real_connect()* 一样

**22.8.7.8.**  *mysql_create_db()*

> *int mysql_create_db(MYSQL *mysql, const char *db)*

**描述**

> 创建一个以 *db* 命名的数据库。

> 该函数已废弃。推荐使用调用 *mysql_query()* 执行 **CREATE DATABASE** 语句的方式。

**返回值**

> 当数据库创建成功时返回0。否则返回非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。


**范例**

```c
if(mysql_create_db(&mysql, "my_database"))
{
   fprintf(stderr, "Failed to create new database.  Error: %s\n",
           mysql_error(&mysql));
}
```

**22.8.7.9.**  *mysql_data_seek()*

> *void mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)*

**描述**

> 定位到查询结果集的任意行。 *offset* 参数表示行号。该值的范围应该介于0和 *mysql_num_rows(result)-1* 之间。

> 该函数要求结果集包含了整个查询结果，因此该函数只能与 *mysql_store_result()* 配合使用，不能跟 *mysql_use_result()* 配合使用。

**返回值**

> 无。

**错误**

> 无。

**22.8.7.10.**  *mysql_debug()*

> *void mysql_debug(const char *debug)*

**描述**

> 以给定字符串执行 **DBUG_PUSH** 。该函数使用了Fred Fish库。要使用这个函数，必须对客户端库正确编译以支持调试功能。参考 [23.4.3，调试包]() 。

**返回值**

> 无。

**错误**

> 无。

**范例**

> 以下示例会让客户端库在客户端机器上生成一个名为 */tmp/client.trace* 的trace文件。

```c
mysql_debug("d:t:O,/tmp/client.trace");
```

**22.8.7.11.**  *mysql_drop_db()*

> *int mysql_drop_db(MYSQL *mysql, const char *db)*

**描述**

> 删除以 *db* 命名的数据库。

> 该函数已废弃。推荐使用调用 *mysql_query()* 执行 **DROP DATABASE** 语句的方式。

**返回值**

> 当数据库删除成功时返回0。否则返回非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**范例**

```c
if(mysql_drop_db(&mysql, "my_database"))
  fprintf(stderr, "Failed to drop the database: Error: %s\n",
          mysql_error(&mysql));
```

**22.8.7.12.**  *mysql_dump_debug_info()*

> *int mysql_dump_debug_info(MYSQL *mysql)*

**描述**

> 指示服务端将调试信息写入错误日志。连接上的用户必须具有 **SUPER** 权限。

**返回值**

> 命令执行成功时返回0。否则非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.13.**  *mysql_eof()*

> *my_bool mysql_eof(MYSQL_RES *result)*

**描述**

> 该函数已废弃。使用 *mysql_errno()* 或者 *mysql_error()* 来代替。

> 该函数用来检查是否读到了结果集的最后一行。

> 当 *mysql_store_result()* 调用成功时，客户端一次性读取了整个结果集。 在此情况下， *mysql_fetch_row()* 返回 **NULL** 则说明结果集已经读取完毕，因此也就无需调用 *mysql_eof()*。当跟 *mysql_store_result()* 配合使用时， *mysql_eof()* 总是返回 true。

> 但是如果你调用了 *mysql_use_result()* 初始化结果集读取时，各行是通过重复调用  *mysql_fetch_row()* 一行一行地从服务端读取回来的。因为这个过程中数据库连接上可能会发生错误，所以 *mysql_fetch_row()* 调用返回 **NULL** 并不意味着到达了结果集尾部。此时你可以使用 *mysql_eof()* 来确定到底发生了什么，如果返回非0说明确实到达了结果集尾部，返回0说明有错误发送。

> 历史上，  *mysql_eof()* 比标准MySQL错误函数 *mysql_errno()* 和 *mysql_error()* 出现的早。因为错误函数提供了同样的信息，相比 *mysql_eof()* 更推荐使用错误函数，而 *mysql_eof()* 已被废弃。（事实上，错误函数提供了更多的信息，因为  *mysql_eof()* 仅仅返回一个boolean值，而错误函数则在错误发生时还会提供错误发生的原因。）

**返回值**

> 无错误发生时返回0。如果到达了结果集尾部则返回非0。

**错误**

> 无。

**范例**

> 以下范例演示了如何使用 *mysql_eof()* ：

```c
mysql_query(&mysql,"SELECT * FROM some_table");
result = mysql_use_result(&mysql);
while((row = mysql_fetch_row(result)))
{
    // do something with data
}
if(!mysql_eof(result))  // mysql_fetch_row() failed due to an error
{
    fprintf(stderr, "Error: %s\n", mysql_error(&mysql));
}
```

> 使用MySQL标准错误函数可以达到同样的效果：

```c
mysql_query(&mysql,"SELECT * FROM some_table");
result = mysql_use_result(&mysql);
while((row = mysql_fetch_row(result)))
{
    // do something with data
}
if(mysql_errno(&mysql))  // mysql_fetch_row() failed due to an error
{
    fprintf(stderr, "Error: %s\n", mysql_error(&mysql));
}
```

**22.8.7.14.**  *mysql_errno()*

> *unsigned int mysql_errno(MYSQL *mysql)*

**描述**

> 返回 *mysql* 所指定的连接上最后一次API调用的错误码，无论成功还是失败。如果没有错误发生，则返回0。客户端错误码定义在 *errmsg.h* 头文件中。服务端错误码定义在 *mysqld_error.h* 头文件中。 [附录C，错误，错误码以及一般性问题]() 列出了这些信息。

> 要注意有些函数比如 *mysql_fetch_row()* 在执行成功时不会设置 *mysql_errno()* 的返回值。

> 规律是所有必须查询服务端以获取信息的函数在成功的时候都会重置 *mysql_errno()* 的返回值。

>  *mysql_errno()* 返回的MySQL相关错误码跟 *mysql_sqlstate()* 返回的SQLSTATE值不是一回事。下面的例子说明了客户端展示错误信息的格式，1146是 *mysql_errno()* 的返回值而 **42S02** 则是相应的  *mysql_sqlstate()* 返回值：

```sql
shell> SELECT * FROM no_such_table;
ERROR 1146 (42S02): Table 'test.no_such_table' doesn't exist
```

**返回值**

> 上一次API调用如果失败，返回错误码。无错误发生时返回0。

**错误**

> 无。

**22.8.7.15.**  *mysql_error()*

> *const char *mysql_error(MYSQL *mysql)*

**描述**

> 返回 *mysql* 所指定的连接上最后一次失败的API调用的错误信息，错误信息的形式是null结尾字符串。如果函数调用并没有失败，返回值或者为之前的调用的错误信息，或者为空字符串（说明没有错误发生）。

> 对于所有必须查询服务端以获取信息的调用，如果调用成功， *mysq_error()* 的返回值都会被重置。

> 对于这种调用，可以使用以下两种方式来检查错误：

```c
if(*mysql_error(&mysql))
{
  // an error occurred
}
if(mysql_error(&mysql)[0])
{
  // an error occurred
}
```

> 客户端错误信息的语种可以通过重新编译客户端库的方式改变。目前有若干种语言供选择。参考 [10.2，设置错误信息语种]()。

**返回值**

> 描述错误的null结尾字符串。如果没有错误发生则返回空串。

**错误**

> 无。

**22.8.7.16.**  *mysql_escape_string()*

> 使用 *mysql_real_escape_string()* 代替！

> 该函数功能跟 *mysql_real_escape_string()* 一样，除了后者会接收连接句柄作为第一个参数，并且依据其包含的当前字符集来进行转义。而 *mysql_escape_string()* 并不接收这样的一个参数，从而也不会参考当前字符集。

**22.8.7.17.**  *mysql_fetch_field()*

> *MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result)*

**描述**

> 以 **MYSQL_FIELD** 结构的形式返回结果集某一字段的定义。重复调用该函数以获取结果集中所有列的信息。当所有列信息都获取完了的时候返回 **NULL** 。

> 每当你重新执行一句 **SELECT** 查询，该函数返回值都会被重置到结果集第一列。该函数的返回值还会受 *mysql_field_seek()* 调用的影响。

> 假设你调用了 *mysql_query()* 执行了一次 **SELECT** 查询但是还没有调用 *mysql_store_result()*，此时你如果调用 *mysql_fetch_field()* 来获取某一 **BLOB** 字段的长度，则返回值将会是该类型字段的默认长度（8KB）。（之所以是8KB是因为MySQL并不知道结果集中该类型字段的真实最大长度。这个数字将来会变成可配置的。）一旦你读取了结果集，*field->max_length* 就会包含该查询中这一列的最大长度。

**返回值**

> 对于当前列，返回对应的 **MYSQL_FIELD** 结构体。如果所有列都已读完，则返回 **NULL** 。

**错误**

> 无。

**范例**

```c
MYSQL_FIELD *field;
while((field = mysql_fetch_field(result)))
{
    printf("field name %s\n", field->name);
}
```

**22.8.7.18.**  *mysql_fetch_field_direct()*

> *MYSQL_FIELD *mysql_fetch_field_direct(MYSQL_RES *result, unsigned int fieldnr)*

**描述**

> 以 *MYSQL_FIELD* 结构体的形式返回结果集中列编号 *fieldnr* 指定的列的信息。可以使用该函数来获取任意列的信息。 *fieldnr* 应该介于0与 *mysql_num_fields(result)-1* 之间。

**返回值**

> 包含指定列信息的 *MYSQL_FIELD* 结构。

**错误**

> 无。

**范例**

```c
unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *field;
num_fields = mysql_num_fields(result);
for(i = 0; i < num_fields; i++)
{
    field = mysql_fetch_field_direct(result, i);
    printf("Field %u is %s\n", i, field->name);
}
```

**22.8.7.19.**  *mysql_fetch_fields()*

> *MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result)*

**描述**

> 返回一个 **MYSQL_FIELD** 结构的列表。每个成员提供结果集中一列的定义。

**返回**

> 一个 **MYSQL_FIELD** 结构的一个列表，包含了结果集中所有列的信息。

**返回值**

> 无。

**返回值**

```c
unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *fields;
num_fields = mysql_num_fields(result);
fields = mysql_fetch_fields(result);
for(i = 0; i < num_fields; i++)
{
   printf("Field %u is %s\n", i, fields[i].name);
}
```

**22.8.7.20.**  *mysql_fetch_lengths()*

> *unsigned long *mysql_fetch_lengths(MYSQL_RES *result)*

**描述**

> 返回结果集中当前行各列的长度。如果你要拷贝各列的内容，这些信息可以拿来优化代码，因为这时你可以无需调用 *strlen()* 。另外，如果结果集包含了二进制数据，你只能使用这一方法来确定数据的大小，因为对于任何包含了'\0'的字段，*strlen()* 都会返回错误的结果。

> 对于空字段或者值为 **NULL** 的字段，其长度为0。关于如何区分这两种情况，参考 *mysql_fetch_row()* 的描述。

**返回值**

> 无符号整数的数组，每个值代表一个列的大小（不包含结尾'\0'）。当出错时则返回 **NULL** 。

**错误**

> *mysql_fetch_lengths()* 只对结果集的当前行有意义。在调用 *mysql_fetch_row()* 之前或者读完了结果集的所有行之后，该调用都将返回 **NULL** 。

**范例**

```c
MYSQL_ROW row;
unsigned long *lengths;
unsigned int num_fields;
unsigned int i;
row = mysql_fetch_row(result);
if (row)
{
    num_fields = mysql_num_fields(result);
    lengths = mysql_fetch_lengths(result);
    for(i = 0; i < num_fields; i++)
    {
		printf("Column %u is %lu bytes in length.\n",
		       i, lengths[i]);
	} 
}
```

**22.8.7.21.**  *mysql_fetch_row()*

> *MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)*

**描述**

> 读取结果集中的下一行。当与 *mysql_store_result()* 配合使用时，如果没有更多的行可供读取则返回 **NULL**。当与 *mysql_use_result()* 配合使用时，如果没有更多的行可供读取或者发生错误时返回 **NULL**。

> 结果集中的一行有多少列可以调用 *mysql_num_fields(result)* 获得。如果 *row* 存放了 *mysql_fetch_row()* 调用的返回值，各列值的指针可以从 *row[0]* 到 *row[mysql_num_fields(result)-1]* 的方式获得。 **NULL** 值以 **NULL** 指针表示。

> 各列的长度可以调用 *mysql_fetch_lengths()* 获得。空字段或者值为 **NULL** 的长度均为0；可以通过检查列值的指针来区分这两者。如果指针为 **NULL** ，则字段值为 **NULL** ；否则，仅字段为空而已。

**返回值**

> 代表下一行的 *MYSQL_ROW* 结构。如果所有行都已读取完毕或者有错误发生时返回 **NULL** 。

**错误**

> 注意在 *mysql_fetch_row()* 各次调用之间错误信息不会被重置。

> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**范例**

```c
MYSQL_ROW row;
unsigned int num_fields;
unsigned int i;
num_fields = mysql_num_fields(result);
while ((row = mysql_fetch_row(result)))
{
   unsigned long *lengths;
   lengths = mysql_fetch_lengths(result);
   for(i = 0; i < num_fields; i++)
   {
       printf("[%.*s] ", (int) lengths[i],
              row[i] ? row[i] : "NULL");
}
   printf("\n");
}
```

**22.8.7.22.**  *mysql_field_count()*

> *unsigned int mysql_field_count(MYSQL *mysql)*

**描述**

> 返回连接上最近一次查询的列数。

> 该函数的使用场景是调用 *mysql_store_result()* 时返回 **NULL** （此时你没有结果集指针）。这个时候，你可以调用 *mysql_field_count()* 来弄清 *mysql_store_result()* 是否应该返回非空结果集。从而使得客户端无需知道查询是否属于 **SELECT** 类型，也能采取合适的后续动作。下面的例子会说明如何做。

> 参考 [22.8.15，为什么有时候在 *mysql_query()* 成功之后调用 *mysql_store_result()* 也会返回 **NULL** ]() 。

**返回值**

> 表示结果集中列数量的的无符号整数。

**错误**

> 无。

**范例**

```c
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;
if (mysql_query(&mysql,query_string))
{
	// error 
}
else // query succeeded, process any data returned by it
{
    result = mysql_store_result(&mysql);
    if (result)  // there are rows
    {
        num_fields = mysql_num_fields(result);
        // retrieve rows, then call mysql_free_result(result)
    }
    else  // mysql_store_result() returned nothing; should it have?
    {
		if(mysql_field_count(&mysql) == 0)
		{
		    // query does not return data
		    // (it was not a SELECT)
		    num_rows = mysql_affected_rows(&mysql);
		}
		else // mysql_store_result() should have returned data
		{
		    fprintf(stderr, "Error: %s\n", mysql_error(&mysql));
		}
	} 
}
```

> 另一种方法是以 *mysql_errno(&mysql)* 替换 *mysql_field_count(&mysql)* 。这样你就可以直接检查 *mysql_store_result()* 调用是否出错而不需要引用 *mysql_field_count()* 来确定查询语句是否是 **SELECT** 类型。

**22.8.7.23.**  *mysql_field_seek()*

> *MYSQL_FIELD_OFFSET mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET offset)*

**描述**

> 移动列游标到指定偏移处。下一次 *mysql_fetch_field()* 调用就将返回该偏移对应的列定义信息。

> 要移动到行首，给 *offset* 参数传入0。

**返回值**

> 之前的列游标偏移值。

**错误**

> 无。

**22.8.7.24.**  *mysql_field_tell()*

> *MYSQL_FIELD_OFFSET mysql_field_tell(MYSQL_RES *result)*

**描述**

> 返回上一次 *mysql_fetch_field()* 所使用的列游标的位置。该值可以作为参数传递给 *mysql_field_seek()* 。

**返回值**

> 列游标的当前偏移。

**错误**

> 无。

**22.8.7.25.**  *mysql_free_result()*

> *void mysql_free_result(MYSQL_RES *result)*

**描述**

>释放为结果集分配的内存，结果集可能来自 *mysql_store_result()* ， *mysql_use_result()*， *mysql_list_dbs()* 等调用。当对一个结果集已经使用完毕了，必须调用 *mysql_free_result()* 以释放它所占用的内存。

> 在释放掉结果集之后就不要尝试访问它了。

**返回值**

> 无。

**错误**

> 无。

**22.8.7.26.**  *mysql_get_character_set_info()*

> *void mysql_get_character_set_info(MYSQL *mysql, MY_CHARSET_INFO *cs)*

**描述**

> 该函数提供关于客户端默认字符集的信息。默认字符集可以通过 *mysql_set_character_set()* 修改。

**范例**

> 下例展示了 **MY_CHARSET_INFO** 结构中所有可用成员。

```c
if (!mysql_set_character_set(&mysql, "utf8"))
{
    MY_CHARSET_INFO cs;
    mysql_get_character_set_info(&mysql, &cs);
    printf("character set information:\n");
    printf("character set+collation number: %d\n", cs.number);
    printf("character set name: %s\n", cs.name);
    printf("collation name: %s\n", cs.csname);
    printf("comment: %s\n", cs.comment);
    printf("directory: %s\n", cs.dir);
    printf("multi byte character min. length: %d\n", cs.mbminlen);
    printf("multi byte character max. length: %d\n", cs.mbmaxlen);
}
```

**22.8.7.27.**  *mysql_get_client_info()*

> *const char *mysql_get_client_info(void)*

**描述**

> 返回一个字符串，以说明客户端库的版本。

**返回值**

> 表示MySQL客户端库版本的字符串。

**错误**

> 无。

**22.8.7.28.**  *mysql_get_client_version()*

> *unsigned long mysql_get_client_version(void)*

**描述**

> 返回一个表示客户端库版本的整数。返回值的格式时 **XYYZZ** ，X表示大版本，YY表示版本级别，ZZ表示版本级别内的版本号。例如，40102表示客户端版本时4.1.2。

**返回值**

> 一个表示客户端版本的整数。

**错误**

> 无。

**22.8.7.29.**  *mysql_get_host_info()*

> *const char *mysql_get_host_info(MYSQL *mysql)*

**描述**

> 返回一个字符串以描述当前连接的类型，包括服务器主机名。

**返回值**

> 包含服务器主机名和连接类型的字符串。

**错误**

> 无。

**22.8.7.30.**  *mysql_get_proto_info()*

> *unsigned int mysql_get_proto_info(MYSQL *mysql)*

**描述**

> 返回当前连接所使用的协议版本。

**返回值**

> 一个无符号整数，表示当前连接所使用的协议版本。

**错误**

> 无。

**22.8.7.31.**  *mysql_get_server_info()*

> *const char *mysql_get_server_info(MYSQL *mysql)*

**描述**

> 返回一个字符串，说明服务端的版本号。

**返回值**

> 代表服务端版本号的字符串。

**错误**

> 无。

**22.8.7.32.**  *mysql_get_server_version()*

> *unsigned long mysql_get_server_version(MYSQL *mysql)*

**描述**

> 以整数形式返回服务端版本号。

**返回值**

> 一个以如下格式表示MySQL服务端版本的整数：

```c
 major_version*10000 + minor_version *100 + sub_version
```

> 例如，版本5.1.5就会表示为50105。

> 对客户端程序来说，这个函数对于确定某一特定版本相关的功能是否存在很有用处。

**错误**

> 无。

**22.8.7.33.**  *mysql_get_ssl_cipher()*

> *const char *mysql_get_ssl_cipher(MYSQL *mysql)*

**描述**

> 该函数返回到服务端的指定连接所使用的SSL加密方法。 *mysql* 代表连接句柄，由 *mysql_init()* 返回。

**返回值**

> 一个表示数据库连接所使用的SSL加密方法的字符串，如果没有加密则返回 **NULL** 。

**22.8.7.34.**  *mysql_hex_string()*

> *unsigned long mysql_hex_string(char *to, const char *from, unsigned long length)*

**描述**

> 该函数用来创建合法SQL字符串，以便能用在SQL语句之中。参考 [9.1.1，字符串文本]() 。

> *from* 所代表的字符串会被转换成16进制格式，每个字符被编码成2个16进制数字。结果末尾添加一个'\0'字节，存于 *to* 。

> *from* 指向的字符串必须为 *length* 字节长。为 *to* 分配的内存至少应该有 _2*length+1_ 字节。当调用返回时， *to* 变量的内容为以null结尾字符串。返回值为编码结果的长度，不包括结尾'\0'在内。

> 返回值可以以 *0xvalue* 或者 *X'value'* 的格式置入SQL语句。但是因为返回值并不包含 *0x* 或者 *X'...'* 。调用者必须自己添加。

**范例**

```c
char query[1000],*end;
end = strmov(query,"INSERT INTO test_table values(");
end = strmov(end,"0x");
end += mysql_hex_string(end,"What is this",12);
end = strmov(end,",0x");
end += mysql_hex_string(end,"binary data: \0\r\n",16);
*end++ = ')';
if (mysql_real_query(&mysql,query,(unsigned int) (end - query)))
{
   fprintf(stderr, "Failed to insert row, Error: %s\n",
           mysql_error(&mysql));
}
```

> 该例中使用的 *strmov* 函数包含于 *libmysqlclient* 库中，功能类似于 *strcpy()* ，只是返回值指向第一个参数的结尾字符'\0'处。

**返回值**

> 放入 *to* 处的字符串的长度，不包括结尾'\0'。

**错误**

> 无。

**22.8.7.35.**  *mysql_info()*

> *const char *mysql_info(MYSQL *mysql)*

**描述**

> 返回一个字符串，提供最近被执行的语句的信息，这些语句必须包含在以下列表中，对于不在该列表中的语句，该调用返回 **NULL** 。如下所述，语句类型不同，返回字符串的格式也不同。其中的数字只是用来做说明而已，具体的值依具体的语句而定。

> * [__INSERT INTO ... SELECT ...__]()
	
>	字符串格式： *Records: 100 Duplicates: 0 Warnings: 0*

> * [__INSERT INTO ... VALUES (...),(...),(...)...__]()

> 	字符串格式： *Records: 3 Duplicates: 0 Warnings: 0*

> * [__LOAD DATA INFILE ...__]()

> 	字符串格式： *Records: 1 Deleted: 0 Skipped: 0 Warnings: 0*

> * [__ALTER TABLE__]()

>	字符串格式： *Records: 3 Duplicates: 0 Warnings: 0*

> * [__UPDATE__]()

>	字符串格式： *Rows matched: 40 Changed: 40 Warnings: 0*

> 要注意的时，对于 **INSERT ... VALUES** 语句， *mysql_info()* 只为其多行形式返回非 **NULL** 值（语句中列出了多个行）。

**返回值**

> 一个字符串，包含了关于最近执行语句的一些信息。如果对于该语句无相关信息则返回 **NULL** 。

**错误**

> 无。

**22.8.7.36.**  *mysql_init()*

> *MYSQL *mysql_init(MYSQL *mysql)*

**描述**

> 分配或者初始化一个用于 *mysql_real_connect()* 的 **MYSQL** 对象。如果 *mysql* 参数为 **NULL** 指针，该函数会分配并初始化一个新对象返回。否则会初始化传入的对象并返回对象的地址。如果 *mysql_init()* 分配了新对象，该对象将会在调用 *mysql_close()* 以关闭连接的时候被释放。

**返回值**

> 一个初始化了的 _MYSQL*_句柄。当内存不够，无法分配新对象时返回 **NULL** 。

**错误**

> 内存不够时返回 **NULL** 。

**22.8.7.28.**  *mysql_insert_id()*

> *my_ulonglong mysql_insert_id(MYSQL *mysql)*

**描述**

> 返回上一条 **INSERT** 或者 **UPDATE** 语句为 **AUTO_INCREMENT** 列所生成的值。在执行 **INSERT** 语句往有字段被定义为 **AUTO_INCREMENT** 的表插入数据之后或者使用了包含 **LAST_INSERT_ID(expr)** 的 **INSERT** 或者 **UPDATE** 语句之后再使用该函数。

> 除非在以下几种情况下被显式更新，否则 *mysql_insert_id()* 都会返回0：

> * 往 **AUTO_INCREMENT** 字段写了值的 **INSERT** 语句。无论这个值是因为插入 **0** 或者 **NULL** 而自动生成的还是显式指定的都是如此。

> * 如果是多行 **INSERT** 语句， *mysql_insert_id()* 将会返回被成功插入的第一个 **AUTO_INCREMENT** 值。

>	如果没有记录插入成功，则返回0。

> * 如果执行了 **INSERT ... SELECT** 语句，而且没有自动生成值被插入，该函数返回最后一个被插入行的ID。

> * 如果 **INSERT ... SELECT** 语句使用了 **LAST_INSERT_ID(expr)** ，该函数的返回值为*expr* 。

> * 通过向任一列插入或者将其更新为 **LAST_INSERT_ID(expr)** 而生成了 **AUTO_INCREMENT** 值的 **INSERT** 语句。

> * 如果之前的语句返回了错误， *mysql_insert_id()* 的返回值时未定义的。

> 关于 *mysql_insert_id()* 的返回值可以归纳为以下几点：
 
> 2.  如果存在一个 **AUTO_INCREMENT** 列，并且自动生成的值也插入成功了，返回第一个这样的值。

> 4. 如果语句中包含 **LAST_INSERT_ID(expr)** ，则返回 *expr* ，哪怕在受影响表中有 **AUTO_INCREMENT** 列。

> 1. 返回值因语句的不同而不同。

>		* 当在 **INSERT** 语句之后调用，如果表中有一个 **AUTO_INCREMENT** 列，并且向这一列成功插入了一些显式指定的值，则返回最后一个显式值。
		
>		* 当在 **INSERT ... ON DUPLICATE KEY UPDATE** 之后调用，如果表中有一个 **AUTO_INCREMENT** 列，而且向该列成功插入或者更新了一些显式值，则返回最后一个被插入或者更新的值。

>  如果之前的语句没有生成 **AUTO_INCREMENT** 值， *mysql_insert_id()* 返回0。如果你后续需要用到这个值，确保在生成这个值的语句之后立即调用 *mysql_insert_id()* 。

>  *mysql_insert_id()* 的值只受当前连接内的语句影响。跟其他连接无关。

>  **LAST_INSERT_ID()** SQL函数第一个被成功插入的自动生成的值。其返回值在语句之间并不会被重置，因为这个值是维护在服务端。它跟 *mysql_insert_id()* 的另一个不同是，在给 **AUTO_INCREMENT** 列置一个特定的非平凡值时， **LAST_INSERT_ID()** 的返回值也不会被修改。参考 [12.14，信息函数]() 。

> 以 **CALL** 语句调用存储过程之后再调用 *mysql_insert_id()* ，返回值为0，即便存储过程中生成了 **AUTO_INCREMENT** 值也是如此，因为 *mysql_insert_id()* 是针对的 **CALL** 语句而不是存储过程内部的语句。再存储过程内，可以在SQL层面使用 **LAST_INSERT_ID()** 以获取 **AUTO_INCREMENT** 值。

>  **LAST_INSERT_ID()** 和 *mysql_insert_id()* 不同的原因是 **LAST_INSERT_ID()** 是为了便于在脚本中使用，而 *mysql_insert_id()* 则尝试提供更多的关于 **AUTO_INCREMENT** 列的新西。

**返回值**

> 如上所述。

**错误**

> 无。

**22.8.7.38.**  *mysql_kill()*

> *int mysql_kill(MYSQL *mysql, unsigned long pid)*

**描述**

> 命令服务端杀死 *pid* 指定的线程。

> 该函数已废弃。建议使用 *mysql_query()* 执行 **KILL** 语句的方式代替。

>  *mysql_kill()* 不能处理超过32位的pid，为了防止错杀线程，MySQ L5.6.9在以下情况下会返回错误：

> * 如果ID的值大于32位，该函数返回 **CR_INVALID_CONN_HANDLE** 错误。

> * 当服务端内部线程ID计数器超过了32位，任何 *mysql_kill()* 调用都将失败，并且返回 **ER_DATA_OUT_OF_RANGE** 错误。

**返回值**

> 成功时返回0。发生错误时返回非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_INVALID_CONN_HANDLE

>	*pid* 大于32位。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

> * ER_UNKNOWN_COM_ERROR()

>	服务端的内部线程ID计数器超过了32位，此时将拒绝所有的 *mysql_kill()* 调用。

**22.8.7.39.**  *mysql_library_end()*

> *void mysql_library_end(void)*

**描述**

> 该函数析构MySQL库。在使用完库之后调用这个函数（例如，在断开数据库连接之后）。这个函数的效果取决于你的程序是链接了MySQL客户端库还是嵌入式服务端库。对于在编译阶段使用了 *-lmysqlclient* 标志与 *libmysqlclient* 库链接的客户端程序，该函数执行一些内存管理工作以清理内存。对于以 *-lmysqld* 标志链接了 *libmysqld* 的嵌入式服务程序，该函数停止嵌入式服务并执行一些清理工作。

> 关于使用信息，参考 [22.8.6，C API函数概述]() 以及 [22.8.7.40，mysql_library_init()]() 。

**22.8.7.40.**  *mysql_library_init()*

> *int mysql_library_init(int argc, char **argv, char **groups)*

**描述**

> 不管你的程序时普通的客户端程序还是使用了嵌入式服务，在调用其他MySQL函数之前都应该调用此函数以初始化MySQL库。如果你的程序使用的时嵌入式服务，该函数会启动服务器并且初始化所有必需的子系统（mysys，InnoDB等等）。

> 程序在使用完MySQL库之后，调用 *mysql_library_end()* 以进行清理。参考 [22.8.7.39，mysql_library_end]() 。

> 程序是普通客户端程序还是使用了嵌入式服务取决于你在链接阶段使用了 *libmysqlclient* 还是 *libmysqld* 。更多信息请参考 [22.8.6，C API函数概述]() 。

> 在非多线程环境下，对 *mysql_library_init()* 的调用可以省掉，因为在必要的时候 *mysql_init()* 会自动调用它。但是，在多线程环境下， *mysql_library_init()* 不是线程安全的， *mysql_init()* 也不是。你必须在创建任何线程之前调用 *mysql_library_init()* 或者使用互斥量进行保护，无论直接调用或者通过 *mysql_init()* 间接调用都应该如此。在此之后你才能调用其他客户端库函数。

> *argc* 和 *argv* 参数类似 *main()* 函数的相关参数，从而可以给嵌入式服务传递一些选项。方便起见，在没有命令行参数要传递给嵌入式服务的时候 *argc* 参数可以为0。普通客户端（非嵌入式）就属于这种情形，这个时候调用代码通常是这样的 *mysql_library_init(0, NULL, NULL)* 。

```c
#include <mysql.h>
#include <stdlib.h>
int main(void) {
  if (mysql_library_init(0, NULL, NULL)) {
    fprintf(stderr, "could not initialize MySQL library\n");
exit(1); }
  /* Use any MySQL API functions here */
  mysql_library_end();
  return EXIT_SUCCESS;
}
```

> 当需要传递参数时（ *argc* 大于0）， *argv* 的第一个元素将会被忽略。 *mysql_library_init()* 会另外拷贝一份这些参数以便调用过后可以安全销毁 *argv* 和 *groups* 。

> 对于嵌入式程序，如果你想连接外部服务器而不是启动嵌入式服务，则必须给 *argc* 参数传递一个负值。

> *groups* 参数是一个字符串数组，描述选项文件中的组。参考 [4.2.3.3，使用选项文件]() 。将数组中的最后一个元素置为 **NULL** 。方便起见，如果 *groups* 参数为 **NULL** ， *[server]* 组和 *[embeded]* 组将会被默认使用。

```c
#include <mysql.h>
#include <stdlib.h>
static char *server_args[] = {
  "this_program",       /* this string is not used */
  "--datadir=.",
  "--key_buffer_size=32M"
};
static char *server_groups[] = {
  "embedded",
  "server",
  "this_program_SERVER",
  (char *)NULL
};
int main(void) {
  if (mysql_library_init(sizeof(server_args) / sizeof(char *),
                        server_args, server_groups)) {
    fprintf(stderr, "could not initialize MySQL library\n");
exit(1); }
/* Use any MySQL API functions here */
mysql_library_end();
  return EXIT_SUCCESS;
}
```

**返回值**

> 成功返回0。出错返回非0。

**22.8.7.41.**  *mysql_list_dbs()*

> *MYSQL_RES *mysql_list_dbs(MYSQL *mysql, const char *wild)*

**描述**

> 返回包含服务端数据库名字的结果集，这些名字必须匹配 *wild* 指定的简单正则表达式。 *wild* 可以包含通配符 "%" 和 "_" ，也可以 **NULL** 以匹配所有数据库。调用 *mysql_list_dbs()* 类似于执行查询 **SHOW DATABASES [LIKE wild]**。

> 必须调用 *mysql_free_result()* 以释放结果集。

**返回值**

> 成功返回 **MYSQL_RES** 结构的结果集。有错误发生时返回 **NULL** 。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_OUT_OF_MEMORY

>	内存不足

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.42.**  *mysql_list_fields()*

> *MYSQL_RES *mysql_list_fields(MYSQL *mysql, const char *table, const char *wild)*

**描述**

> 返回包含指定表中字段的元信息的结果集，字段名必须匹配 *wild* 指定的简单正则表达式。 *wild* 可以包含通配符 "%" 和 "_" ，也可以 **NULL** 以匹配所有字段。调用 *mysql_list_fields()* 类似于执行查询 **SHOW COLUMNS FROM tbl_name [LIKE wild]** 。

> 相比于 *mysql_list_fields()* ，更推荐使用 **HOW COLUMNS FROM tbl_name** 。

> 必须调用 *mysql_free_result()* 以释放结果集。

**返回值**

> 成功返回 **MYSQL_RES** 结构的结果集。有错误发生时返回 **NULL** 。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**范例**

```c
int i;
MYSQL_RES *tbl_cols = mysql_list_fields(mysql, "mytbl", "f%");
unsigned int field_cnt = mysql_num_fields(tbl_cols);
printf("Number of columns: %d\n", field_cnt);
for (i=0; i < field_cnt; ++i)
{
  /* col describes i-th column of the table */
  MYSQL_FIELD *col = mysql_fetch_field_direct(tbl_cols, i);
  printf ("Column %d: %s\n", i, col->name);
}
mysql_free_result(tbl_cols);
```

**22.8.7.43.**  *mysql_list_processes()*

> *MYSQL_RES *mysql_list_processes(MYSQL *mysql)*

**描述**

> 返回一个包含当前服务端线程的结果集。返回的信息和 *mysqladmin processlist* 命令和 **SHOW PROCESSLIST** 查询返回的一样。

>必须调用 *mysql_free_result()* 以释放结果集。

**返回值**

> 成功返回 **MYSQL_RES** 结构的结果集。有错误发生时返回 **NULL** 。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.44.**  *mysql_list_tables()*

> *MYSQL_RES *mysql_list_tables(MYSQL *mysql, const char *wild)*

**描述**

> 返回一个结果集，包含当前数据库内的表名，表名必须匹配由 *wild* 所指定的简单正则表达式。 *wild* 可以包含通配符 "%" 和 "_" ，也可以 **NULL** 以匹配所有表。调用 *mysql_list_tables()* 效果类似于执行 **SHOW TABLES [LIKE wild]** 查询。

> 必须调用 *mysql_free_result()* 以释放结果集。

**返回值**

> 成功返回 **MYSQL_RES** 结构的结果集。有错误发生时返回 **NULL** 。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.45.**  *mysql_more_results()*

> *my_bool mysql_more_results(MYSQL *mysql)*

**描述**

> 该函数用于以下场景：在一条命令中执行多条语句；或者执行了可能返回多个结果集的 **CALL** 语句。

> 对于当前执行命令，如果还有待读取的结果集该函数返回true，在此情况下应用程序必须调用 *mysql_next_result()* 以获取结果集。

**返回值**

> 如果还有待读取结果集返回TRUE(1)。否则返回FALSE(0)。

> 大多数情况下，你都可以调用 *mysql_next_result()* 并且初始化读取而无需测试是否还有未读结果集。

> 参考 [22.8.17，C API对于多语句执行的支持]() ，以及 [22.8.7.46，mysql_next_result()]() 。

**错误**

> 无

**22.8.7.46.**  *mysql_next_result()*

> *int mysql_next_result(MYSQL *mysql)*

**描述**

> 该函数用于以下场景：在一条命令中执行多条语句；或者执行了可能返回多个结果集的 **CALL** 语句。

> 该函数读取下一条语句的结果并且返回一个错误码以表示释放还有未读取结果集。如果该调用返回了错误，则说明所有结果集都已读取。

> 如果当前语句会返回结果集（而不只是个结果状态），在调用 *mysql_next_result()* 之前必须调用 *mysql_free_result()* 。

> 调用了 *mysql_next_result()* 之后，数据库连接的状态等同于执行了 *mysql_real_query()* 或者 *mysql_query()* 之后的状态。这意味着此刻你可以调用 *mysql_store_result()*， *mysql_warning_count()*， *mysql_affected_rows()* 等待。

> 如果你调用 **CALL** 语句以执行存储过程，必须设置 **CLIENT_MULTI_RESULTS** 标记。这是因为除了返回存储过程内部各语句的结果集之外， **CALL** 还会返回调用状态。因为 **CALL** 语句可能返回多个结果集，所以以一个循环去处理结果集，每个循环内部调用 *mysql_next_result()* 以确定是否还存在未读取的结果集。

> 可以通过调用 *mysql_real_connect()* 以设置 **CLIENT_MULTI_RESULTS** ，也可以显式传递 **CLIENT_MULTI_RESULTS** 标记，或者通过传递 **CLIENT_MULTI_STATEMENTS** （它会设置 **CLIENT_MULTI_RESULTS** ）标记隐式传递该标记。在MySQL 5.6.1中，**CLIENT_MULTI_RESULTS** 默认被设置。

> 也可以调用 *mysql_more_results()* 以测试是否还有未读取结果集。但是该函数不会改变连接状态，所以如果该函数返回true，你还是需要调用 *mysql_next_result()* 以读取下一个结果集。

> 关于如何使用 *mysql_next_result()* 的范例，请参考 [22.8.17，C API对于多语句执行的支持]() 。

**返回值**

> <table>
> 	<tr><th>返回值</th><th>描述</th></tr>
> 	<tr><td>0</td><td>调用成功并且有未读结果集</td></tr>
> 	<tr><td>-1</td><td>调用成功并且无未读结果集</td></tr>
> 	<tr><td>>0</td><td>错误</td></tr>
> </table>

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。比如没有对上一个结果集调用 *mysql_use_result()* 。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.47.**  *mysql_num_fields()*

> *unsigned int mysql_num_fields(MYSQL_RES *result)*

> 如果要传递 **MYSQL \*** 参数，请使用 *unsigned int mysql_field_count(MYSQL *mysql)* 。

**描述**

> 返回结果集中的列数。

> 你可以从连接句柄或者结果集指针中获取列的数目。如果 *mysql_store_result()* 或者 *mysql_use_result()* 返回了 **NULL** （从而无法拿到结果集指针），你必须使用连接句柄来获取。在此情况下，你也可以调用 *mysql_field_count()* 来确定 *mysql_store_result()* 是否应该返回非空结果集。这使得客户端无需知道查询是否是 **SELECT** 类型也能采取合适的动作。下面的例子会展示如何做到这一点。

> 参考 [22.8.15.1，为什么在 *mysql_query()* 成功返回之后， *mysql_store_result()* 调用有时候会返回 **NULL** ]() 。

**返回值**

> 表示结果集中字段数目的无符号整数。

**错误**

> 无。

**范例**

```c
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;
if (mysql_query(&mysql,query_string))
{
// error }
else // query succeeded, process any data returned by it
{
    result = mysql_store_result(&mysql);
    if (result)  // there are rows
    {
        num_fields = mysql_num_fields(result);
        // retrieve rows, then call mysql_free_result(result)
    }
    else  // mysql_store_result() returned nothing; should it have?
    {
        if (mysql_errno(&mysql))
        {
			fprintf(stderr, "Error: %s\n", mysql_error(&mysql));
		}
		else if (mysql_field_count(&mysql) == 0)
		{
			// query does not return data
			// (it was not a SELECT)
			num_rows = mysql_affected_rows(&mysql);
		}
	}
}
```

> 如果知道查询应该返回结果集，可以通过检查 *mysql_field_count(&mysql)* 是否返回0 来代替对 *mysql_errno(&mysql)* 的调用。因为只在错误发生时返回值才会为0。

**22.8.7.48.**  *mysql_num_rows()*

> *my_ulonglong mysql_num_rows(MYSQL_RES *result)*

**描述**

> 返回结果集中的记录数。

> 在 *mysql_store_result()* 和 *mysql_use_result()* 两种情况下， *mysql_num_rows()* 的使用方法有所不同。如果使用的 *mysql_store_result()* ， *mysql_num_rows()* 可以立即调用。如果使用的是 *mysql_use_result()* ，必须等到所有结果集都读取完毕之后 *mysql_num_rows()* 才能返回正确结果。

> *mysql_num_rows()* 被设计与返回结果集的语句搭配使用，比如 **SELECT** 。对于 **INSERT**， **UPDATE**， 或者 **DELETE** 之类的语句，通过调用 *mysql_affected_rows()* 以获得受影响行数。

**返回值**

> 结果集中的记录数

**错误**

> 无。

**22.8.7.49.**  *mysql_options()*

> *int mysql_options(MYSQL *mysql, enum mysql_option option, const void *arg)*

**描述**

> 可以用来设置额外的连接选项进而影响连接上的行为。该函数可以多次调用以设置多个选项。

> 在 *mysql_init()* 之后， *mysql_connect()* 或者 *mysql_real_connect()* 之前调用该函数。

>  *option* 参数是你准备设置的选项； *arg* 参数是该选项的值。如果置为整数，把该整数的指针作为参数传递给 *arg* 。

> 下面的列表描述可能的选项，以及他们的效果，以及对于每个选项 *arg* 时如何使用的。有一些选项只适用于链接了 *libmysqld* 嵌入式服务库的程序，对于链接了 *libmysqlclient* 的客户端库的程序时无用的。对于有些选项 *arg* 参数无需使用，所以其值无需关心，通常将其赋为0。

> * **MYSQL_DEFAULT_AUTH** （参数类型： *char \** ）

>	要使用的认证插件的名字。

> * **MYSQL_ENABLE_CLEARTEXT_PLUGIN** （参数类型： *my_bool \** ）

>	开启 *mysql_clear_password* cleartext认证插件。（参考 [6.3.7.7，Cleartext客户端认证插件]() 。）该选项自MySQL 5.6.7被添加。

> * **MYSQL_INIT_COMMAND** （参数类型： *char \** ）

>	当连接上MySQL服务端的时候自动执行的SQL语句。如果发生重连，该语句也会再次自动执行。

> * **MYSQL_OPT_BIND** （参数类型： *char \** ）

>	使用哪个网络接口来连接服务端。这一选项用在当客户端主机有多个网络接口的时候。参数可以是主机名或者IP地址（字符串形式）。该选项自MySQL 5.6.1被添加。

> * **MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS** （参数类型： *char \** ）

>	给定键名，将其对应的键值对从连接属性集合中删除，该属性集合是要在连接时候传递给服务端的。参数是一指向null结尾字符串，包含键名。键名的比较时大小写敏感的。

>	参考对于 **MYSQL_OPT_CONNECT_ATTR_RESET** 选项的描述以及 *mysql_options4()* 中对于 **MYSQL_OPT_CONNECT_ATTR_ADD** 选项的描述。其中有一个使用的范例。这些选项都是自MySQL 5.6.6被添加。

>	连接属性可以从Performance Schema表 *session_connect_attr* 和 *session_account_connect_attrs* 中获取。参考 [21.9.8， Performance Schema连接属性表]() 。

> * **MYSQL_OPT_CONNECT_ATTR_RESET** （参数未使用）

>	该选项清除当前的连接属性集合。

>	参考对于 **MYSQL_OPT_CONNECT_ATTR_DELETE** 选项的描述以及 *mysql_options4()* 中对于 **MYSQL_OPT_CONNECT_ATTR_ADD** 选项的描述。其中有一个使用的范例。这些选项都是自MySQL 5.6.6被添加。

>	连接属性可以从Performance Schema表 *session_connect_attr* 和 *session_account_connect_attrs* 中获取。参考 [21.9.8， Performance Schema连接属性表]() 。

> * **MYSQL_OPT_CONNECT_TIMEOUT** （参数类型： *unsigned int \** ）

>	连接超时时间，以秒为单位。

> * **MYSQL_OPT_GUESS_CONNECTION** （参数未使用）

>	对于链接了 *libmysqld* 嵌入式服务库的程序，这一选项允许库猜测是使用嵌入式服务还是远程服务。"猜"意味着如果主机名被设定了，而且不是 *localhost* ，则将使用远程服务。这一行为是默认的。可以使用 **MYSQL_OPT_USE_EMBEDDED_CONNECTION** 以及 **MYSQL_OPT_USE_REMOTE_CONNECTION** 将其覆盖。如果程序链接的是 *libmysqlclient* 客户端库，这些选项将被忽略。

> * **MYSQL_OPT_LOCAL_INFILE** （参数类型：指向 *unsigned int* 的指针，可选）

>	如果指针未赋值或者指针指向非0的 *unsigned int* 值，则将可以执行 **LOAD LOCAL INFILE** 语句。

> * **MYSQL_OPT_NAMED_PIPE** （参数未使用）

>	使用命名管道连接Windows上的MySQL服务，当然前提是服务端允许命名管道连接。

> * **MYSQL_OPT_PROTOCOL** （参数类型： *unsigned int \** ）

>	要使用的协议类型。指定一个 *mysql.h* 中定义的 *mysql_prototol_type* 枚举值。

> * **MYSQL_OPT_READ_TIMEOUT** （参数类型： *unsigned int \** ）

>	读请求的超时时间，以秒为单位。在必要的情况下可能会有重试，从而总共的有效超时时间可能为选项值的3倍。合理的设置这个值可以早点发现连接断线，而不需要等 **Close_Wait_Timeout** ，也就是10分钟，

>	这一超时的实现机制可能不是在所有平台上都可用。在这样的平台上，发出了读请求的客户端在某些情况下可能会永不超时的等待。例如，如果服务端因为“磁盘满”而卡住，无法响应时，客户端可能就会永远等待。

> * **MYSQL_OPT_RECONNECT** （参数类型： *my_bool \** ）

>	开启或者关闭发现连接断开时的自动重连。默认是关闭的；这一选项提供了显式控制重连行为的方式。

> * **MYSQL_OPT_SSL_CA** （参数类型： *char \** ）

>	包含可信SSL CA列表的文件路径。这一选项自MySQL 5.6.3被添加。

> * **MYSQL_OPT_SSL_CAPATH** （参数类型： *char \** ）

> 	包含PEM格式可信SSL CA证书的文件夹路径。这一选项自MySQL 5.6.3被添加。

> * **MYSQL_OPT_SSL_CERT** （参数类型： *char \** ）

>	用来建立安全连接的SSL证书文件的名字。这一选项自MySQL 5.6.3被添加。

> * **MYSQL_OPT_SSL_CIPHER** （参数类型： *char \** ）

>	可允许的用于SSL加密的加密器列表。这一选项自MySQL 5.6.3被添加。

> * **MYSQL_OPT_SSL_CRL** （参数类型： *char \** ）

>	一个PEM格式文件的路径，该文件包含证书废止列表。这一选项自MySQL 5.6.3被添加。

> * **MYSQL_OPT_SSL_CRLPATH** （参数类型： *char \** ）

>	一个文件夹的路径，其中的文件是PEM格式，内容为证书废止列表。这一选项自MySQL 5.6.3被添加。

> * **MYSQL_OPT_SSL_KEY** （参数类型： *char \** ）

>	用于简历安全连接的SSL密钥文件的名字。这一选项自MySQL 5.6.3被添加。

> * **MYSQL_OPT_SSL_VERIFY_SERVER_CERT** （参数类型： *my_bool \** ）

>	开启或者关闭主机名和证书中Common Name值的对比验证。如果不匹配则连接将被拒绝。这一特性可以用来防止中间人攻击。验证默认是关闭的。

> * **MYSQL_OPT_USE_EMBEDDED_CONNECTION** （参数未使用）

>	对于链接了 *libmysqld* 嵌入式服务库的程序，这一选项强制连接嵌入式服务实例。如果程序链接但是 *libmysqlclient* ，这一选项将会被忽略。

> * **MYSQL_OPT_USE_REMOTE_CONNECTION** （参数未使用）

>	对于链接了 *libmysqld* 嵌入式服务库的程序，这一选项强制连接远程服务实例。如果程序链接但是 *libmysqlclient* ，这一选项将会被忽略。

> * **MYSQL_OPT_USE_RESULT** （参数未使用）

>	选项未使用。

> * **MYSQL_OPT_WRITE_TIMEOUT** （参数类型： *unsigned int \** ）

>	向服务端写操作的超时时间，以秒为单位。在必要的情况下可能会有重试，从而总共的有效超时时间可能为选项值的2倍。

> * **MYSQL_PLUGIN_DIR** （参数类型： *char \** ）

>	查找客户端插件的目录。

> * **MYSQL_READ_DEFAULT_FILE** （参数类型： *char \** ）

> 	从指定的选项文件而不是 *my.cnf* 中读取配置。

> * **MYSQL_READ_DEFAULT_GROUP** （参数类型： *char \** ）

>	从 *my.cnf* 或者 **MYSQL_READ_DEFAULT_FILE** 指定的文件中读取指定组的配置。

> * **MYSQL_REPORT_DATA_TRUNCATION** （参数类型： *my_bool \** ）

>	开启或者关闭使用 **MYSQL_BIND** 结构的 *error* 成员报告预处理语句的数据截断错误。（默认：开启）

> * **MYSQL_SECURE_AUTH** （参数类型： *my_bool \** ）

>	是否连接不支持MySQL 4.1.1及之后版本使用的密码hash功能的服务实例。在MySQL 5.6.7中，该选项默认为是。

> * **MYSQL_SERVER_PUBLIC_KEY** （参数类型： *char \** ）

>	包含了服务端RSA公钥的文件的路径。该文件必须是PEM格式。该公钥在连接服务端的时候用于对客户端密码进行RSA加密，只有在使用 *sha256_password* 插件进行认证的时候才会使用这种方法。其他情况下该选项将被忽略。在密码加密非必要的情况下，该选项也会被忽略，因为在这个情况下客户端以SSL方式连接服务端。

>	在需要的时候服务端会将公钥发送给客户端，所以哪怕要使用RSA密码加密，这一选项也不是必要的。当然这样做更有效一点，因为服务端无需发生公钥。

>	关于 *sha256_password* 插件使用的更多讨论，包括如何获取RSA公钥，请参考 [6.3.7.4，SHA-256认证插件]() 。

>	该选项自MySQL 5.6.6添加。

> * **MYSQL_SET_CHARSET_DIR** （参数类型： *char \** ）

>	包含字符集定义文件的文件夹路径。

> * **MYSQL_SET_CHARSET_NAME** （参数类型： *char \** ）

>	被用作默认字符集的字符集名字。参数可以是 **MYSQL_AUTODETECT_CHARSET_NAME** ，这样将会使程序基于操作系统设置自动探测字符集（参考 [10.1.4，连接字符集以及校对规则]() ）。

> * **MYSQL_SET_CLIENT_IP** （参数类型： *char \** ）

>	对于链接了 *libmysqld* 嵌入式服务库的的程序（ *libmysqld* 以支持认证的方式编译），这意味着用户应该被看成是从指定的IP连接过来的。如果程序连接的是 *libmysqlclient* 客户端库，这一选项将被忽略。

> * **MYSQL_SHARED_MEMORY_BASE_NAME** （参数类型： *char \** ）

>	用于与Windows上服务通信的共享内存对象的名字，前提是服务器支持共享内存连接。将其值设置为跟你要连接的 *mysqld* 服务实例的 *--shared-memory-base-name* 选项一致。

>	如果使用了 **MYSQL_READ_DEFAULT_FILE** 或者 **MYSQL_READ_DEFAULT_GROUP** ，*client* 组将总是会被读取。

>	选项文件中的特定组可以包含如下选项。

> <table>
> 	<tr><th>选项</th><th>描述</th></tr>
> 	<tr><td>character-sets-dir=path</td><td>字符集被安装的路径</td></tr>
> 	<tr><td>compress</td><td>使用压缩client/server协议</td></tr>
> 	<tr><td>connect-timeout=seconds</td><td>以秒为单位的连接超时，在Linux上该选项也表示等待服务端首歌应答的时间</td></tr>
> 	<tr><td>database=db_name</td><td>如果在连接命令中没有指定数据库就是用该数据库</td></tr>
> 	<tr><td>debug</td><td>调试选项</td></tr>
> 	<tr><td>default-character- set=charset_name</td><td>要使用的默认字符集</td></tr>
> 	<tr><td>disable-local-infile</td><td>禁止使用 LOAD DATA LOCAL </td></tr>
> 	<tr><td>enable-cleartext-plugin</td><td>使用 mysql_clear_password cleartext认证插件。在MySQL 5.6.7被加入。</td></tr>
> 	<tr><td>host=host_name</td><td>默认主机名</td></tr>
> 	<tr><td>init-command=stmt</td><td>在连接MySQL服务端时候自动执行的语句。如果重连发生，该语句将会自动再次执行</td></tr>
> 	<tr><td>interactive- timeout=seconds</td><td>跟在调用 mysql_real_connect() 时设置 CLIENT_INTERACTIVE 效果一样。参考[22.8.7.53，mysql_real_connect()]()</td></tr>
> 	<tr><td>local-infile[={0|1}]</td><td>如果未指定参数或者指定了非0值，开启LOAD DATA FILE的使用，否则关闭</td></tr>
> 	<tr><td>max_allowed_packet=bytes</td><td>可以从服务端读取的包的最大长度</td></tr>
> 	<tr><td>multi-queries, multi- results</td><td>允许因多语句执行或者存储过程而产生的多结果集</td></tr>
> 	<tr><td>multi-statements</td><td>运行客户端在一个请求字符串中发生多条语句（以“;”分隔）</td></tr>
> 	<tr><td>password=password</td><td>默认密码</td></tr>
> 	<tr><td>pipe</td><td>使用命名管道连接Windows上的MySQL服务</td></tr>
> 	<tr><td>port=port_num</td><td>默认端口</td></tr>
> 	<tr><td>protocol={TCP|SOCKET|
PIPE|MEMORY}</td><td>连接服务端时使用的协议</td></tr>
> 	<tr><td>return-found-rows</td><td>对于UPDATE，让mysql_info()返回匹配的行而不是更改的行</td></tr>
> 	<tr><td>shared-memory-base-name=name</td><td>用于连接服务端的共享内存的名字</td></tr>
> 	<tr><td>socket=path</td><td>默认套接字文件</td></tr>
> 	<tr><td>ssl-ca=file_name</td><td>Certificate Authority文件</td></tr>
> 	<tr><td>ssl-capath=path</td><td>Certificate Authority目录</td></tr>
> 	<tr><td>ssl-cert=file_name</td><td>证书文件</td></tr>
> 	<tr><td>ssl-cipher=cipher_list</td><td>可允许的SSL加密方法</td></tr>
> 	<tr><td>ssl-key=file_name</td><td>密钥文件</td></tr>
> 	<tr><td>timeout=seconds</td><td>类似connect-timeout</td></tr>
> 	<tr><td>user</td><td>默认用户</td></tr>
> </table>

>	*timeout* 已经被 *connect-timeout* 取代，但是在MySQL 5.6中为了向后兼容， *timeout* 依然被支持。

>	关于选项文件的更多信息，参考 [4.2.3.3，使用选项文件]() 。

**返回值**

>	成功返回0，如果指定了一个未知选项将返回非0。

**范例**

>	下面的 *mysql_options4()* 调用将会要求客户端启用 client/server 协议的压缩模式、从配置文件 *my.cbf=cnf* 的 *[odbc]* 组中读取选项以及关闭事物的自动提交模式：

```c
MYSQL mysql;
mysql_init(&mysql);
mysql_options(&mysql,MYSQL_OPT_COMPRESS,0);
mysql_options(&mysql,MYSQL_READ_DEFAULT_GROUP,"odbc");
mysql_options(&mysql,MYSQL_INIT_COMMAND,"SET autocommit=0");
if (!mysql_real_connect(&mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
          mysql_error(&mysql));
}
```

**22.8.7.50.**  *mysql_options4()*

> *int mysql_options4(MYSQL *mysql, enum mysql_option option, const void *arg1, const void *arg2)*

**描述**

> *mysql_option4()* 跟 *mysql_option()* 类似，但是多了一个参数，所以可以为相关的选项传递2个值。这个函数自MySQL 5.6.6被添加。

> 以下列表描述使用的选项，效果以及 *argv1* 和 *argv2* 如何使用。

> * **MYSQL_OPT_CONNECT_ATTR_ADD** （参数类型： *char \*, char \** ）

> 	该选项给连接属性的当前集合增加一个键值对，这个集合会在连接服务端的时候被使用。两个参数都是指向null结尾字符串的指针。分别代表键和值。如果改键在当前属性集合中已存在，将会出错。键名的比较是大小写敏感的。

> 	以下划线（_）开头的键名被保留做内部用途，应用程序不应该使用这样的键名。

> 	参考 *mysql_option()* 中关于选项 **MYSQL_OPT_CONNECT_ATTR_RESET** 和 **MYSQL_OPT_CONNECT_ATTR_DELETE** 的描述。

>	连接属性可以从Performance Schema表 *session_connect_attr* 和 *session_account_connect_attrs* 中获取。参考 [21.9.8， Performance Schema连接属性表]() 。

**返回值**

> 成功时返回0。指定了未知选项时返回非0。

**范例**

> 本例演示如何调用该函数设置连接属性。

```c
MYSQL mysql;
mysql_init(&mysql);
mysql_options(&mysql,MYSQL_OPT_CONNECT_ATTR_RESET, 0);
mysql_options4(&mysql,MYSQL_OPT_CONNECT_ATTR_ADD, "key1", "value1");
mysql_options4(&mysql,MYSQL_OPT_CONNECT_ATTR_ADD, "key2", "value2");
mysql_options4(&mysql,MYSQL_OPT_CONNECT_ATTR_ADD, "key3", "value3");
mysql_options(&mysql,MYSQL_OPT_CONNECT_ATTR_DELETE, "key1");
if (!mysql_real_connect(&mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
        mysql_error(&mysql));
}
mysql_options(&mysql,MYSQL_OPT_CONNECT_ATTR_RESET, 0);
```

**22.8.7.51.**  *mysql_ping()*

> *int mysql_ping(MYSQL *mysql)*

**描述**

> 检查到服务端的连接是否可用。如果连接断开了，但是设置了自动重连，则该调用会尝试重连服务器，如果未设置自动重连，该函数返回一个错误。

> 自动重连默认关闭。可以以选项 **MYSQL_OPT_RECONNECT** 调用 *mysql_options()* 来将其开启。详细请参考 [22.8.49，mysql_options()]() 。

> 在客户端空闲了很久的情况下，可以调用 *mysql_ping()* 来检查连接是否已被服务端关闭，并且在必要的时候重连。

> 没有很显而易见的方法检查 *mysql_ping()* 进行了重连。一个迂回的方法是，在调用该函数之前和之后分别调用 *mysql_thread_id()* 并且检查两个值是否一致，如果不同则说明发生了重连。

> 一旦发生了重连，一些连接的属性将会被重置。详细请参考 [22.8.16，控制自动重连行为]() 。

**返回值**

> 如果连接是存活的，返回0。出错了返回非0。非0不代表服务宕机；连接也有可能因为其他的原因比如网络问题而断开。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
		
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.52.**  *mysql_query()*

> *int mysql_query(MYSQL *mysql, const char *stmt_str)*

**描述**

> 执行null结尾字符串 *stmt_str* 包含的SQL语句。一般情况下，字符串只能包含一条SQL语句，同时不需要以“;”和“\g”结尾。如果开启了多语句执行，字符串可以包含多条SQL语句，但要以分分号分隔。参考 [22.8.17，C API对多语句执行的支持]() 。

> 该函数不能用于包含了二进制数据的语句；那种情况下必须使用 *mysql_real_query()* 。（因为二进制数据可能包含 “\0”， *mysql_query()* 会将其误认为是字符串结尾。）

> 如果你想知道一条语句是否返回了一个结果集，你可以调用 *mysql_field_count()* 来进行验证。参考 [22.8.7.22，mysql_field_count()]() 。

**返回值**

> 执行成功时返回0。出错时返回非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.53.**  *mysql_real_connect()*

> *MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag)*

**描述**

> 该函数尝试建立一条到 *host* 指定的MySQL数据库引擎的连接。在调用任何需要 **MYSQL** 连接句柄作为参赛的API函数之前，必须确保 *mysql_real_connect()* 被调用了，并且成功返回了。

> 参数说明如下：

> *	把 **MYSQL** 结构的地址传给第一个参数。在调用 *mysql_real_connect()** 之前，调用 *mysql_init()* 以初始化 **MYSQL** 对象。另外可以调用 *mysql_options()* 更改各种连接选项。参考 [22.8.7.49，mysql_options()]() 。

> *	*host* 参数可以是主机名或者是IP地址。如果 *host* 参数为 **NULL** 或者 “ *localhost* ”，将默认连接本机自己。对于Windows，如果服务端支持共享内存连接，客户端也将通过共享内存连接的方式进行连接。否则，将使用TCP/IP。对于Unix，使用Unix套接字文件的方式进行连接。对于本地连接，你可通过调用 *mysql_options()* 设置 **MYSQL_OPT_PROTOCOL** 或者 **MYSQL_OPT_NAMED_PIPE** 选项来修改连接方式。当然必须要服务端支持这种连接方式。在Windows上，如果 *host* 的值为 “.” 同时服务端支持命名管道连接方式，则客户端将通过命名观点通服务端连接，如果服务端不支持则会报错。

> *	*user* 参数为用户的MySQL登陆ID。如果该参数为 **NULL** 或者为空字符串，将默认使用当前用户。在Unix下，即为当前登陆用户。在Windows ODBC，必须显式指定当前用户名。参考 [22，连接器和API]() 的Connector/ODBC 节。

> *	*passwd* 参数包含用户 *user* 的密码。如果该参数为 **NULL** ，则将只与系统 *user* 表中的那些密码字段为空的用户进行匹配。从而数据库管理员可以通过根据用户是否有密码来决定权限的方式来建立MySQL权限系统。

> **注意**

> 不要在调用 *mysql_real_connect()* 之前对密码进行加密；密码加密工作是在客户端API内自动完成的。

> *	参数 *user* 和 *passwd* 的字符集由 **MYSQL** 结构体中相关信息决定。默认是 *latin1* 这个值也可以通过在进行连接之前调用 *mysql_options(mysql, MYSQL_SET_CHARSET_NAME, "charset_name")* 的方式进行修改。

> *	*db* 是数据库名。如果其非 **NULL** ，本连接的默认数据库将被设置为该值。

> *	如果 *port* 参数非0，则将把它作为TCP/IP连接的端口。注意 *host* 参数决定了连接的类型。

> *	如果 *unix_socket* 参数非 **NULL** ，则其指定要使用的套接字或者命名管道。注意 *host* 参数决定了连接的类型。

> *	*client_flag* 的值通常为0，不过也可以设置为以下标记的组合以开启相应的功能。

> <table>
> 	<tr><th>标记名</th><th>标记描述</th></tr>
> 	<tr><td>CAN_HANDLE_EXPIRED_PASSWORDS</td><td>客户端可以处理过期密码。更多信息参考 [6.3.6，密码过期与沙盒模型]() 。该选项自MySQL 5.6.10被添加。</td></tr>
> 	<tr><td>CLIENT_COMPRESS</td><td>使用压缩协议</td></tr>
> 	<tr><td>CLIENT_FOUND_ROWS</td><td>返回匹配行数，而不是修改行数</td></tr>
> 	<tr><td>CLIENT_IGNORE_SIGPIPE</td><td>禁止客户端库安装 **SIGPIPE** 信号处理函数。这样可以避免跟应用程序已安装的此类函数冲突。</td></tr>
> 	<tr><td>CLIENT_IGNORE_SPACE</td><td>允许函数名后加空格。使所有函数名成为保留字。</td></tr>
> 	<tr><td>CLIENT_INTERACTIVE</td><td>在关闭连接之前，允许最长 interactive_timeout （而不是 wait_timeout ）秒的空闲期。该会话的 wait_timeout 将被设置为 interactive_timeout 的值。</td></tr>
> 	<tr><td>CLIENT_LOCAL_FILES</td><td>允许使用 LOAD DATA INFILE</td></tr>
> 	<tr><td>CLIENT_MULTI_RESULTS</td><td>通知服务端可以处理因多语句执行或者存储过程造成的多结果集。如果CLIENT_MULTI_STATEMENTS被开启，该标记也将默认开启。参考本表之后的提示以及更多的关于本标记的信息。</td></tr>
> 	<tr><td>CLIENT_MULTI_STATEMENTS</td><td>通知服务端客户端可能会在一个请求中发送多条语句（以“;”分隔）。如果此标记未设置，多语句执行功能将不能使用。参考本表之后的提示以及更多的关于本标记的信息。</td></tr>
> 	<tr><td>CLIENT_NO_SCHEMA</td><td>不允许db_name.tbl_name.col_name语法。这是针对ODBC的。如果使用这样的语法将会导致错误，这对于在一些ODBC程序中跟踪bug很有作用。</td></tr>
> 	<tr><td>CLIENT_ODBC</td><td>未使用</td></tr>
> 	<tr><td>CLIENT_SSL</td><td>使用SSL（加密协议）。不要在程序中显式设置该选项；在客户端库内部将会被设置。正确的做法是在调用 mysql_real_connect() 之前调用 mysql_ssl_set()。</td></tr>
> 	<tr><td>CLIENT_REMEMBER_OPTIONS</td><td>记住通过mysql_options()设置的选项。否则，如果mysql_real_connect()失败，而你需要重新连接的时候你将必须再次重复之前的mysql_options()调用。设置了该标记之后，就无需再次重复那些调用了。</td></tr>
> </table>


> 如果你需要调用 **CALL** 来执行存储过程，必须设置 **CLIENT_MULTI_RESULTS** 标记。因为 **CALL** 语句除了返回存储过程产生的各结果集之外还会返回一个值以表示本调用的状态。因为 **CALL** 语句比如产生多个结果集，所以需要重复调用 *mysql_next_result()* 来检查是否已将所有结果集读完。

> 可以在调用 *mysql_real_connect()* 的时候显式设置 **CLIENT_MULTI_RESULTS** 标记或者通过设置 **CLIENT_MULTI_STATEMENTS** 的方式隐式设置 **CLIENT_MULTI_RESULTS** （ **CLIENT_MULTI_STATEMENTS** 会自动开启 **CLIENT_MULTI_RESULTS** ）。在MySQL 5.6中，将标记默认被设置。

> 如果设置了 **CLIENT_MULTI_STATEMENTS** 或者 **CLIENT_MULTI_RESULTS** ，每次调用 *mysql_query()* 或者 *mysql_real_query()* 之后都应该重复调用 *mysql_next_result()* 来检查是否还有未读的数据集。 [22.8.17，C API对于多语句执行的支持]() 有一个相关例子。

> 对于有些参数，可以从选项文件中读取，而不需要通过 *mysql_real_connect()* 显式指定。要做到这一点只需在调用 *mysql_real_connect()* 之前以 **MYSQL_READ_DEFAULT_FILE** 或者 **MYSQL_READ_DEFAULT_GROUP** 调用 *mysql_options()* 即可。在之后的 *mysql_real_connect()* 调用中，对于这些可以从选项文件中读取的参数，将其值设置为 "no-value" 就好了。

> *	对于 *host* 将其设置为 **NULL** 或者为空字符串（""）。

> *	对于 *user* 将其设置为 **NULL** 或者为空字符串。

> *	对于 *passwd* 将其设置为 **NULL** 。（对于密码，选项文件中的值不能覆盖在 *mysql_real_connect()* 中传递过去的空字符串，这是因为空字符串显式的指明了该账号的的密码就是空字符串。）

> *	对于 *db*  将其设置为 **NULL** 或者为空字符串。

> *	对于 *port*  将其设置0。

> *	对于 *passwd* 将其设置为 **NULL** 。

> 如果有些参数在选项文件中找不到，则将使用它们的默认值，本节前面部分这方面的说明。

**返回值**

> 如果连接成功，返回一个 **MYSQL\*** 类型的连接句柄，否则返回 **NULL** 。如果成功，返回值和第一个参数是一样的。

**错误**

>	* **CR_CONN_HOST_ERROR**
	
	无法连接MySQL服务端。
	
>	* **CR_CONNECTION_ERROR**
	
	无法连接本地MySQL服务端。
	
>	* **CR_IPSOCK_ERROR**

	无法创建IP套接字。
	
>	* **CR_OUT_OF_MEMORY**
	
	内存不足。

>	* **CR_SOCKET_CREATE_ERROR**
	
	无法创建Unix套接字。
	
>	* **CR_UNKNOWN_HOST**
	
	无法获取主机的IP地址。

>	* **CR_VERSION_ERROR**
	
	客户端与服务端协议不匹配。
	
>	* **CR_NAMEDPIPEOPEN_ERROR**

	无法在Windows上创建命名管道。
	
>	* **CR_NAMEDPIPEWAIT_ERROR**
	
	在Windows上等待命名管道出错。

>	* **CR_NAMEDPIPESETSTATE_ERROR**
	
	无法在Windows上获取管道句柄。
	
>	* **CR_SERVER_LOST**
	
	在 *connect_timeout* > 0 情况下，连接服务器耗费的时间超过了该值；或者在执行 *init-command* 的时候服务端挂起。
	
>	* **CR_ALREADY_CONNECTED**

	**MYSQL** 连接句柄已处于连接状态。
	
**范例**

```c
MYSQL mysql;
mysql_init(&mysql);
mysql_options(&mysql,MYSQL_READ_DEFAULT_GROUP,"your_prog_name");
if (!mysql_real_connect(&mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
          mysql_error(&mysql));
}
```

> 调用 *mysql_options()* 读取 *my.cnf* 文件的 *[client]* 和 *[your_prog_name]* 节以确认你的程序正常工作，这样也就不怕有人以非标准的方式的方式安装MySQL了。

> 要注意的是，一旦连接建立之后， *mysql_real_connect()* 函数在5.0.3以及更老版本上会将 *reconnect* 标记（ **MYSQL** 结构的一个成员）设置为1，在较新的版本上会将其设置为0。为1就意味着如果因为连接丢失而导致一个语句不能执行，客户端将会尝试重连。可以通过使用 **MYSQL_OPT_RECONNECT** 选项调用 *mysql_options()* 来控制重连行为。

**22.8.7.54.**  *mysql_real_escape_string()*

> *unsigned long mysql_real_escape_string(MYSQL *mysql, char *to, const char *from, unsigned long length)*

> 注意 *mysql* 必须是一个有效的活跃连接。因为转义依赖于服务端正在使用的字符集，所以这一点是必须的。

**描述**

> 该函数用来生成能够用于SQL语句的合法SQL字符串。参考 [9.1.1，字符串文本]() 。

> 根据连接当前使用的字符集， *from* 包含的字符串将会被转义编码。结果存放在 *to* 中，以'\0'结尾。被转义的字符有“\”，“'”，“""”，NUL（0的ASCII编码），“\n”，“\r”，以及Contron+Z。严格的说，MySQL查询中只有反斜线，单双引号需要转义。转义其他的的字符只是为了让其在日志文件中更易阅读。参考 [9.1.1，字符串文本]() 和 [12.5，字符串函数]() 中的字符串文本引用规则和 **QUOTE()** SQL函数以进行比较。

> *length* 指定 *from* 的长度。 *to* 所使用的缓存大小至少应为 *length\*2+1* 字节。（最坏情况下，每个字符将会编码成2个字节，最后还需加上结尾的 '\0' ）。 *mysql_real_escape_string()* 调用返回之后， *to* 的内容为一null结尾字符串。返回值是编码字符串的长度，不包含null字符。

> 如果你要改变连接的字符集，使用 *mysql_set_character_set()* 函数，不要使用执行 **SET NAMES** （或者 **SET CHARACTER SET** ）语句的方式。 *mysql_set_character_set()* 作用跟 **SET NAMES** 类似，但是它会改变 *mysql_real_escape_string()* 所使用的字符集，但是 **SET NAMES** 则不会。

**范例** 

```c
char query[1000],*end;
end = strmov(query,"INSERT INTO test_table values(");
*end++ = '\'';
end += mysql_real_escape_string(&mysql, end,"What is this",12);
*end++ = '\'';
*end++ = ',';
*end++ = '\'';
end += mysql_real_escape_string(&mysql, end,"binary data: \0\r\n",16);
*end++ = '\'';
*end++ = ')';
if (mysql_real_query(&mysql,query,(unsigned int) (end - query)))
{
   fprintf(stderr, "Failed to insert row, Error: %s\n",
           mysql_error(&mysql));
}
```

> 此例中使用的 *strmov()* 函数包含于 *libmysqlclient* 之中，作用跟 *strcpy()* 类似，除了返回值指向的是第一个参数的结尾null字符。

**返回值**

> 写入 *to* 中字符串的长度，不包含结尾的 null 字符。

**错误**

> 无。

**22.8.7.55.**  *mysql_real_query()*

> *int mysql_real_query(MYSQL *mysql, const char *stmt_str, unsigned long length)*

**描述**

> 执行 *stmt_str* 字符串所包含的SQL语句，其长度为 *length* 字节。一般的，该字符串只能包含一条单一的SQL语句，也不需要“;”或者“\g”结尾。但是如果启用了多语句执行，该字符串就可以包含多条语句，用分号分隔即可。参考 [22.8.17，C API对多语句执行的支持]() 。

> *mysql_query()* 无法用于包含二进制数据的语句，在此情况下你必须使用 *mysql_real_query()* 。（二进制数据可能包含'\0' ， *mysql_query()* 会将其认为是字符串结尾。）其次， *mysql_real_query()* 要比 *mysql_query()* 更快，因为无需对语句字符串调用 *strlen()* 函数。

> 要想确定一个语句是否返回了结果集，可以调用 *mysql_field_count()* 来检查之。参考 [22.8.7.22，mysql_field_count()]() 。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.56.**  *mysql_refresh()*

> *int mysql_refresh(MYSQL *mysql, unsigned int options)*

**描述**

> 该函数刷新表和缓存，或者重置复制服务器信息。连接上的用户必须要有 **RELOAD** 权限。

> *options* 参数可以是以下各值的或运算组合。

> *	**REFRESH_GRANT** 

>	刷新授权表，类似 **FLUSH PRIVILEGES** 。

> *	**REFRESH_LOG**

>	刷新日志，类似 **FLUSH LOGS** 。

> *	**REFRESH_TABLES**

>	刷新表缓存，类似 **FLUSH TABLES** 。

> *	**REFRESH_HOSTS**

>	刷新主机缓存，类似 **FLUSH HOSTS** 。

> *	**REFRESH_STATUS**

>	重置状态变量，类似 **FLUSH STATUS** 。

> *	**REFRESH_THREADS**

>	刷新线程缓存。

> *	**REFRESH_SLAVE**

>	在用于复制的从服务器上，重置主服务器相关信息并且重启从服务器，类似 **RESET SLAVE** 。

> *	**REFRESH_MASTER**

>	在用于复制的主服务器上，删除二进制日志索引文件中的二进制日志文件列表，并且清空该文件的内容，类似 **RESET MASTER** 。

**返回值**

> 成功返回0。发生错误时返回非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.57.**  *mysql_reload()*

> *int mysql_reload(MYSQL *mysql)*

**描述**

> 指示MySQL服务程序重新载入授权表。连接上的用户必须有 **RELOAD** 权限。

> 该函数已废弃。推荐使用 *mysq_query()* 执行 **FLUSH PRIVILEGES** SQL语句的方法代替。

**返回值**

> 成功返回0。错误发生是返回非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

>	未知错误。

**22.8.7.58.**  *mysql_rollback()*

> *my_bool mysql_rollback(MYSQL *mysql)*

**描述**

> 回滚当前事物。

> 该函数的行为跟系统变量 *completion_type* 有关系。尤其当其值为 **RELEASE** （或者2）时，服务端在终止一个事物之后会执行一次释放并且关闭客户端连接。在程序中调用 *mysql_close()* 以从客户端关闭连接。

**返回值**

> 成功返回0。错误发生时返回非0。

**错误**

> 无。

**22.8.7.4.**  *mysql_row_seek()*

> *MYSQL_ROW_OFFSET mysql_row_seek(MYSQL_RES *result, MYSQL_ROW_OFFSET offset)*

**描述**

> 移动行游标到结果集的任意位置。 *offset* 为行偏移，其值来自于 *mysql_row_tell()* 或者 *mysql_row_seek()* 的返回值。主要其值不是行号，如果要以行号定位到结果集中的某一行，请使用 *mysql_data_seek()* 代替。

> 该函数要求结果集包含查询的整个结果，所以 *mysql_row_seek()* 只能跟 *mysql_store_result()* 配合使用，而不能跟 *mysql_use_result()* 一起使用。

**返回值**

> 调用该函数之前的行游标值。这个值可以传递给后续的 *mysql_row_seek()* 调用。

**错误**

> 无。

**22.8.7.60.**  *mysql_row_tell()*

> *MYSQL_ROW_OFFSET mysql_row_tell(MYSQL_RES *result)*

**描述**

> 返回行游标的当前位置，该位置受上次 *mysql_fetch_row()* 调用影响。该值可作为 *mysql_row_seek()* 调用的参数。

> 只能在 *mysql_store_result()* 之后调用 *mysql_row_tell()* ，而不能在 *mysql_use_result()* 之后调用。

**返回值**

> 行游标的当前偏移。

**错误**

> 无。

**22.8.7.61.**  *mysql_select_db()*

> *int mysql_select_db(MYSQL *mysql, const char *db)*

**描述**

> 使 *db* 指定的数据库作为 *mysql* 所代表连接的默认（当前）数据库。在后续的查询中，如果没有显式指定数据库前缀，该数据库将作为表所在的默认数据库。

**返回值**

> 成功返回0。错误发生返回非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.62.**  *mysql_set_character_set()*

> *int mysql_set_character_set(MYSQL *mysql, const char *csname)*

**描述**

> 该函数设置当前连接的默认字符集。 *csname* 指定一个有效的字符集名。本字符集的校验规则将会变成连接的校验规则。该函数效果类似 **SET NAMES** 语句，同时也回设置 *mysql->charset* ，因而会影响 *mysql_real_escape_string()* 使用的字符集。

**返回值**

> 成功返回0。错误发生返回非0。

**范例**

```c
MYSQL mysql;
mysql_init(&mysql);
if (!mysql_real_connect(&mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
          mysql_error(&mysql));
}
if (!mysql_set_character_set(&mysql, "utf8"))
{
    printf("New client character set: %s\n",
           mysql_character_set_name(&mysql));
}
```

**22.8.7.63.**  *mysql_set_character_set()*

> *mysql_set_local_infile_default()*

**描述**

> 设置 **LOAD LOCAL DATA INFILE** 回调函数为默认值，该函数被C客户端库使用。如果 *mysql_set_local_infile_handler()* 未被调用或者没有提供合适的回调函数，该函数将会被自动调用。

**返回值**

> 无。

**错误**

> 无。

**22.8.7.64.**  *mysql_set_local_infile_handler()*

> *void mysql_set_local_infile_handler(MYSQL *mysql, int (*local_infile_init)(void **, const char *, void *), int (*local_infile_read)(void *, char *, unsigned int), void (*local_infile_end)(void *), int (*local_infile_error)(void *, char*, unsigned int), void *userdata)*

**描述**

> 该函数安装在执行 **LOAD DATA LOCAL INFILE** 期间将会被用到的回调函数。该函数使得程序可以对本地数据文件读取施加控制。参数分别是连接句柄，一组回调函数的指针，以及一个指向用户数据的指针，回调函数可以使用这一指针来共享信息。

> 要使用 *mysql_set_local_infile_handler()* ，必须定义如下回调函数：

```c
int
local_infile_init(void **ptr, const char *filename, void *userdata);
```

> 初始化函数，只调用一次，用来做一些必要的初始化，打开数据文件，分配数据结构等等。第一个参数 *void\*\** 是一个指针的指针。你可以将其值（*ptr）设置为某个合适的值，传递给其他回调函数（以 *void\** 的方式）。其他的回调函数可以使用这个值来维护状态信息。 *userdata* 参数的值就是传递给 *mysql_set_local_infile_handler()* 的同名参数的值。

> 该函数在成功的时候应该返回0，发生错误的时候返回非0。

```c
int
local_infile_read(void *ptr, char *buf, unsigned int buf_len);
```

> 数据读取函数。重复调用以读取数据文件。 *buf* 指向存储数据的缓存区， *buf_len* 表示回调函数可以读取以及存储到缓存中的最大字节数。（可以少读，但是绝对不可用多读。）

> 返回值应该为已读取的字节数，当无数据读取的时候返回0（表示EOF）。错误发生时返回小于0的数。

```c
void
local_infile_end(void *ptr);
```

> 终止函数。该函数在 *local_infile_end()* 返回0或者错误之后调用，只需调用一次。该函数应该回收 *local_infile_init()* 分配的内存以及执行必要的清理工作。哪怕是初始化函数返回错误，该函数也会被调用。

```c
int
local_infile_error(void *ptr,
                   char *error_msg,
                   unsigned int error_msg_len);
```

> 错误处理函数。在任何其他回调函数返回错误的时候，调用该函数以获得一个文本错误信息以返回给用户。 *error_msg* 指向错误信息要被写入的缓存， *error_msg_len* 表示缓存的长度。错误信息应该是一个null结尾字符串，所以最大只能 *error_msg_len-1* 字节长。

> 返回值即为错误码。

> 通常，其他回调函数都会吧错误信息存放在 *ptr* 所指向的数据结构中，从而 *local_infile_error()* 可以将其拷贝到 *error_msg* 。

> 在C代码中调用了 *mysql_set_local_infile_handler()* ，传递了相应指针给回调函数之后，就可以执行 **LOAD DATA LOCAL INFILE** 语句了（例如，使用 *mysql_query()* ）。客户端库会自动调用你的回调函数。 语句 **LOAD DATA LOCAL INFILE** 中指定的文件名将会作为第二个参数传递给回调函数 *local_infile_init()* 。

**返回值**

> 无。

**错误**

> 无。

**22.8.7.65.**  *mysql_set_server_option()*

> *int mysql_set_server_option(MYSQL *mysql, enum enum_mysql_set_option option)*

**描述**

> 开启或者关闭本连接的一个选项。 *option* 参数可取以下值。

<table>
	<tr><th>选项</th><th>描述</th></tr>
	<tr><td>MYSQL_OPTION_MULTI_STATEMENTS_ON</td><td>开启多语句支持</td></tr>
	<tr><td>MYSQL_OPTION_MULTI_STATEMENTS_OFF</td><td>关闭多语句支持</td></tr>
</table>

> 如果开启了多语句支持，在读取 *mysql_query()* 或者 *mysql_real_query()* 执行的结果时，必须循环的调用 *mysql_next_result()* 来确定是否还有未读取的结果集。相关例子请参考 [22.8.17，C API对多语句执行的支持]() 。

> 以 **MYSQL_OPTION_MULTI_STATEMENTS_ON** 的方式开启多语句支持跟传递 **CLIENT_MULTI_STATEMENTS** 给 *mysql_real_connect()* 的方式进行开启的效果不完全一样： **CLIENT_MULTI_STATEMENTS** 同时会开启 **CLIENT_MULTI_RESULTS** 。如果你在程序中使用 **CALL** SQL语句，多结果集支持必须开启；这就意味着要使用 **CALL** ，仅使用 **MYSQL_OPTION_MULTI_STATEMENTS_ON** 的方式时不够的。

**返回值**

> 成功返回0。错误发生时返回非0。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_COM_ERROR

>	服务端不支持 *mysql_set_server_option()* （服务端版本低于4.1.1）或者服务端不支持要设置的选项。

**22.8.7.66.**  *mysql_shutdown()*

> *int mysql_shutdown(MYSQL *mysql, enum mysql_enum_shutdown_level shutdown_level)*

**描述**

> 要求服务端关闭。连接用户必须要有 **SHUTDOWN** 权限。MySQL 5.6仅支持一种类型的关闭； *shutdown_level* 必须为 **SHUTDOWN_DEFAULT** 。有计划增加另外的一些关闭级别以满足这方面的需求。动态链接程序如果是使用老版本的 *libmysqlclient* 库头文件进行的编译，则调用 *mysql_shutdown()* 时必须保证运行时链接的是 *libmysqlclient* 动态库。

> 服务关闭过程请参考 [5.1.12，关闭过程]() 。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.67.**  *mysql_sqlstate()*

> *const char *mysql_sqlstate(MYSQL *mysql)*

**描述**

> 返回一个null结尾字符串，返回最近一次执行的SQL语句的SQLSTATE错误码。该错误吗包含5个字符。’00000‘表示“无错误”。其值由 ANSI SQL以及ODBC定义。详细列表参考 [附录C，错误，错误码以及一般性问题]() 。

> 由 *mysql_sqlstate()* 返回的SQLSTATE值不同于 *mysql_errno()* 返回的特定于MySQL的错误码。例如， *mysql* 客户端程序以下面的格式展示错误信息， *1146* 是 *mysql_errno()* 的返回值，而 ’42S02‘ 是相应的 *mysql_sqlstate()* 返回值：

```bash
shell> SELECT * FROM no_such_table;
ERROR 1146 (42S02): Table 'test.no_such_table' doesn't exist
```

> 不是所有的MySQL错误码都可以映射成SQLSTATE错误码。’ **HY000** ‘（一般性错误）用来表示无法映射的错误码。

> 如果在 *mysql_real_connect()* 失败之后调用 *mysql_sqlstate()* ，可能不会返回有用的值。例如，某主机被服务端所屏蔽，此时连接将会被关闭，而且不会有任何SQLSTATE值被发送给客户端。

**返回值**

> 包含SQLSTATE错误码的null结尾字符串。

**参考**

> 参考 [22.8.7.14，mysql_errno()]() ，[22.8.7.15，mysql_error()]() 以及 [22.8.11.27，mysql_stmt_sqlstate()]() 。

**22.8.7.68.**  *mysql_ssl_set()*

> *my_bool mysql_ssl_set(MYSQL *mysql, const char *key, const char *cert, const char *ca, const char *capath, const char *cipher)*

**描述**

> *mysql_ssl_set()* 使用SSL创建安全连接。必须在 *mysql_real_connect()* 之前调用。

> 客户端库中开启了SSL支持， *mysql_ssl_set()* 调用才有意义，否则它将什么也不干。

> *mysql* 是 *mysql_init()* 调用返回的连接句柄。其他参数定义如下：

> *	*key* 表示密钥文件的路径。

> *	*cert* 表示认证文件的路径。

> *	*ca* 表示证书颁发机构文件的路径。

> *	*capath* 代表一个文件夹的路径。该文件夹中以PEM格式存放可信SSL CA 证书。

> *	*cipher* 表示用于SSL加密的可允许的加密器。

> 不需要的SSL参数可以向其传递 **NULL** 。

**返回值**

> 该函数总是返回0。如果SSL设置不正确，在使用 *mysql_real_connect()* 尝试连接服务端的时候将会返回错误。

**22.8.7.69.**  *mysql_stat()*

> *const char *mysql_stat(MYSQL *mysql)*

**描述**

> 返回一个字符串，该字符串包含的信息类似于 *mysqladmin status* 返回的结果。包含以秒为单位的运行时间，正在运行的线程数，查询数，重载数，打开的表数目等等。

**返回值**

> 描述服务端状态的字符串。错误发生时返回 **NULL** 。

**错误**

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.70.**  *mysql_store_result()*

> *MYSQL_RES *mysql_store_result(MYSQL *mysql)*

**描述**

> 在调用了 *mysql_query()* 或者 *mysql_real_query()* 之后，对于每一个产生了结果集的语句（ **SELECT** ， **SHOW** ， **DESCRIBE** ， **EXPLAIN** ， **CHECK TABLE** 等等），你必须调用 *mysql_store_result()* 或者 *mysql_use_result()* 。在对结果集操作完成之后你还必须调用 *mysql_free_result()* 。

> 对于其他语句，没有必要调用 *mysql_store_result()* 或者 *mysql_use_result()* ，但是如果不管什么语句你都调用 *mysql_store_result()* 也不会造成什么危害或者对性能有显著的影响。可以通过检查 *mysql_store_result()* 是否返回非0值来探测语句是否生成了结果集（详见下文）。

> 如果开启了多语句支持，要读取 *mysql_query()* 或者 *mysql_real_query()* 产生的结果集，你必须循环调用 *mysql_next_result()* 来检查是否还有结果集未读取完毕。相关范例请参考 [22.8.17，C API对多语句执行的支持]() 。

> 如果想知道一条语句是否返回了结果集，可以调用 *mysql_field_count()* 进行检查。参考 [22.8.7.22，mysql_field_count()]() 。

> *mysql_store_result()* 将整个查询的结果集读往客户端，为其分配 **MYSQL_RES** 结构，并且结果集存到该结构中。

> 如果语句不产生结果集， *mysql_store_result()* 返回一个空指针（比如 **INSERT** 语句）。

> 如果读取结构集失败， *mysql_store_result()* 也回返回空指针。可以通过以下方式检查是否出错： *mysql_error()* 是否返回空字符串， *mysql_errno()* 是否返回了非0， *mysql_field_count()* 是否返回了0。

> 如果没有记录，将会返回一个空结果集。（要注意空结果集和空指针是不同。）

> 调用完了 *mysql_store_result()* 如果返回结果不是空指针，此时就可以调用 *mysql_num_rows()* 来获取结果集中记录的数目。

> 调用 *mysql_fetch_row()* 从结果集中读取记录，调用 *mysql_row_tell()* 和 *mysql_row_seek()* 以获得和设置结果集中当前记录的位置。

**返回值**

> 代表结果集的 **MYSQL_RES** 结构。发生错误时返回 **NULL** （0）。

**错误**

> *mysql_store_result()* 调用成功时会重置 *mysql_error()* 和 *mysql_errno()* 。

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> *	CR_OUT_OF_MEMORY

>	内存不足。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.71.**  *mysql_thread_id()*

> *unsigned long mysql_thread_id(MYSQL *mysql)*

**描述**

> 返回当前连接的线程ID。该返回值可以作为参数传递给 *mysql_kill()* 以杀死该线程。

> 如果连接丢失，并且通过了 *mysql_ping()* 进行重连，线程ID将会发生改变。这意味着你不能先获取一个线程ID，存储起来很久之后再使用。而应该是在需要的时候再去获取。


> **注意**

> 如果线程ID超过了32位能表示的范围，该函数的将无法正确工作，这在某些系统上确实会发生。要避免 *mysql_thread_id()* 的问题，最好避免使用它。要获取连接ID，执行 **SELECT CONNECTION_ID()** 查询并读取期结果。

**返回值**

> 当前连接的线程ID。

**错误**

> 无。

**22.8.7.72.**  *mysql_use_result()*

> *MYSQL_RES *mysql_use_result(MYSQL *mysql)*

**描述**

> 在调用了 *mysql_query()* 或者 *mysql_real_query()* 之后，对于每一个产生了结果集的语句（ **SELECT** ， **SHOW** ， **DESCRIBE** ， **EXPLAIN** ， **CHECK TABLE** 等等），你必须调用 *mysql_store_result()* 或者 *mysql_use_result()* 。在对结果集操作完成之后你还必须调用 *mysql_free_result()* 。

> *mysql_use_result()* 初始化结果集读取，但是并不会像 *mysql_store_result()* 一样将结果集读往客户端。相反，必须调用 *mysql_fetch_row()* 来读取每一条单一记录。这一方式不会将结果集存到临时表或者本地缓存，而是直接从服务端读取，这一方式某种情况下会更快，使用的内存也比 *mysql_store_result()* 更少。客户端只对当前记录和通信缓存分配内存（通信缓存的长度不会超过 *max_allowed_packet* 字节）。

> 另外，如果你要在客户端对每一行做大量的处理工作，或者结果是输出到屏幕而且用户可以输入 **^S** （停止滚动），则你就不应该使用 *mysql_use_result()* ，因为它会阻塞服务端，阻止其他线程修改正在被读取的那些表。

> 使用 *mysql_use_result()* 的时候，必须执行 *mysql_fetch_row()* 直到返回 **NULL** ，否则，未读取的记录将会作为下一次查询的结果集返回。如果你忘记了这样做，C API将会给出 *Commands out of sync; you can't run this command now* 这样的错误信息。

> 不能对 *mysql_use_result()* 返回的结果集调用 *mysql_data_seek()* ， *mysql_row_seek()* ， *mysql_row_tell()* ， *mysql_num_rows()* 或者 *mysql_affected_rows()* ，在 *mysql_use_result()* 完成之前也不能执行其他查询。（但是，如果你读取了所有行之后， *mysql_num_rows()* 将返回准确的已读取行数。）

> 一旦对结果集使用完毕，必须调用 *mysql_free_result()* 。

> 如果你使用 *libmysqld* 嵌入式服务程序，这一方式内存方面的好处将显著减少，这是因为随着每一行的读取，内存使用将持续增长直到调用了 *mysql_free_result()* 。

**返回值**

> 表示结果集的 **MYSQL_RES** 结构。发生错误时返回 **NULL** 。

**错误**

> *mysql_use_result()* 调用成功时会重置 *mysql_error()* 和 *mysql_errno()* 。

> * CR_COMMANDS_OUT_OF_SYNC
	
> 	命令执行的顺序不对。

> *	CR_OUT_OF_MEMORY

>	内存不足。

> * CR_SERVER_GONE_ERROR

> 	MySQL连接已断开。
	
> * CR_SERVER_LOST
	
> 	查询期间连接丢失。
	
> * CR_UNKNOWN_ERROR

> 	未知错误。

**22.8.7.73.**  *mysql_warning_count()*

> *unsigned int mysql_warning_count(MYSQL *mysql)*

**描述**

> 返回上一条SQL语句执行过程中产生的错误，警告和提醒的数目。

**返回值**

> 警告数。

**错误**

> 无。