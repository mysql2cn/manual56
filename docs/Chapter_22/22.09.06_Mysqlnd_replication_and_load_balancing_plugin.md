以下章节由[22.9.6. Mysqlnd replication and load balancing plugin (mysqlnd_ms)](http://dev.mysql.com/doc/refman/5.6/en/apis-php-book.mysqlnd-ms.html)翻译而来

### 22.9.6. Mysqlnd 复制与负载均和插件 (mysqlnd_ms)


Mysqlnd复制与负载均衡插件（mysqlnd_ms）向所有使用[mysqlnd](./22.9.5_MySQL_Native_Driver.md)(MySQL原生PHP驱动)的PHP MySQL扩展提供了易用的MySQL复制（replication）特性支持。   

MySQL原生PHP驱动（mysqlnd）为PHP 5.3.3及后续版本设立了一个用于构建内部插件的C语言API。基于C语言构建的插件，如复制与负载均衡插件，具有扩展[MySQL原生驱动](./22.9.5_MySQL_Native_Driver.md)（mysqlnd）功能的能力。   

从PHP 5.3.0开始，MySQL原生PHP驱动作为一个C库以被包含进PHP发行版的方式进行分发。它作为MySQL客户端库（libmysqlclient）的简易替代向外提供服务。使用Mysql原生驱动（mysqlnd）有如下好处：不需要额外的下载环节，mysqlnd与PHP捆绑发行；myslnd受PHP所使用的协议的约束；在某些情况下消耗的内存会更少；包含诸如异步队列等新的功能。   

在多数情况下,像mysqlnd_ms（MySQL原生驱动复制与负载均衡插件）这样的mysqlnd（MySQL原生驱动）插件是对用户透明的.复制与负载均衡差价支持所有PHP程序和所有MySQL PHP扩展。复制与负载均衡差价不更改现有的任何API。所以，它可以非常容易的在现有的PHP程序当总进行使用。   
以下章节为[22.9.6.1. Key Features](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-ms.key-features.html)的翻译

--------

#### [22.9.6.1. 主要特性](#22.9.6.1)


PECL/mysqlnd_ms（PHP扩展社区库/MySQL原生驱动复制与负载均衡插件）的主要特性如下.   

* 透明进而易用。   
    * 支持所有PHP MySQL扩展。 
    * 支持SSL协议。
    * 标准API，具有一致性。
    * 根据使用的情况不，对程序的改动很小或者完全不需要改动程序。
    * 惰性连接：在具体的SQL语句执行前，不建立到数据库的连接(主库和从库)。
    * 可选性：在一个web请求中，执行一次写入操作后，便自动使用主库，以达到减少对复制特性的延迟的可能的影响的目的。
        
* 可以同任何MySQL集群方案（MySQL clustering solution）一同使用。
    * MySQL复制：读写分离是由这个插件完成的。读写分离是这个插件的主要关注点。
    * MySQL集群（MySQL Cluster）：可以禁用读写分离。配置多个主库。
    * 第三方方案：此插件为MySQL复制特性优化过，但是仍然可以与任何其他的MySQL集群方案（MySQL clustering solution）一同使用。 

* 特有的读写分离特性
    * 自动探测SELECT语句。
    * 支持更改SQL的自动分配策略。
    * 用户定义。
    * 在需要的时候可以关闭读写分离，比如使用像MySQL Cluster这样的同步集群时。

* 特有的负载均衡策略
    * 轮循策略（Round Robin）：对于每个对从库的请求，通过轮循的方式选择不同的从库响应。
    * 随机策略：对于每个对从库的请求，随机选择一个从库进行响应。
    * 一次随机策略（粘性）：随机选择一个从库响应某一段时间内的所有来自web的对从库的请求。
    * 用户定义：程序可以对mysqlnd_ms（MySQL原生驱动复制与负载均衡插件）注册回调函数。
    * PHP 5.4.0及后续版本：如果使用API调用来控制事务，能够进行事物感知。
    * 加权负载均衡：可以为不同的服务器赋予不同的权重，比如控制向性能墙的服务器发送更多的请求，向性能弱的服务器发送少的请求。或者向提高逻辑通路更短的服务器的优先级以降低延迟。

* 全局事务ID
    * 客户端模拟(器)。在异步集群中（如应用了MySQL复制特性的集群），更容易的演练主库下线（因故），从库接替主库的过程。
    * 支持从MySQL 5.6.5版本开始引进的内建的全局事务ID（标识符）特性。
    * 当遇到读操作需要保证会话一致性的时候，支持使用事务ID来识别已经完成同步的从库（异步）。
    * 抑制：可选特性，mysqlnd_ms插件能够等待一个从库“同步”完成后在继续其他工作。
    
* 服务等级和一致性水平
    * 对于程序中的连接,会自动搜索集群中合适的节点进行响应。会话的完整性和强一致性有保证。
    * 满足最终一致性要求的从库（应用了MySQL复制特性）访问能够被快速本地缓存访问替代，可以显著的降低服务器负载。
 
* 分区和分片 
    * 在应用了复制特性的集群中的服务器能够被组织成若干分组。 MySQL提示（SQL hints）特性可以被用来手动分发查询（queries）到特定的组。分株特性可以用来将数据分组（或分片），或者解决由更新带来的与热点有关的问题。
    * MySQL复制特性过滤器通过表过滤器进行支持.
以下章节由[22.9.6.2. Limitations](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-ms.limitations.html)翻译而来

------

#### [22.9.6.2. 局限](#22.9.6.2)


内建的读写分离机制比较基础。每个由SELECT开始的查询都被视为一次读请求被分发至MySQL从库服务器。其他的所有查询（如SHOW语句）都被视为写请求被分发至MySQL主库服务器。内建的机制使用[SQL提示](#22.9.6.7)（SQL hints），或者用户定义的[回调函数](#E22.282)进行覆盖。


读写分离器不具备多重语句感知能力。多重语句被视为一个语句。语句在何地运行的决策是基于语句首进行判定的。比如说，如果使用使用[mysqli_multi_query](./22.9.3.9_The_mysqli_class.md#22.9.3.9.34)函数来执行一个多重语句 ``` SELECT id FROM test ; INSERT INTO test(id) VALUES (1)``` ，因为其以SELECT开头故语句将被分发到从库服务器。多重语句的后半部分，INSERT语句将不会被分发至主库服务器。

> **注意**   

>程序必须感知到出于负载均衡为目的的链接切换结果。请查看关于[连接池与切换](#22.9.6.5.2)，[事务处理](#22.9.6.5.3)，[故障转移负载均衡](#22.9.6.5.6)和[读写分离](＃22.9.6.5.8)的相关文档.
以下章节由[22.9.6.3. On the name](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-ms.name.html)翻译而来

#### [22.9.6.3. 插件名由来](#22.9.6.3)

Mysqlnd_ms是MySQL原生驱动主从插件（mysqlnd master slave plugin）的简称。这个名字起的很“短平快”。在项目开始的时候该项目的开发者们不想使用代码风格的命名方式来命名这个项目。
以下章节由[22.9.6.4. Quickstart and Examples](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-ms.quickstart.html)翻译而来

------

#### [22.9.6.4. 快速入门与实例](#22.9.6.4)

Mysqlnd复制与负载均衡插件很方便使用。本节快速入门将向您演示一些典型的应用案例，并向您提供一些使用该插件的实际建议。   

除了快速入门手册外，我们强烈建议您阅读参考部分的章节。本快速入门手册尽量避免讨论理论概念和插件的局限。在参考部分的章节我们会具体探讨这些事宜。从快速入门手册开始了解本插件是件不错的事情。然而，在将插件应用在生产环境（或其他的重要环境）之前，我们强烈建议您先阅读参考部分章节以获得足够的背景知识。 

本章重点关注如何在一个异步的MySQL集群（及MySQL复制主从集群）上使用PECL/mysqlnd_ms。一般来说一个异步集群要比一个同步集群更难使用与维护。比如说，维护MySQL集群（MySQL Cluster）需要获取比需要的更多的信息。

##### [22.9.6.4.1. 设置](#22.9.6.4.1)

Mysqlnd_ms是以作为PHP扩展的形式实现的。另请参阅[安装说明](#22.9.6.6.2)中的相关章节来安装[PECL/mysqlnd_ms](http://pecl.php.net/package/mysqlnd_ms)扩展。

首先，编译或配置你计划与mysqlnd库一起使用的PHP MySQL扩展（API）（[mysqli](./22.9.3_MySQL_Improved_Extension.md#22.9.3.15)，[PDO_MYSQL](./22.9.4_MySQL_Functions.md)，[mysql](./22.9.2_Original_MySQL_API.md#22.9.2.5)）。PECL/mysqlnd_ms是mysqlnd库的一个插件。如果想要跟其他的PHP MySQL扩展一块使用，该插件必须要使用mysqlnd库。

然后，讲扩展加载进PHP并且在PHP配置文件中激活该扩展，激活相关的命令为：mysqlnd_ms.enable。

[ **示例 22.215. 使插件生效 (php.ini)** ](#e22.215)

```
mysqlnd_ms.enable=1
mysqlnd_ms.config_file=/path/to/mysqlnd_ms_plugin.ini
```

该插件使用自己的配置文件，使用PHP配置参数项[mysqlnd_ms.config_file](#22.9.6.6.3)来指定插件的配置文件路径。这个文件必须对PHP运行用户（如，运行web服务器的用户，apache，www，nobody等）是可读的。请注意，从mysqlnd_ms 1.4.0开始，需要使用[mysqlnd_ms.config_file](#22.9.6.6.3) 这个配置项代替原有的配置项[mysqlnd_ms.ini_file](＃22.9.6.6.3)。仍然使用旧的配置项名称是一个常见的错误.   

生成插件配置文件，然后在mysql配置文件中使用配置项[mysqlnd_ms.config_file](#22.9.6.6.3)指定该配置文件的路径。   

mysqlnd_ms插件配置文件是基于JSON格式的。配置文件可被区块化。每个区块有其自己的名称，如 myapp。每个区块都可以独立设置自己的参数及参数值。   

一个区块之少要包含MySQL 主库服务器地址（MySQL replication master server），和从库的地址列表。该插件支持每个区块只用一个主库。多主库的MySQL replication集群配置没有不能够得到完全支持。在配置文件中需要指定主库的主机名（hostname），主库的端口号或者socket地址。指定从库的从库关键字（slave keyword）。

[ **示例 22.216. mysqlnd_ms最简配置文件（mysqlnd_ms_plugin.ini）** ](#e22.216)

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost"
            }
        },
        "slave": [

        ]
    }
}
```
在配置文件中，MySQL从库地址列表选项必须存在，列表可以为空。推荐至少设置一个从库。你可以给服务器列表起一个名字，也可以不这么作。没有名字的服务器列表包含服务器的别名，如：本示例中的master_0为主库master的别名。快速入门手册中使用更加详细的无名字示例。

[ **示例 22.217. 推荐的最简配置文件（mysqlnd_ms_plugin.ini）** ](#e22.217)

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
```


在至少配置文件中至少包含两个服务器时，mysqlnd_ms插件便可以启用负载均衡机制和切换链接（switch connections）机制。切换链接机制并不总是透明的，在一些特定的情况下能够引发一些问题。关于[连接池与切换](#2.6.9.5.2)，[事务处理](2.6.9.5.3)，[故障转移（fail over）负载均衡](2.6.9.5.6)，[读写分离](2.6.9.5.8)章节会有详细的说明。其他的潜在隐患也会在稍后说明。   

通过配置至少一主一从的服务器，使切换连接特性生效，进而可以发现相关问题的，来达到应对可能由连接切换引发的潜在问题之目的，是一种负责的表现。

您配置的MySQL主库和MySQL从库，并不一定需要成为MySQL复制特性（MySQL replication）设置的一部分。出于测试的目的，你可以仅使用一台MySQL服务器，在配置文件中将其设置为主库或从库，详见下例。这样设置可以帮助你定位很多可能由连接切换所引发的潜在问题。然而，这样设置容易遇到由复制延迟所引发的相关问题。

[ **示例 22.218. 仅使用一台服务器（设为主库或从库）(仅作测试使用!)** ](#e22.218)

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
```

插件会尝试提示你次设置文件无效。从1.5.0版本开始，如果配置文件不可读，为空或JSON解析失败，会在PHP启动阶段突出一个警告。根据你的相关设置情况，这个警告也可能仅出现在日志文件中。当连接初始化完毕并且能够在设置中找到有效的区块后，进一步的验证便会完成。变更mysqlnd_ms.force_config_usage设置项可以帮助你找到有问题的设置。请参见：[]配置文件调试指南](#22.9.6.6)。

##### [**22.9.6.4.2. 运行语句**](#22.9.6.4.2)

该插件可以与任何使用mysqlnd库的PHP MySQL扩展（mysqli，mysql，和PDO_MYSQL）一同使用。PECL/mysqlnd_ms直接与mysqlnd库对接。它并不改变上述扩展的API或使用方法。

当一个到MySQL的连接被建立时，该扩展比这个连接调用的主机名参数的值和配置文件中的区块名称作比较。比如，配置文件中有一个名为myapp的区块，那么将按照这个区块的设置与相应的主机建立连接。

[**示例 22.219. mysqlnd_ms插件配置文件（mysqlnd_ms_plugin.ini）**](#e22.219)

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.220. 打开一个负载均衡连接**](#e22.220)

```php
<?php
/* Load balanced following "myapp" section rules from the plugins config file */
/* 应用myapp区块配置的负载均衡连接 */
$mysqli = new mysqli("myapp", "username", "password", "database");
$pdo = new PDO('mysql:host=myapp;dbname=database', 'username', 'password');
$mysql = mysql_connect("myapp", "username", "password");
?>
```

上面的连接示例会建立负载均衡连接。插件会将被判定为读的语句分发到IP为192.168.2.27的MySQL从库，并且开始为MySQL客户端连接监听3306端口。所有被判定为非读的语句会被分发到在本主机（localhost）上面运行的MySQL主库上面。如果使用的是类UNIX操作系统，在本主机（localhost）运行的主库服务会开始接受建立在UNIX socket /tmp/mysql.sock 上面的MySQL客户端连接，而使用TCP/IP协议进行连接是Windows主机的默认方法。插件会使用‘username’作为用户名，使用‘password‘作为密码来与配置文件中myapp区块中列出的MySQL服务器进行连接。连接后插件会选择使用’database‘库作为当前库。

用户名，密码和库名，将从连接API调用的相关参数中取出，并且在所有服务器上面使用。也就是说，你必须在配置文件的一个区块所列的所有MySQL服务器上面使用相同的用户名和密码。在 PECL/mysqlnd_ms 1.1.0中，允许在配置文件中为每一台服务器指定用户名和密码，这些用户名密码将用来在API调用时进行验证。

在运行语句时，插件并不更改API。读写分离“开箱即用”。假设主库和从库之间没有大的复制延迟的情况下，请看下面的例子。

[**示例 22.221. 执行语句**](#e22.221)

```php

<?php
/* Load balanced following "myapp" section rules from the plugins config file */
/* 应用myapp区块配置的负载均衡连接 */
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Statements will be run on the master */
/* 语句将在主库上执行 */
if (!$mysqli->query("DROP TABLE IF EXISTS test")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("CREATE TABLE test(id INT)")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* read-only: statement will be run on a slave */
/* 仅有读操作的语句: 语句将在从库上执行 */
if (!($res = $mysqli->query("SELECT id FROM test")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("Slave returns id = '%s'\n", $row['id'];
}
$mysqli->close();
?>
```

上例的输出将类似与下面这样:

Slave returns id = '1'

##### [**22.9.6.4.3. 连接状态**](#22.9.6.4.3)

该插件更改了PHP MySQL 连接句柄的语义处理机制。新的连接处理机制相当于一个连接池，而不是一个单独的MySQL客户端网络连接。一个连接池包括一个主库连接，和任意多的可选的从库连接。

连接池中的每个连接都有它自己的状态。比如说，SQL 用户变量（user variable），临时表，事物等，都是状态的一部分。上面提及的都那些项目隶属于连接状态，请参见[连接池与切换相关概念]()文档，如果出于负载均衡角度考虑，插件想要切换连接，那么程序将被分配一个拥有着不同状态的连接。必须告知程序让其知晓相关变更。

[**示例 22.222. 一主一从的配置文件**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.223. 隐患：连接状态和SQL用户变量]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connection 1, connection bound SQL user variable, no SELECT thus run on master */
/* 连接1，用SQL用户变量绑定连接，没有SELECT查询会跑在主库上面 */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connection 2, run on slave because SELECT */
/* 连接2,SELECT查询会在从库上运行 */
if (!($res = $mysqli->query("SELECT @myrole AS _role"))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
```
    
上例输出:

@myrole = ''

上例会建立一个负载均衡连接并且执行两个语句。第一个语句```SET @myrole='master'```不是以SELECT关键字开头的.所以插件没有将其判定为一个只读查询（只读查询会在从库上运行）.插件将这个语句分配到主库运行。该语句设置了一个绑定在主库连接上用户变量。主库的连接状态已经被改变。

第二个语句是```SELECT @myrole AS _role```。插件将其判定为一个只读查询。所以语句会在从库上执行。这个连接没有与任何SQL用户变量进行绑定。它与第一个主库连接相比有着不同的连接状态。SQL用户请求变量（The requested SQL user variable）没有被设置。示例脚本输出：

@myrole = ''.

对于成寻开发者来说，关注连接状态是一种尽责的表现。Mysqlnd_ms插件并不监控所有的连接状态行为。监控所有的可能情形是很耗费CPU资源，也是几乎不可实现的。

The pitfalls can easily be worked around using SQL hints.

使用SQL提示（SQL hints）很容易解决这些隐患问题。

##### [**22.9.6.4.4. SQL提示（SQL Hints）**](#22.9.6.4.4)

SQL提示可以强制一个查询使用连接池中的特定服务器。它会发给插件一个使用特定服务器的提示，这可以解决由连接切换和连接状态所引发的问题。

SQL hint是符合标准的SQL注释。因为SQL注释应该被SQL处理系统忽略，他们不干涉其他的程序，如MySQL服务器程序，MySQL代理程序，或者防火墙。

Mysqlnd_ms支持三种SQL hint：MYSQLND_MS_MASTER_SWITCH hint会让插件在主库上面执行一个语句。MYSQLND_MS_SLAVE_SWITCH 会让语句强制使用从库。MYSQLND_MS_LAST_USED_SWITCH 会让语句运行在上一条语句运行的库上。

The plugin scans the beginning of a statement for the existence of an SQL hint. SQL hints are only recognized if they appear at the beginning of the statement.

Mysqlnd_ms插件会扫描语的开头部分，来确定SQL hint是否存在。只有SQL hint出现在语句开头的位置时，他们才能够被识别到。

[**示例 22.224. 一主一从配置文件**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.225. 使用SQL hint防止连接切换**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (mysqli_connect_errno())
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Connection 1, connection bound SQL user variable, no SELECT thus run on master */
/* 连接1，连接绑定SQL用户变量，无SELECT语句会运行在主库上 */
if (!$mysqli->query("SET @myrole='master'")) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}

/* Connection 1, run on master because of SQL hint */
/* 连接1，由于SQL hint 的作用会运行在主库上*/
if (!($res = $mysqli->query(sprintf("/*%s*/SELECT @myrole AS _role", MYSQLND_MS_LAST_USED_SWITCH)))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
} else {
 $row = $res->fetch_assoc();
 $res->close();
 printf("@myrole = '%s'\n", $row['_role']);
}
$mysqli->close();
?>
```
    
上例输出：

@myrole = 'master'


在上例中，当SELECT语句运行时，我们使用MYSQLND_MS_LAST_USED_SWITCH 来避免会话从主库切换到从库上面。

SQL hint也可以被用来强制使SELECT语句运行在主库上。 当MySQL从库长时间无法同步主库完成的但是你仍然需要获取集群中存储的最近的信息的时候，这个特性就会变得很有用。

Mysqlnd_ms 1.2.0 为了应对当前数据需要被获取的案例，进而引入了服务水平的概念。使用服务等级，你就可以投入更少的经历，并且不在需要使用SQL hint来应对对应的应用案例。请阅读[服务等级和一致性]()章节获取更多信息。

[**示例 22.226. 对抗复制延迟**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Force use of master, master has always fresh and current data */
/* 强制使用主库，主库总是刷新并且提供当前数据 */
if (!$mysqli->query(sprintf("/*%s*/SELECT critical_data FROM important_table", MYSQLND_MS_MASTER_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
?>
```

另外一个应用SQL hint的案例是可以在从库上创建表。如果没有给出SQL hint的话，mysqlnd_ms插件会将CREATE和INSERT语句分发到主库上去。使用MYSQLND_MS_SLAVE_SWITCH这个SQL hint可以将他们分发到从库上面，例如构建一些临时报告用表。

[**示例 22.227. 在从库上创建表**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Force use of slave */
/* 强制使用从库 */
if (!$mysqli->query(sprintf("/*%s*/CREATE TABLE slave_reporting(id INT)", MYSQLND_MS_SLAVE_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* Continue using this particular slave connection */
/* 继续使用特定从库连接 */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO slave_reporting(id) VALUES (1), (2), (3)", MYSQLND_MS_LAST_USED_SWITCH))) {
 printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
/* Don't use MYSQLND_MS_SLAVE_SWITCH which would allow switching to another slave! */
if ($res = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM slave_reporting", MYSQLND_MS_LAST_USED_SWITCH))) {
  $row = $res->fetch_assoc();
  $res->close();
  printf("There are %d rows in the table 'slave_reporting'", $row['_num']);
} else {
  printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
}
$mysqli->close();
?>
```

The SQL hint MYSQLND_MS_LAST_USED forbids switching a connection, and forces use of the previously used connection.

SQL hint MYSQLND_MS_LAST_USED会禁止连接的却换,并且强制使用之前使用的连接。

##### [**22.9.6.4.5. 事务**](＃22.9.6.4.5)

当前版本的mysqlnd_ms插件默认上并不是事务安全的。因为它并不能感知所有应用案例中的运行事务。SQL事务是在SQL服务器上面工作的基本单元。Mysqlnd_ms插件并不总能知晓事务何时开始，何时结束。所以，插件可能在事务执行的过程中决定切换连接。

没有任何一种MySQL负载均衡器能够在不从程序获取任何提示的情况下探测到事务的边界。

You can either use SQL hints to work around this limitation. Alternatively, you can activate transaction API call monitoring. In the latter case you must use API calls only to control transactions, see below.

应对这个局限的方法之一是使用SQL hint，你也可以激活事务API调用监控。下面的例子中，你必须使用API调用来控制事务，见下。

[**示例 22.228. 一主一丛配置**]()

```json
[myapp]
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "192.168.2.27",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.229. 对事务应用SQL hint**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));
  
/* Not a SELECT, will use master */
/* 非SELECT,在主库运行 */
if (!$mysqli->query("START TRANSACTION")) {
 /* Please use better error handling in your code */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Prevent connection switch! */
/* 防止连接切换！ */
if (!$mysqli->query(sprintf("/*%s*/INSERT INTO test(id) VALUES (1)", MYSQLND_MS_LAST_USED_SWITCH)))) {
 /* Please do proper ROLLBACK in your code, don't just die */
 /* 请在你的代码中作适当的回滚操作，不要直接调用die */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if ($res = $mysqli->query(sprintf("/*%s*/SELECT COUNT(*) AS _num FROM test", MYSQLND_MS_LAST_USED_SWITCH)))) {
  $row = $res->fetch_assoc();
  $res->close();
  if ($row['_num'] > 1000) {
   if (!$mysqli->query(sprintf("/*%s*/INSERT INTO events(task) VALUES ('cleanup')", MYSQLND_MS_LAST_USED_SWITCH)))) {
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
   }
  }
} else {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/UPDATE log SET last_update = NOW()", MYSQLND_MS_LAST_USED_SWITCH)))) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query(sprintf("/*%s*/COMMIT", MYSQLND_MS_LAST_USED_SWITCH)))) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

$mysqli->close();
?>
```

从PHP 5.4.0开始，如果autocommit模式被API调用设置，而不是被SQL语句设置（比如说，SET AUTOCOMMIT=0 ）的话，mysqlnd库允许插件监控autocommit模式的状态。

如果使用PHP 5.4.0 及以后版本，API调用启用autocommit模式，当在配置文件中有trx_stickiness=master这个设置时，插件会自动禁用负载均衡并和SQL事务的连接切换。如果这样配置，插件会停止负载均衡并将所有语句分发到主库。这样可以防止在一个事务运行时连接切换，一旦autocommit重新开启，负载均衡便再次开启。

API based transaction boundary detection has been improved with PHP 5.5.0 and PECL/mysqlnd_ms 1.5.0 to cover not only calls to mysqli_autocommit but also mysqli_begin, mysqli_commit and mysqli_rollback.

基于API的事务边界探测在PHP 5.5.0及后续版本中得到了加强。PECL/mysqlnd_ms 1.5.0不仅仅可以支持mysqli_autocommit，同样也可以支持mysqli_begin，mysqli_commit和mysqli_rollback。

[**示例 22.230. 事务感知负载均衡：trx_stickiness设置**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "trx_stickiness": "master"
    }
}
```

[**示例 22.231. 事务感知**]()

```
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Disable autocommit, plugin will run all statements on the master */
/* 禁用autocommit，插件会将所有语句都分发到主库运行 */
$mysqli->autocommit(FALSE);

if (!$mysqli->query("INSERT INTO test(id) VALUES (1)")) {
 /* Please do proper ROLLBACK in your code, don't just die */
 /* 请在你的代码中作适当的回滚操作，不要直接调用die */
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if ($res = $mysqli->query("SELECT COUNT(*) AS _num FROM test")) {
  $row = $res->fetch_assoc();
  $res->close();
  if ($row['_num'] > 1000) {
   if (!$mysqli->query("INSERT INTO events(task) VALUES ('cleanup')")) {
     die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
   }
  }
} else {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->query("UPDATE log SET last_update = NOW()")) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}
if (!$mysqli->commit()) {
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Plugin assumes that the transaction has ended and starts load balancing again */
/* 插件假设事务已经完成并重新开始负载均衡 */
$mysqli->autocommit(TRUE);
$mysqli->close();
?>
```

>版本要求

>插件的配置项trx_stickiness=master 需要PHP 5.4.0 及后续版本。

请查看事务助理相关概念章节的限制概述（restrictions outlined）部分。

##### [22.9.6.4.6. 服务水平及一致性](#22.9.6.4.6)

>版本要求

>服务水平在PECL/mysqlnd_ms 1.2.0-alpha版本被引进。mysqlnd_ms_qos 在PHP 5.4.0 及后续版本中可用。

不同种类的MySQL集群方案向用户提供不同的数据和一致性水平。一个异步的MySQL复制集群（MySQL replication cluster）默认就能保证最终一致性。一个运行在异步集群从库上的读请求操作，根据从库与主库的同步状态不同，可能会返回当前的数据，旧数据，或者什么都不返回。

使用MySQL复制集群的应用程序需要被设计成能够正确的处理最终一致性数据。然而，在一些案例中旧数据是不能够接受的。在那些案例中，为了让集群能够向外提供达标的服务质量，只有特定的从库甚至只有主库被允许访问。

As of PECL mysqlnd_ms 1.2.0 the plugin is capable of selecting MySQL replication nodes automatically that deliver session consistency or strong consistency. Session consistency means that one client can read its writes. Other clients may or may not see the clients' write. Strong consistency means that all clients will see all writes from the client.

从PECL/mysql_ms 1.2.0版本开始，插件已经有了能够正确大自动选择能够提供会话一致性或强一致性的MySQL复制集群节点的能力。会话一致性的意思是，一个客户端可以正确读出它写入的数据。其他客户端可能有可能能读取到他的写入，也有可能读取不到他的写入。强一致性的意思是，所有客户端都可以正确读取某个客户端的所有写入的数据。

[**示例 22.232. 会话一致性：读出写入的数据**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.233. 会话一致性需求**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* read-write splitting: master used */
/* 读写分离：使用主库 */
if (!$mysqli->query("INSERT INTO orders(order_id, item) VALUES (1, 'christmas tree, 1.8m')")) {
   /* Please use better error handling in your code */
   /* 请在你的代码中作适当的回滚操作，不要直接调用die */
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Request session consistency: read your writes */
/* 需要保证会话一致性：读出写入的数据 */    
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks a node which has the changes, here: master */
/* 插件挑选一个包含数据变更的节点，本例中为主库节点 */
if (!$res = $mysqli->query("SELECT item FROM orders WHERE order_id = 1"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

var_dump($res->fetch_assoc());

/* Back to eventual consistency: stale data allowed */
/* 回到最终一致性：允许旧数据 */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks any slave, stale data is allowed */
/* 插件选择任何一个从库，允许旧数据 */
if (!$res = $mysqli->query("SELECT item, price FROM specials"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
```

服务水平可以在插件的配置文件中，或者运行时阶段使用mysqlnd_ms_set_qos参数进行设置。在上面例子中，这个功能被用来确保未来所有语句的会话一致性（读出你的写入），知道配置变更。对orders表的SELECT查询语句会运行在从库上，从而保证之前的所有写入可以被客户端读取。读写分离逻辑会作适当的更改以满足服务水平要求。


在应用程序读取到它对orders表所做的变更的那部分数据之后，他会回到默认的服务水平：最终一致性。最终一致性在选择阶段运行语句方面没有任何限制。所以，对specials表的SELECT查询语句会在从库上运行。

The new functionality supersedes the use of SQL hints and the master_on_write configuration option. In many cases mysqlnd_ms_set_qos is easier to use, more powerful improves portability.

这个新功能取代了SQL hint和master_on_write配置选项。在许多案例中，mysqlnd_ms_qos都更易用,也会大大改善代码的可移植性。

[**示例 22.234. Maximum age/slave lag**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "failover" : "master"
    }
}
```

[**示例 22.235. 限制slave lag**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Read from slaves lagging no more than four seconds */
/* 如果与主库的延迟不超过4秒，则从从库读取数据 */
$ret = mysqlnd_ms_set_qos($mysqli,
         MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
         MYSQLND_MS_QOS_OPTION_AGE, 4);

if (!$ret)
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks any slave, which may or may not have the changes */
/* 插件任意挑选一个从库，这个从库有可能包含刚刚变更的数据，也有可能不包含 */
if (!$res = $mysqli->query("SELECT item, price FROM daytrade"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));


/* Back to default: use of all slaves and masters permitted */
/* 回到默认设置：所有主库和从库都可以使用 */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
```

最终一致性服务水平可以与一个可选的参数一同使用，这个参数可以设置在选择从库的时候最大的从库延迟。如果这个参数被设置了，插件会检查所有的从库的SHOW SLAVE STATUS结果。在上面例子中，之后状态为Slave_IO_Running=Yes，Slave_SQL_Running=Yes且Seconds_Behind_Master <= 4的从库会被考虑用来运行从表daytrade中查询项目的SELECT查询语句。



对于应用程序来说，检查SHOW SLAVE STATUS结果的这个过程是透明的。如果出现错误，这些错误会被当成警告吐出。连接句柄被设置为没有错误。及时所有的SHOW SLAVE STATUS语句（这些语句都是由插件执行的）都执行失败，用户语句的执行也不会停止，假设主库的故障转移已经启动。所以，不需要对程序代码进行更改。

>**大开销及低效的操作**   
>在所有从库上检查SHOW SLAVE STATUS的输出结果会增加应用程序的开销。它是一种打开小，效率低的操作。请尽量少的使用这种操作。很遗憾的是，一个MySQL复制集群不会向客户端提供从中央实例上请求一个候选列表的可能性。所以一种更加高效的检查从库延迟的方法行不通了。
>
> 请进一步查看MySQL手册中的解释关于SHOW SLAVE STATUS 的局限和特性的相关章节


为了避免mysql_ms插件在没有满足条件的从库（从库与主库延迟小于设定的时间）能被找到时吐出警告，我们应该在插件配置文件中设置主库的故障转移。如果没有从库能够被使用并且故障转移被打开的话，插件会选择一个主库来执行语句。


如果没有从库能够被使用，并且故障转移被关闭了，插件会吐出一个警告，语句不会被执行，并且会产生一个连接错误。

[**示例 22.236. 故障转移未被设置**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        }
    }
}
```

[**示例 22.237. 没有能满足时间限制的从库**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* Read from slaves lagging no more than four seconds */
/* 从延迟不大于4秒的从库读取数据 */
$ret = mysqlnd_ms_set_qos($mysqli,
         MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL,
         MYSQLND_MS_QOS_OPTION_AGE, 4);

if (!$ret)
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Plugin picks any slave, which may or may not have the changes */
/* 插件任意挑选一个从库，这个从库有可能包含刚刚变更的数据，也有可能不包含 */
if (!$res = $mysqli->query("SELECT item, price FROM daytrade"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));


/* Back to default: use of all slaves and masters permitted */
/* 回到默认设置：所有主库和从库都可以使用 */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
?>
```
    
上例输出：

```php
PHP Warning:  mysqli::query(): (mysqlnd_ms) Couldn't find the appropriate slave connection. 0 slaves to choose from. Something is wrong in %s on line %d
PHP Warning:  mysqli::query(): (mysqlnd_ms) No connection selected by the last filter in %s on line %d
[2000] (mysqlnd_ms) No connection selected by the last filter
```

##### [22.9.6.4.7. 全局事务ID（Global transaction IDs）](#22.9.6.4.7)

>**版本要求**
>客户端全局事务ID（client-side global transaction ID）mysqlnd_ms 1.2.0-alpha版本被引进。这个特性不依赖于同步集群，比如说：MySQL Cluster。你可以在MySQL异步集群（如传统的MySQL replication）上使用它。
>
>从MySQL 5.6.5-m8版本开始，MySQL开始内建全局事务标识符（global transaction identifiers）。从PECL/mysqlnd_ms 1.3.0-alpha版本开始支持全局事务ID。

PECL/mysqlnd_ms 亦可以使用自己的全局事务ID模拟器或者使用MySQL内建的GTID（MySQL 5.6.5-m8及后续版本）。从开发者的角度来看，客户端端GTID和服务器GTID基本可以PECL/mysqlnd_ms提供相同的特性，和一样的服务水平.他们的区别将在概念章节作具体讨论。


在演示怎样使用服务器端GTID之前,快速入门手册中首先演示PECL/mysqlnd_ms内建的客户端全局事务ID模拟器.这么做得目的是为了确保我们会首先讨论一些基本概念。

概念和客户端端模拟器

全局事务ID（GTID）本质上来讲是主库上的一个表上的一个计数器。每当有一个事务在主库上被提交，这个计数器便增加一次。从库会复制这个表。这个计数器有两个目的。一旦主库故障，它可以帮助数据库管理员来识别同步率最高的从库成为新的主库。同步率最高的从库就是计数器数值最大的那个。应用程序可以利用全局事务ID来查找那些从库已经复制了某些写操作）（由全局事务ID识别）。


PECL/mysqlnd_ms可以为每个提交的事务注入SQL语句，用来让GTID计数器数值增长。对于一个想要识别一个应用程序写操作的应用程序来说，GTID是可读的。这可以让插件通过查询主库和已经复制了更改的从库从而向外交付会话一致性（读出你的写入）的服务水平，

客户端端的全局事务ID模拟器有着一些局限。在将其应用在生产环境之前，请仔细阅读概念章节，以彻底理解其背后的原则和理念。在不需要充分了解那些背景知识的前提下，你仍然可以继续阅读快速入门手册。

首先，在你的主库上面创建一个计数器表并且插入一条记录。插件并不会自动建立这个表的。数据库管理员必须手动确保表的存在。根据错误报告模式的不同，插件有可能直接静默忽略此表的缺失，或者bail out。

[**示例 22.238. 在主库上面建立数据库表**]()

```sql
CREATE TABLE `trx` (
  `trx_id` int(11) DEFAULT NULL,
  `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=latin1
INSERT INTO `trx`(`trx_id`) VALUES (1);
```

在插件配置文件中，设置一个SQL来是使用global_transaction_id_injection会话的on_commit更新全局事务ID表。请检查UPDATE语句中的表名，确保表明没有问题。在本例中,test.trx 被用来指向test库的trx表。使用上一步刚刚建立的表。使用表的全名是十分重要的，因为执行注入的连接可能使用的一个其他的默认的数据库。请保证用来打开会话的用户是允许执行UPDATE语句的。

当mysqlnd_ms执行全局事务ID注入时候，有可能会自动开启错误汇报。

[**示例 22.239. 插件配置：SQL 客户端端GTID注入**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "report_error":true
        }
    }
}
```

[**示例 22.240. 全局事务ID注入**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("DROP TABLE IF EXISTS test"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("CREATE TABLE test(id INT)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* auto commit mode, read on slave, no increment */
/* auto commit模式，从从库上读， GTID不增长*/
if (!($res = $mysqli->query("SELECT id FROM test")))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

var_dump($res->fetch_assoc());
?>
```
    

上例输出：

```
array(1) {
  ["id"]=>
  string(1) "1"
}
```

上例在主库上以auto commit模式执行三个语句，引发主库上的三个事务。对于每个语句来说，插件会在用户的SQL语句之前注入一个定义好的UPDATE语句。当脚本结束时，在主库上的全局事务ID计数器已经增长3次。

例子中执行的第四个SQL语句，一个SELECT语句，并不触发增长。只有落（写在）在主库上的事务会使GTID计数器数值增长。

>**全局事务ID SQL：高效方案征集**
>客户端端全局事务ID模拟器使用的SQL是低效的。它是为了表述清晰优化的，而不是为性能优化的。请不要在生产环境使用。请帮助我们寻找更高效的方案。我们十分感谢您的贡献。

[**示例 22.241. 插件配置: 抓取GTID的SQL**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "report_error":true
        }
    }
}
```

[**示例 22.242. 在注入后获取GTID**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("DROP TABLE IF EXISTS test"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

printf("GTID after transaction %s\n", mysqlnd_ms_get_last_gtid($mysqli));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("CREATE TABLE test(id INT)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

printf("GTID after transaction %s\n", mysqlnd_ms_get_last_gtid($mysqli));
?>
```
    
上例输出：

```
GTID after transaction 7
GTID after transaction 8
```

应用程序可以询问PECL/mysqlnd_ms 插件该应用程序最后一次执行的写操作的全局事务ID是多少。方法mysqlnd_ms_get_last_gtid返回一个GTID，插件的配置文件有一个章节是global_transaction_id_injection，这个章节当中有一个条目是当运行SQL语句从fetch_last_gtid，这个条目的内容是一个SQL语句，方法mysqlnd_ms_get_last_gtid就返回执行这个语句获得到的GTID。

不建议应用程序运行SQL语句本身，因为着可能引起一个潜在的风险，就是会误增加GTID。同时，如果方法被使用，程序迁移也会很容易，比如，可以迁移到内建MySQL全局事务ID特性的MySQL服务器。

本快速入门手册展示了一个将会返回等于或大于之前的语句执行后的结果的GTID的语句。在语句执行和SELECT语句获得GTID之间的这个时间段，如果没有其他客户端请求使GTID增长，那么此GTID就是之前的语句导致的那个GTID。不然的话，GTID的数值应该变大。

[**示例 22.243. 插件配置：检视某GTID**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "on_commit":"UPDATE test.trx SET trx_id = trx_id + 1",
            "fetch_last_gtid" : "SELECT MAX(trx_id) FROM test.trx",
            "check_for_gtid" : "SELECT trx_id FROM test.trx WHERE trx_id >= #GTID",
            "report_error":true
        }
    }
}
```

[**示例 22.244. 会话一致性服务水平和GTID聚合（combined）**](http://)

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* auto commit mode, transaction on master, GTID must be incremented */
/* auto commit模式，事务落在主库上， GTID增长*/
if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* GTID as an identifier for the last write */
/* GTID 相当于最后写入的表示符 */
$gtid = mysqlnd_ms_get_last_gtid($mysqli);

/* Session consistency (read your writes): try to read from slaves not only master */
/* 会话一致性（读出你的写入）：尝试从从库和主库读 */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION, MYSQLND_MS_QOS_OPTION_GTID, $gtid)) {
    die(sprintf("[006] [%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Either run on master or a slave which has replicated the INSERT */
/* 在主库或者已经复制了这个INSERT的从库上面运行  */
if (!($res = $mysqli->query("SELECT id FROM test"))) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

var_dump($res->fetch_assoc());
?>
```

Mysqlnd_ms_get_last_gtid返回的GTID可以被用来当作会话一致性水平的一个选项.会话一致性的交付是要满足读出你的写入这个要求.会话一致性可以通过调用mysqlnd_ms_set_qos来请求。在本例中，插件会在主库或者已经复制了之前的INSERT操作的从库上执行SELECT语句。

PECL/mysqlnd_ms插件将透明的检查所有的在配置当中的从库，通过检查从库上面的GTID表，来查看其是否已经复制了直线的INSERT操作。插件配置文件里面有一个章节是global_transaction_id_injection，该章节里面有一个选项为check_for_gtid，上面的那个检查过程就是通过运行check_for_gtid选项配置的SQL来完成的。请注意，这是一个慢并且大开销的程序。应用程序可以通过减少使用他的次数或者只从主库当中读（除非主控的读负载很高）。

服务器端全局事务ID特性的使用

从MySQL 5.6.5-m8 开始，MySQL复制系统（MySQL Replication system）引入了服务器端全局事务ID特性。服务器会自动生成并维护事务ID。用户不需要关系如何维护他们。不需要进一步设置任何的表，或者设置on_commit模式。客户端模拟器不在被需要了。

客户端可以继续使用全局事务ID来满足自己在从MySQL Replication从库读取信息的会话一致性的要求。算法上面描述的一致。fetch_last_gtid和check_for_gtid选项必须配置为不同的SQL语句。这些语句在下面给出了。请注意，MySQL 5.6.5-m8是一个开发版。服务器实现的具体细节可能会在未来改变，或者为了适配所示的SQL语句。

使用下面的配置文件，任何上面描述的功能都可以与服务器端全局事务ID特性一同使用。mysqlnd_ms_get_last_gtid和mysqlnd_ms_set_qos会和上面描述的一样继续工作。唯一的区别是服务器并不是使用一个有序数值而是使用一个包含服务器描述符和有序数值的字符串。所以用户不能容易的从mysqlnd_ms_get_last_gtid返回的GTID中获得旧的数据。

[**示例 22.245. 插件配置； 使用MySQL 5.6.5-m8内建GTID特性**]()

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
        "global_transaction_id_injection":{
            "fetch_last_gtid" : "SELECT @@GLOBAL.GTID_DONE AS trx_id FROM DUAL",
            "check_for_gtid" : "SELECT GTID_SUBSET('#GTID', @@GLOBAL.GTID_DONE) AS trx_id FROM DUAL",
            "report_error":true
        }
    }
}
```

[##### 22.9.6.4.8. 缓存整合](#22.9.6.4.8)

>**版本要求，依赖关系和状态**   
>请阅读概念章节，来获得更多关于版本要求，扩展加载顺序和当前状态的信息。


数据库集群能够向外提供不同的一致性等级。从PECL/mysqlnd_ms 1.2.0 开始，已经可以让插件只考虑再能够交付需要的一致性服务水平的集群中的节点中运行任务。比如，如果使用一个集群范围最终一致性的MySQL Replication异步集群，我们可以在任何时候通过使用mysqlnd_ms_set_quos来要求会话一致性（读出你的写）。请阅读服务水平和一致性的引言章节。

[**示例 22.246. 概括: 关于读出你的写入的服务质量**](#22.246)

```php
/* Request session consistency: read your writes */
/* 需要会话一致性：读出你的写 */
if (!mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
``` 

架设PECL/mysqlnd已经被明确的告知需要提供非会话一致性服务水平的优先级高于最终一致性，作为无效策略用一个客户端端的缓存（配置了TTL）替换一个数据库节点的读请求是可能的。数据库节点和缓存都有可能能够或者不能够提供当前的数据，这个是最终一致性的定义。


用本地缓存替换掉数据库的读访问可以提高整个应用整体的性能并且降低数据库的负载。如果缓存项目能够被其他客户端重用，就能够省略一个数据库访问这样就能降低数据库负载。进一步的，如果一个数据库查询的计算与交付过程要比本地缓存慢，那么系统性能会变得更好。


[**示例 22.247. 插件配置：没有特殊的缓存条目**](http://)

```json
{
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "127.0.0.1",
                "port": "3306"
            }
        },
    }
}
```

[**示例 22.248. 缓存从库请求**](http://)

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Explicitly allow eventual consistency and caching (TTL <= 60 seconds) */
/* 明确允许最终一致性和缓存（TTL <= 60 seconds）*/
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL, MYSQLND_MS_QOS_OPTION_CACHE, 60)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* To make this example work, we must wait for a slave to catch up. */
/* 为了让本示例工作，我们必须等待主库同步完毕。蛮力风格。*/
$attempts = 0;
do {
  /* check if slave has the table */
  /* 检查从库是否有对应的表*/
  if ($res = $mysqli->query("SELECT id FROM test")) {
    break;
  } else if ($mysqli->errno) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
  }
  /* wait for slave to catch up */
  /* 等待主库同步 */
  usleep(200000);
} while ($attempts++ < 10);

/* Query has been run on a slave, result is in the cache */
/* 查询在主库运行，结果在缓存中*/
assert($res);
var_dump($res->fetch_assoc());
/* Served from cache */
/* 用缓存提供服务 */
$res = $mysqli->query("SELECT id FROM test");
?>
```

上例展示了如何使用缓存特性。首先，你必将服务质量设置为最终一致性和明确允许缓存。这个动作可以通过调用mysqlnd_ms_set_qos来完成。然后，每个只读语句的结果集会被缓存，缓存时间为mysqlnd_ms_set_qos设置的时间。

真正的TTL会比mysqlnd_ms_set_qos设置的时间小，或者持平。通过mysqlnd_ms_set_qos设置的为最大的缓存时间。真正的TTL为设置值减去从库的复制延迟。比如，如果TTL设置为60秒，然后从库报告同步延迟为10秒，那么实际的TTL会被计算为50秒。TTL会针对每个缓存查询单独进行计算。

[**示例 22.249. Read your writes and caching combined**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

if (!$mysqli->query("DROP TABLE IF EXISTS test") ||
    !$mysqli->query("CREATE TABLE test(id INT)") ||
    !$mysqli->query("INSERT INTO test(id) VALUES (1)"))
  die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Explicitly allow eventual consistency and caching (TTL <= 60 seconds) */
/* 明确允许最终一致性和缓存（TTL <= 60 seconds）*/
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_EVENTUAL, MYSQLND_MS_QOS_OPTION_CACHE, 60)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* To make this example work, we must wait for a slave to catch up. Brute force style. */
/* 为了让本示例工作，我们必须等待主库同步完毕。蛮力风格。*/
$attempts = 0;
do {
  /* check if slave has the table */
  /* 检查从库是否有对应的表*/
  if ($res = $mysqli->query("SELECT id FROM test")) {
    break;
  } else if ($mysqli->errno) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
  }
  /* wait for slave to catch up */
  /* 等待主库同步 */
  usleep(200000);
} while ($attempts++ < 10);

assert($res);

/* Query has been run on a slave, result is in the cache */
/* 查询在主库运行，结果在缓存中*/
var_dump($res->fetch_assoc());

/* Served from cache */
/* 用缓存提供服务 */
if (!($res = $mysqli->query("SELECT id FROM test")))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
var_dump($res->fetch_assoc());

/* Update on master */
/* 更新主库 */
if (!$mysqli->query("UPDATE test SET id = 2"))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

/* Read your writes */
/* 读取你的写 */
if (false == mysqlnd_ms_set_qos($mysqli, MYSQLND_MS_QOS_CONSISTENCY_SESSION)) {
    die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
}

/* Fetch latest data */
/* 抓取最新数据 */
if (!($res = $mysqli->query("SELECT id FROM test")))
 die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));
var_dump($res->fetch_assoc());
?>
```

为了避免进一步的缓存使用,服务质量可以在任何时候变更。如果需要，你可以切换为会话一致性（读出你的写）.如果这样的话，缓存将不再被使用，将直接读取数据。

##### [22.9.6.4.9. 故障转移（Failover)](#22.9.6.4.9)

默认情况下，如果连接到某个主机失败，插件是不会做任何跟故障转移的相关动作的。这样可以避免跟连接状态有关的潜在故障。我们推荐手动的处理类似于失败事务这样的连接错误。你应该捕获异常，重建连接状态，并且重新运行查询，具体示例如下。

如果连接状态没有任何问题，你可以启用自动静默故障转移。根据配置的不同，自动且静默故障转移会在问题或者错误发生之前尝试切换到主库，或者让允许的查询在尝试连接主库前试着连结其它从库。因为自动故障转移不是万无一失的，这些细节将不会在快速入门手册中探讨。这些细节将在下面的概念章节具体给出。


[**示例 22.250. 手动故障转移, 可选自动转移（automatic optional）**]()

```json
  {
    "myapp": {
        "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "simulate_slave_failure",
                "port": "0"
            },
            "slave_1": {
                "host": "127.0.0.1",
                "port": 3311
            }
        },
       "filters": { "roundrobin": [] }
    }
  }
```


[**示例 22.251. 手动故障转移**]()

```php
<?php
$mysqli = new mysqli("myapp", "username", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
/* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

$sql = "SELECT 1 FROM DUAL";

/* error handling as it should be done regardless of the plugin */
/* 错误处理应该在插件之外独立进行 */
if (!($res = $link->query($sql))) {
  /* plugin specific: check for connection error */
  /* plugin specific: 检查连接错误 */
  switch ($link->errno) {
    case 2002:
    case 2003:
    case 2005:
      printf("Connection error - trying next slave!\n");
      /* load balancer will pick next slave */
      /* 负载均衡会挑选下一个从库 */
      $res = $link->query($sql);
      break;
    default:
      /* no connection error, failover is unlikely to help */
      /* 没有连接错误，故障转移帮不到什么。*/
      die(sprintf("SQL error: [%d] %s", $link->errno, $link->error));
      break;
  }
}
if ($res) {
  var_dump($res->fetch_assoc());
}
?>
```

##### [22.9.6.4.10. 分区和分片](#22.9.6.4.10)

我们会因为各种各样的原因使用数据库集群。集群可以提高可用性，容错能力，并且通过将任务分发到多台机器上来提升性能。有时候集群会与分区和分片结合使用，来达到进一步将大的负载的认为化为小的更易于管理的单元。

Mysqlnd_ms插件旨在支持各种各样的MySQL数据库集群。一些风格的数据库集群有内建的分区和分片特性，这些特性的使用是透明的。插件支持两种最常见的方法：MySQL Replication 表过滤,和分片（基于分区）。

MySQL Replication 支持像过滤器一样分区，这允许你建立能够完全或者部分复制主库或者某些表的从库。然后应用程序需要负责根据过滤器规则来选择一个从库。你可以使用mysqlnd_ms node_groups过滤器来手动支持这个点，也可以使用预置（试验）表过滤器。

手动分区和分片通过节点组过滤器（node grouping filter）进行支持，这跟1.5.0及以后版本的SQL hint一样。node_groups过滤器可以让你将一个符号名分配到主库和从库的一个组中。在示例中，主库master_0 和组Partition_A中的slave_0。如何分组完全是你的决定。比如，你可以使用节点组进行分片，或者通过组名来确定分片比如Shard_A_Range_0_100。


[**示例 22.252. 集群节点组**]()

```json
 {
  "myapp": {
       "master": {
            "master_0": {
                "host": "localhost",
                "socket": "\/tmp\/mysql.sock"
            }
        },
        "slave": {
            "slave_0": {
                "host": "simulate_slave_failure",
                "port": "0"
            },
            "slave_1": {
                "host": "127.0.0.1",
                "port": 3311
            }
        },
        "filters": {
            "node_groups": {
                "Partition_A" : {
                    "master": ["master_0"],
                    "slave": ["slave_0"]
                }
            },
           "roundrobin": []
        }
    }
}
```

示例 22.253. 使用SQL hint 手动分区

```php
<?php
function select($mysqli, $msg, $hint = '') {
  /* Note: weak test, two connections to two servers may have the same thread id */
  /* 注意：弱测试，连接到两个服务器的两个id可能有相同的 thread id*/
  $sql = sprintf("SELECT CONNECTION_ID() AS _thread, '%s' AS _hint FROM DUAL", $msg);
  if ($hint) {
    $sql = $hint . $sql;
  }
  if (!($res = $mysqli->query($sql))) {
    printf("[%d] %s", $mysqli->errno, $mysqli->error);
    return false;
  }
  $row =  $res->fetch_assoc();
  printf("%d - %s - %s\n", $row['_thread'], $row['_hint'], $sql);
  return true;
}

$mysqli = new mysqli("myapp", "user", "password", "database");
if (!$mysqli)
  /* Of course, your error handling is nicer... */
  /* 考虑进行容错是一种好习惯. */
  die(sprintf("[%d] %s\n", mysqli_connect_errno(), mysqli_connect_error()));

/* All slaves allowed */
/* 允许所有从库 */
select($mysqli, "slave_0");
select($mysqli, "slave_1");

/* only servers of node group "Partition_A" allowed */
/* 只有在Partition_A这个组的节点被允许 */
select($mysqli, "slave_1", "/*Partition_A*/");
select($mysqli, "slave_1", "/*Partition_A*/");
?>
```

```    
6804 - slave_0 - SELECT CONNECTION_ID() AS _thread, 'slave1' AS _hint FROM DUAL
2442 - slave_1 - SELECT CONNECTION_ID() AS _thread, 'slave2' AS _hint FROM DUAL
6804 - slave_0 - /*Partition_A*/SELECT CONNECTION_ID() AS _thread, 'slave1' AS _hint FROM DUAL
6804 - slave_0 - /*Partition_A*/SELECT CONNECTION_ID() AS _thread, 'slave1' AS _hint FROM DUAL
```

默认情况下，插件会使用所有已经配置的主库和从库服务器来执行查询。但是如果一个查询是以类似于/*node_group*/这样的SQL hint 开头的话，插件会只考虑在node_group组中列出的服务器上执行查询。所以以/*Partition_A*/开头的SELECT查询只会在slave_0上执行。
