# 13.7.5 SHOW 语法

### 13.7.5 SHOW 语法

SHOW有多种形式提供与服务器相关的数据库、表、列及数据信息等信息。本节描述以下内容：

```sql
SHOW AUTHORS
SHOW {BINARY | MASTER} LOGS
SHOW BINLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]
SHOW CHARACTER SET [like_or_where]
SHOW COLLATION [like_or_where]
SHOW [FULL] COLUMNS FROM tbl_name [FROM db_name] [like_or_where]
SHOW CONTRIBUTORS
SHOW CREATE DATABASE db_name
SHOW CREATE EVENT event_name
SHOW CREATE FUNCTION func_name
SHOW CREATE PROCEDURE proc_name
SHOW CREATE TABLE tbl_name
SHOW CREATE TRIGGER trigger_name
SHOW CREATE VIEW view_name
SHOW DATABASES [like_or_where]
SHOW ENGINE engine_name {STATUS | MUTEX}
SHOW [STORAGE] ENGINES
SHOW ERRORS [LIMIT [offset,] row_count]
SHOW EVENTS
SHOW FUNCTION CODE func_name
SHOW FUNCTION STATUS [like_or_where]
SHOW GRANTS FOR user
SHOW INDEX FROM tbl_name [FROM db_name]
SHOW MASTER STATUS
SHOW OPEN TABLES [FROM db_name] [like_or_where]
SHOW PLUGINS
SHOW PROCEDURE CODE proc_name
SHOW PROCEDURE STATUS [like_or_where]
SHOW PRIVILEGES
SHOW [FULL] PROCESSLIST
SHOW PROFILE [types] [FOR QUERY n] [OFFSET n] [LIMIT n]
SHOW PROFILES
SHOW SLAVE HOSTS
SHOW SLAVE STATUS
SHOW [GLOBAL | SESSION] STATUS [like_or_where]
SHOW TABLE STATUS [FROM db_name] [like_or_where]
SHOW [FULL] TABLES [FROM db_name] [like_or_where]
SHOW TRIGGERS [FROM db_name] [like_or_where]
SHOW [GLOBAL | SESSION] VARIABLES [like_or_where]
SHOW WARNINGS [LIMIT [offset,] row_count]

like_or_where:
    LIKE 'pattern'
  | WHERE expr
```

如果对于一个给定的SHOW语句其语法包括LIKE 'pattern' [1210]部分，则'pattern'是一个字符串，可以包含SQL的“％”和“_”通配符。pattern对于限制语句输出匹配值是有用的。

一些SHOW语句也接受WHERE子句，其对于指定显示哪一行提供更多的灵活性。请参见[Section 20.32, “Extensions to SHOW Statements”][20.32.00]。

很多MySQL的API（如PHP）使你能够将SHOW语句返回的结果看作从SELECT中返回的一个结果集;请参见[Chapter 22, Connectors and APIs][22.00.00]或者你的API文档来了解更多信息。此外，你可以在SQL中查询INFORMATION_SCHEMA 数据库的表得到结果，这对于用SHOW语句返回结果是不容易的。请参见[Chapter 20, INFORMATION_SCHEMA Tables][20.00.00]。



#### 13.7.5.1 [SHOW AUTHORS 语法](#13.7.5.1)

```sql
SHOW AUTHORS
```

SHOW AUTHORS语句显示在MySQL上工作的人的相关信息。对于每个作者，它显示Name、Location以及Comment值。

这个语句在MySQL 5.6.8中已被删除。


#### 13.7.5.2 [SHOW BINARY LOGS 语法](#13.7.5.2)

```sql
SHOW BINARY LOGS
SHOW MASTER LOGS
```

在服务器上列出二进制日志文件。该语句用于[Section 13.4.1.1, “PURGE BINARY LOGS Syntax”][]中所述的程序的一部分，其显示了如何确定哪些日志可以被清除。

```sql
mysql> SHOW BINARY LOGS;
+---------------+-----------+
| Log_name | File_size |
+---------------+-----------+
| binlog.000015 | 724935 |
| binlog.000016 | 733481 |
+---------------+-----------+
```

SHOW MASTER LOGS等同于SHOW BINARY LOGS。

在MySQL 5.6.5和早期版本中，使用该语句需要SUPER [776][]权限。从MySQL 5.6.5开始，拥有REPLICATION CLIENT [775][]权限的用户也可以执行该语句。


#### 13.7.5.3 [SHOW BINLOG EVENTS 语法](#13.7.5.3)

```sql
SHOW BINLOG EVENTS
   [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]
```

在二进制日志中显示事件。如果你未指定'log_name'，将显示第一个二进制日志。

LIMIT子句对于SELECT 语句有相同的语法。请参见[Section 13.2.9, “SELECT Syntax”][13.02.09]。

> ** Note **
>
>发出不带LIMIT子句的SHOW BINLOG EVENTS会启动一个非常耗费时间和资源的过程，因为服务器会将完整的二进制日志的内容（包括服务器所执行的修改数据的所有语句）返回给客户端。作为SHOW BINLOG EVENTS 的替代，使用mysqlbinlog工具将二进制日志保存到一个文本文件中，以便之后检查和分析。请参见[Section 4.6.8, “mysqlbinlog — Utility for Processing Binary Log Files”][04.06.08]。


> ** Note **
>
>与设置用户和系统变量相关的一些事件不包括在SHOW BINLOG EVENTS所输出的内容中。要在二进制日志事件中获得完整范围的事件，请使用mysqlbinlog 。


> ** Note **
>
>SHOW BINLOG EVENTS不能用于中继日志文件。你可以使用SHOW RELAYLOG EVENTS来达到此目的。


#### 13.7.5.4 [SHOW CHARACTER SET 语法](#13.7.5.4)

```sql
SHOW CHARACTER SET
   [LIKE 'pattern' | WHERE expr]
```

SHOW CHARACTER SET语句显示所有可用的字符集。 LIKE [1210]子句如果存在，则表示与哪个字符集名称相匹配。如在[Section 20.32, “Extensions to SHOW Statements”][20.32.00]中所讨论的，在使用更多一般的条件下，WHERE子句可以用来选择行。例如：

```sql
mysql> SHOW CHARACTER SET LIKE 'latin%';
+---------+-----------------------------+-------------------+--------+
| Charset | Description | Default collation | Maxlen |
+---------+-----------------------------+-------------------+--------+
| latin1 | cp1252 West European | latin1_swedish_ci | 1 |
| latin2 | ISO 8859-2 Central European | latin2_general_ci | 1 |
| latin5 | ISO 8859-9 Turkish | latin5_turkish_ci | 1 |
| latin7 | ISO 8859-13 Baltic | latin7_general_ci | 1 |
+---------+-----------------------------+-------------------+--------+
```

MAXLEN列显示需要存储一个字符的字节的最大数量。

#### 13.7.5.5 [SHOW COLLATION 语法](#13.7.5.5)

```sql
SHOW COLLATION
    [LIKE 'pattern' | WHERE expr]
```

该语句列出服务器所支持的排序规则。默认情况下，SHOW COLLATION所输出的内容包括所有可用的排序规则。LIKE [1210]子句如果存在，则表示与哪个排序规则名相匹配。 如在[Section 20.32, “Extensions to SHOW Statements”][20.32.00]中所讨论的，在使用更多一般的条件下，WHERE子句可以用来选择行。例如：

```sql
mysql> SHOW COLLATION LIKE 'latin1%';
+-------------------+---------+----+---------+----------+---------+
| Collation | Charset | Id | Default | Compiled | Sortlen |
+-------------------+---------+----+---------+----------+---------+
| latin1_german1_ci | latin1 | 5 | | | 0 |
| latin1_swedish_ci | latin1 | 8 | Yes | Yes | 0 |
| latin1_danish_ci | latin1 | 15 | | | 0 |
| latin1_german2_ci | latin1 | 31 | | Yes | 2 |
| latin1_bin | latin1 | 47 | | Yes | 0 |
| latin1_general_ci | latin1 | 48 | | | 0 |
| latin1_general_cs | latin1 | 49 | | | 0 |
| latin1_spanish_ci | latin1 | 94 | | | 0 |
+-------------------+---------+----+---------+----------+---------+
```

Collation和Charset列表示相关联的的排序规则和字符集的名称。Id是排序规则ID。Default表示排序规则对于它的字符集来说是否默认。Compiled表示字符集是否被编译到服务器中。Sortlen表示字符集中所显示的用来排序字符串所需的内存量。

要查看每个字符集的默认排序规则，请使用下面的语句。Default 是一个保留字，因此用它作为一个标识符，它必须如此引用：

```sql
mysql> SHOW COLLATION WHERE `Default` = 'Yes';
+---------------------+----------+----+---------+----------+---------+
| Collation | Charset | Id | Default | Compiled | Sortlen |
+---------------------+----------+----+---------+----------+---------+
| big5_chinese_ci | big5 | 1 | Yes | Yes | 1 |
| dec8_swedish_ci | dec8 | 3 | Yes | Yes | 1 |
| cp850_general_ci | cp850 | 4 | Yes | Yes | 1 |
| hp8_english_ci | hp8 | 6 | Yes | Yes | 1 |
| koi8r_general_ci | koi8r | 7 | Yes | Yes | 1 |
| latin1_swedish_ci | latin1 | 8 | Yes | Yes | 1 |
...
```

#### 13.7.5.6 [SHOW COLUMNS 语法](#13.7.5.6)

```sql
SHOW [FULL] COLUMNS {FROM | IN} tbl_name [{FROM | IN} db_name]
    [LIKE 'pattern' | WHERE expr]
```

SHOW COLUMNS 显示指定表中列的相关信息。它对于视图也有效。LIKE [1210]子句如果存在，则表示与哪个列名相匹配。 如在[Section 20.32, “Extensions to SHOW Statements”][20.32.00]中所讨论的，在使用更多一般的条件，WHERE子句可以用来选择行。例如：

SHOW COLUMNS 只显示你拥有权限的这些列的信息。

```sql
mysql> SHOW COLUMNS FROM City;
+------------+----------+------+-----+---------+----------------+
| Field | Type | Null | Key | Default | Extra |
+------------+----------+------+-----+---------+----------------+
| Id | int(11) | NO | PRI | NULL | auto_increment |
| Name | char(35) | NO | | | |
| Country | char(3) | NO | UNI | | |
| District | char(20) | YES | MUL | | |
| Population | int(11) | NO | | 0 | |
+------------+----------+------+-----+---------+----------------+
5 rows in set (0.00 sec)
```

如果数据类型与你所期望的基于CREATE TABLE语句的不同，请注意，当你创建或更改表时，MySQL有时会改变数据类型。发生此事的情况描述在[Section 13.1.17.3, “Silent Column Specification Changes”][]中。

FULL 关键字使得输出包含列排序规则和注释，同样你需要对每一列拥有权限。

你可以使用db_name.tbl_name 作为tbl_name FROM db_name 语法的替换。也就是说，这两个语句是相同的。

```sql
mysql> SHOW COLUMNS FROM mytable FROM mydb;
mysql> SHOW COLUMNS FROM mydb.mytable;
```

SHOW COLUMNS为每个表列显示下面的值：

Field 表示列名。

Type 表示列数据类型。

Collation 为非二进制字符串列表示排序规则，或为其他列表示NULL 。该值仅在你使用FULL关键字时才显示。

如果NULL 值能够存储在列中，则Null 字段包含YES，否则包含NO 。

Key 字段显示列是否有索引：

* 若key为空，要么是列没有索引或索引列中只能作为多列中的辅助列，不是唯一索引。
* 若Key为PRI，则该列是PRIMARY KEY 或者是多列PRIMARY KEY中的一列。

* 若Key为UNI，则该列是UNIQUE 索引的第一列。（UNIQUE 索引允许多重NULL 值，但你可以通过查找Null 字段来辨别是否列允许Null 。）

* 若Key为MUL，则该列是非唯一索引的第一列，在列中多次出现一个给定值是允许的。

如果有一个以上的Key值适用于给定表的一列，则Key显示PRI 、UNI 和MUL顺序中的最高优先级。

如果UNIQUE索引不包含NULL值，且在表中没有PRIMARY KEY，则它可能被显示为PRI。如果几个列形成一个复合UNIQUE索引，则UNIQUE索引可能会显示为MUL;虽然列的组合是唯一的，但每一列仍可以多次出现一个给定值。

Default字段表示分配给列的默认值。如果列有一个明确的默认值为NULL，或者如果列定义没有DEFAULT子句，则它为NULL。

Extra字段包含任何对于给定列有用的附加信息。该值在这些情况下非空：有AUTO_INCREMENT属性的列的auto_increment；拥有ON UPDATE CURRENT_TIMESTAMP属性的TIMESTAMP或者DATETIME列的on update CURRENT_TIMESTAMP。

Privileges表示对于列你所拥有的权限。该值仅在你使用FULL关键字时才显示。

Comment表示列所有的任何注释。该值仅在你使用FULL关键字时才显示。
SHOW FIELDS和SHOW COLUMNS是同义词。你也可以用mysqlshow db_name tbl_name命令来列出一个表的所有列。

DESCRIBE语句提供的信息与SHOW COLUMNS是一样的。请参见[Section 13.8.1,“DESCRIBE Syntax”][13.08.01]。

SHOW CREATE TABLE ，SHOW TABLE STATUS以及SHOW INDEX 语句也提供表的相关信息。请参见[Section 13.7.5, “SHOW Syntax”][13.07.05]。

#### 13.7.5.7 [SHOW CONTRIBUTORS 语法](#13.7.5.7)

```sql
SHOW CREATE DATABASE
```

SHOW CONTRIBUTORS语句显示有助于MySQL源或我们所支持的理由的人的相关信息。对于每一个参与者，它会显示Name，Location和Comment值。

这个语句已经在MySQL 5.6.8中被删除。

#### 13.7.5.8 [SHOW CREATE DATABASE 语法](#13.7.5.8)

```sql
SHOW CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
```

这个语句显示了创建指定数据库的CREATE DATABASE语句。如果SHOW语句包含IF NOT EXISTS子句，则输出也包含该子句。SHOW CREATE SCHEMA与SHOW CREATE DATABASE同义。

```sql
mysql> SHOW CREATE DATABASE test\G
*************************** 1. row ***************************
Database: test
Create Database: CREATE DATABASE `test`
/*!40100 DEFAULT CHARACTER SET latin1 */
mysql> SHOW CREATE SCHEMA test\G
*************************** 1. row ***************************
Database: test
Create Database: CREATE DATABASE `test`
/*!40100 DEFAULT CHARACTER SET latin1 */
```

SHOW CREATE DATABASE通过sql_quote_show_create [560]选项引用表和列名称。参见[Section 5.1.4, “Server System Variables”][05.01.04]。

#### 13.7.5.9 [SHOW CREATE EVENT 语法](#13.7.5.9)

```sql
SHOW CREATE EVENT event_name
```

这个语句显示CREATE EVENT语句，其需要重新创建一个给定的事件。它需要对数据库拥有EVENT [774]权限来显示这个事件。例如（使用同一事件e_daily,其在[Section 13.7.5.19, “SHOW EVENTS Syntax”][]中被定义和修改）：

```sql
mysql> SHOW CREATE EVENT test.e_daily\G
*************************** 1. row ***************************
               Event: e_daily
            sql_mode:
           time_zone: SYSTEM
        Create Event: CREATE EVENT `e_daily`
                         ON SCHEDULE EVERY 1 DAY
                         STARTS CURRENT_TIMESTAMP + INTERVAL 6 HOUR
                         ON COMPLETION NOT PRESERVE
                         ENABLE
                         COMMENT 'Saves total number of sessions then
                                 clears the table each day'
                         DO BEGIN
                           INSERT INTO site_activity.totals (time, total)
                             SELECT CURRENT_TIMESTAMP, COUNT(*)
                             FROM site_activity.sessions;
                           DELETE FROM site_activity.sessions;
                         END
character_set_client: latin1
collation_connection: latin1_swedish_ci
  Database Collation: latin1_swedish_ci
```

当事件被创建时，character_set_client是character_set_client [483]系统变量的会话值，collation_connection 是collation_connection [485]的会话值。Database Collation是与事件相关联的数据库的排序规则。

请注意，输出反映了当前事件状态（ENABLE），而不是它已经被创造的状态。

#### 13.7.5.10 [SHOW CREATE FUNCTION 语法](#13.7.5.10)

```sql
SHOW CREATE FUNCTION func_name
```

这个语句与SHOW CREATE PROCEDURE相似，但其与存储函数相关。请参见[Section 13.7.5.11, “SHOW CREATE PROCEDURE Syntax”][]。

#### 13.7.5.11 [SHOW CREATE PROCEDURE 语法](#13.7.5.11)

```sql
SHOW CREATE PROCEDURE proc_name
```

这个语句是MySQL的扩展。它返回完全匹配的字符串，可以用来重新建立指定的存储过程。类似的语句SHOW CREATE FUNCTION显示存储函数的相关信息（请参见[Section 13.7.5.10, “SHOW CREATE FUNCTION Syntax”][]）。

两个语句都需要你是程序的拥有者或者对mysql.proc表有SELECT存取权限。如果你对程序本身没有权限，显示Create Procedure或者Create Function字段的值将为NULL。

```sql
mysql> SHOW CREATE PROCEDURE test.simpleproc\G
*************************** 1. row ***************************
           Procedure: simpleproc
            sql_mode:
    Create Procedure: CREATE PROCEDURE `simpleproc`(OUT param1 INT)
                      BEGIN
                      SELECT COUNT(*) INTO param1 FROM t;
                      END
character_set_client: latin1
collation_connection: latin1_swedish_ci
  Database Collation: latin1_swedish_ci
  
mysql> SHOW CREATE FUNCTION test.hello\G
*************************** 1. row ***************************
            Function: hello
            sql_mode:
     Create Function: CREATE FUNCTION `hello`(s CHAR(20))
                      RETURNS CHAR(50)
                      RETURN CONCAT('Hello, ',s,'!')
character_set_client: latin1
collation_connection: latin1_swedish_ci
  Database Collation: latin1_swedish_ci
```

当程序被创建时，character_set_client是character_set_client [483]系统变量的会话值，collation_connection是collation_connection [485]变量的会话值。Database Collation是与程序相关的数据库排序规则。

#### 13.7.5.12 [SHOW CREATE TABLE 语法](#13.7.5.12)

```sql
SHOW CREATE TABLE tbl_name
```

这个语句显示创建指定表的CREATE TABLE语句。为了使用该语句，你必须对表拥有一些权限。这个语句对视图也有效。

```sql
mysql> SHOW CREATE TABLE t\G
*************************** 1. row ***************************
       Table: t
Create Table: CREATE TABLE t (
  id INT(11) default NULL auto_increment,
  s char(60) default NULL,
  PRIMARY KEY (id)
) ENGINE=MyISAM
```

SHOW CREATE TABLE通过sql_quote_show_create [560]选项的值引用表和列名称。参见[Section 5.1.4, “Server System Variables”][05.01.04]。

#### 13.7.5.13 [SHOW CREATE TRIGGER 语法](#13.7.5.13)

```sql
SHOW CREATE TRIGGER trigger_name
```

这个语句显示创建指定触发器的CREATE TRIGGER语句。

```sql
mysql> SHOW CREATE TRIGGER ins_sum\G
*************************** 1. row ***************************
Trigger: ins_sum
sql_mode: NO_ENGINE_SUBSTITUTION
SQL Original Statement: CREATE DEFINER=`me`@`localhost` TRIGGER ins_sum
BEFORE INSERT ON account
FOR EACH ROW SET @sum = @sum + NEW.amount
character_set_client: utf8
collation_connection: utf8_general_ci
Database Collation: latin1_swedish_ci
```

SHOW CREATE TRIGGER输出有下面列：

* Trigger：触发器名称。

* sql_mode：当触发器执行时SQL模式生效。

* SQL Original Statement：CREATE TRIGGER语句定义触发器。

* character_set_client：当触发器被创建时，character_set_client [483]系统变量的会话值。

* collation_connection：当触发器被创建时，collation_connection [485]系统变量的会话值。

* Database Collation：触发器相关联的数据库排序规则。

你也可以从包含TRIGGERS表的INFORMATION_SCHEMA中获得有关触发对象的信息。请参见[Section 20.27, “The INFORMATION_SCHEMA TRIGGERS Table”][20.27.00]。

#### 13.7.5.14 [SHOW CREATE VIEW 语法](#13.7.5.14)

```sql
SHOW CREATE VIEW view_name
```

这个语句显示创建指定视图的CREATE VIEW语句。

```sql
mysql> SHOW CREATE VIEW v\G
*************************** 1. row ***************************
                View: v
         Create View: CREATE ALGORITHM=UNDEFINED
                      DEFINER=`bob`@`localhost`
                      SQL SECURITY DEFINER VIEW
                      `v` AS select 1 AS `a`,2 AS `b`
character_set_client: latin1
collation_connection: latin1_swedish_ci
```

当视图被创建时，character_set_client是character_set_client [483]系统变量的会话值，collation_connection是collation_connection [485]系统变量的会话值。

使用SHOW CREATE VIEW需要对正在讨论的视图拥有SHOW VIEW [775]和SELECT [775]权限。

你也可以从包含VIEWS表的INFORMATION_SCHEMA中获得有关视图对象的信息。请参见[Section 20.29, “The INFORMATION_SCHEMA VIEWS Table”][20.29.00]。

MySQL让你使用不同的sql_mode [558]选项来辨别服务器所支持的SQL语法类型。例如，你可能使用ANSI[624] SQL模式，以确保MySQL来正确地解释你所查询的SQL连接运算符双竖线（| |）的标准。如果你再创造一个连接项目的视图，你可能会担心改变sql_mode [558]设置为与ANSI[624]不同的值，这可能会导致视图变成无效。但并不是这种情况。不管你怎么写出视图定义，MySQL总是以同样的方式即一个规范的形式来存储它。下面这个例子显示服务器如何改变双竖线连接运算符为CONCAT() [1198]程序：

```sql
mysql> SET sql_mode = 'ANSI';
Query OK, 0 rows affected (0.00 sec)

mysql> CREATE VIEW test.v AS SELECT 'a' || 'b' as col1;
Query OK, 0 rows affected (0.01 sec)

mysql> SHOW CREATE VIEW test.v\G
*************************** 1. row ***************************
                View: v
         Create View: CREATE VIEW "v" AS select concat('a','b') AS "col1"
...
1 row in set (0.00 sec)
```

以规范形式存储视图定义的好处是，更改后的sql_mode [558]值将不会影响从视图返回的结果。然而，另一个结果是在SELECT之前的注解都被服务器从定义中移除。

#### 13.7.5.15 [SHOW DATABASES 语法](#13.7.5.15)

```sql
SHOW {DATABASES | SCHEMAS}
    [LIKE 'pattern' | WHERE expr]
```

SHOW DATABASES列出在MySQL服务器主机上的数据库。SHOW SCHEMAS是SHOW DATABASES的同义词。如果LIKE [1210]子句存在的话，表示相匹配的数据库名称。如[Section 20.32, “Extensions to SHOW Statements”][20.32.00]中所讨论的，在使用更多一般的条件下，WHERE子句可以用来选择行。

你只能查看拥有某种权限的数据库，除非你拥有全局SHOW DATABASES权限。你也可以使用mysqlshow命令获取这个列表。

如果服务器以--skip-show-database [455]选项启动，你根本不能使用此语句，除非你有SHOW DATABASES[775]权限。

MySQL实现数据库为数据目录中的目录，所以这个语句简单列出在那个位置的目录。然而，输出可能包含不能对应到实际数据库的目录名。

#### 13.7.5.16 [SHOW ENGINE 语法](#13.7.5.16)

```sql
SHOW ENGINE engine_name {STATUS | MUTEX}
```

SHOW ENGINE显示存储引擎相关的操作信息。目前支持下面的语句：

```sql
SHOW ENGINE INNODB STATUS
SHOW ENGINE INNODB MUTEX
SHOW ENGINE {NDB | NDBCLUSTER} STATUS
SHOW ENGINE PERFORMANCE_SCHEMA STATUS
```

SHOW ENGINE INNODB STATUS显示与InnoDB存储引擎相关，来自标准InnoDB监视器的丰富信息。欲了解更多关于提供InnoDB处理过程相关信息的标准显示器和其他InnoDB显示器的信息，请参见[Section 14.2.4.4, “SHOW ENGINE INNODB STATUS and the InnoDB Monitors”][]。

SHOW ENGINE INNODB MUTEX显示互斥数据。语句输出包含以下列：

* Type

  总是InnoDB。
  
* Name

  实现互斥的源文件，以及互斥被创建的文件中的行号。行号可能会改变，这取决于你的MySQL版本。

* Status

  互斥状态。如果在MySQL编译时间中定义UNIV_DEBUG，此字段显示一些值（例如，在 MySQL源代码树中InnoDB部分的include/univ.i）。如果没有定义UNIV_DEBUG，这个语句只显示os_waits值。在后一种情况（没有UNIV_DEBUG），输出所基于的信息不足以区分正则互斥和保护RW锁的互斥（其允许多个读取器或单一写入器）。因此，输出可能会出现对于相同的互斥包含多个行。

* count 表示互斥被请求的次数。

* spin_waits 表示自旋锁不得不运行的次数。
 
* spin_rounds 表示自旋锁循环的数量。（spin_waits除以spin_rounds得到平均循环计数。）
 
* os_waits 表示操作系统等待时间的数量。当自旋锁不工作时会发生这种情况（在自旋锁期间互斥不会被锁，并且有必要屈服操作系统和等待时间）。

* os_yields 表示线程试图锁定放弃它的时间片且屈服于操作系统的互斥的次数（假设允许其他线程运行会释放互斥以便它可以被锁定）。

* os_wait_times 表示如果timed_mutexes [571]系统变量为1（ON），则耗费在操作系统等待上的时间量（以ms为单位）。如果timed_mutexes [571为0（OFF），时间无效，因此os_wait_times为0。timed_mutexes [571]在默认情况下关闭。

来自于这个语句的信息可以用来诊断系统问题。例如，spin_waits和spin_rounds的大值可能显示可伸缩性问题。

请使用SHOW ENGINE PERFORMANCE_SCHEMA STATUS来检查Performance Schema代码的内部操作：

```sql
mysql> SHOW ENGINE PERFORMANCE_SCHEMA STATUS\G
...
*************************** 3. row ***************************
  Type: performance_schema
  Name: events_waits_history.row_size
Status: 76
*************************** 4. row ***************************
  Type: performance_schema
  Name: events_waits_history.row_count
Status: 10000
*************************** 5. row ***************************
  Type: performance_schema
  Name: events_waits_history.memory
Status: 760000
...
*************************** 57. row ***************************
  Type: performance_schema
  Name: performance_schema.memory
Status: 26459600
...
```

这个语句旨在帮助DBA理解不同的Performance Schema选项对内存需求的作用。

Name值包含两个部分，其分别命名内部缓冲区和缓冲区属性。缓冲区名解译如下：

* 不显示为表的内部缓冲区被命名在括号内。例如：(pfs_cond_class).row_size，(pfs_mutex_class).memory。

* 在performance_schema数据库中显示为表的内部缓冲区被命名在表之后，不包含在括号内。例如：events_waits_history.row_size，mutex_instances.row_count。

* 适用于Performance Schema的值作为一个整体以performance_schema开始。例如：performance_schema.memory。

缓冲区属性包含以下意思：

* row_size是被用于实施的内部记录的大小，例如表中一行的大小。row_size值不能被改变。

* row_count是内部记录的数量，例如表中的行数。可以使用性能模式配置选项来改变row_count值。

* 对于表来说，tbl_name.memory是row_size和row_count的产物。Performance Schema作为一个整体，performance_schema.memory是所有被需要内存的总量（所有其它memory值的总量）。

在某些情况下，Performance Schema配置参数和SHOW ENGINE值之间有直接关系。例如，events_waits_history_long.row_count与performance_schema_events_waits_history_long_size [2758]相符。在其它情况下，这种关系更加复杂。例如，events_waits_history.row_count与performance_schema_events_waits_history_size [2758]（每个线程的行的数量）乘以performance_schema_max_thread_instances [2764]（线程的数量）的数量相符。

SHOW ENGINE NDB STATUS。如果服务器使得NDB存储引擎有效，SHOW ENGINE NDB STATUS 显示集群状态信息，例如已连接数据节点的数量、集群连接字符串以及集群二进制日志记录，也就是当连接到集群时被MySQL创建的各种集群API对象的数量。来自这个语句的样本输出显示如下：

```sql
mysql> SHOW ENGINE NDB STATUS;
+------------+-----------------------+--------------------------------------------------+
| Type       | Name                  | Status                                           |
+------------+-----------------------+--------------------------------------------------+
| ndbcluster | connection            | cluster_node_id=7,
  connected_host=192.168.0.103, connected_port=1186, number_of_data_nodes=4,
  number_of_ready_data_nodes=3, connect_count=0                                         |
| ndbcluster | NdbTransaction        | created=6, free=0, sizeof=212                    |
| ndbcluster | NdbOperation          | created=8, free=8, sizeof=660                    |
| ndbcluster | NdbIndexScanOperation | created=1, free=1, sizeof=744                    |
| ndbcluster | NdbIndexOperation     | created=0, free=0, sizeof=664                    |
| ndbcluster | NdbRecAttr            | created=1285, free=1285, sizeof=60               |
| ndbcluster | NdbApiSignal          | created=16, free=16, sizeof=136                  |
| ndbcluster | NdbLabel              | created=0, free=0, sizeof=196                    |
| ndbcluster | NdbBranch             | created=0, free=0, sizeof=24                     |
| ndbcluster | NdbSubroutine         | created=0, free=0, sizeof=68                     |
| ndbcluster | NdbCall               | created=0, free=0, sizeof=16                     |
| ndbcluster | NdbBlob               | created=1, free=1, sizeof=264                    |
| ndbcluster | NdbReceiver           | created=4, free=0, sizeof=68                     |
| ndbcluster | binlog                | latest_epoch=155467, latest_trans_epoch=148126,
  latest_received_binlog_epoch=0, latest_handled_binlog_epoch=0,
  latest_applied_binlog_epoch=0                                                         |
+------------+-----------------------+--------------------------------------------------+
```

Name列中的connection和binlog行在MySQL 5.1中被添加到这个语句的输出中。这两行中每一行的Status列都分别提供MySQL服务器连接到集群和集群二进制日志状态的相关信息。Status信息以逗号分隔的方式来设置名称/值。

connection行的Status列所包含的名称/值描述于以下表中。

<table border="1"><colgroup><col><col></colgroup><thead>
<tr>
    <th scope="col">名称</th><th scope="col">值</th>
</tr></thead><tbody>
<tr>
    <td scope="row"><code class="literal">cluster_node_id</code></td><td>集群中MySQL服务器的节点ID</td>
</tr>
<tr>
    <td scope="row"><code class="literal">connected_host</code></td><td>MySQL服务器所连接的集群管理服务器的主机名或者IP地址
</tr>
<tr>
    <td scope="row"><code class="literal">connected_port</code></td><td>MySQL服务器连接管理服务器(<code class="literal">connected_host</code>)所使用的端口</td>
</tr>
<tr>
    <td scope="row"><code class="literal">number_of_data_nodes</code></td><td> 为集群配置的数据节点数（也就是，在集群<code class="filename">config.ini</code> 文件中<code class="literal">[ndbd]</code>会话数)</td>
</tr>
<tr>
    <td scope="row"><code class="literal">number_of_ready_data_nodes</code></td><td>实际运行中的集群的数据节点数</td>
</tr>
<tr>
    <td scope="row"><code class="literal">connect_count</code></td><td><a class="link" href="mysqld.html" title="4.3.1.&nbsp;mysqld — The MySQL Server"><span class="command"><strong>mysqld</strong></span></a> 已经连接或者重新连接到集群数据节点的次数</td>
</tr></tbody></table>

binlog行的Status列包含有关MySQL集群复制的信息。它所包含的名称/值描述于以下表中。

<table border="1"><colgroup><col><col></colgroup><thead>
<tr>
    <th scope="col">名称</th><th scope="col">值</th>
</tr></thead><tbody>
<tr>
    <td scope="row"><code class="literal">latest_epoch</code></td><td>最近运行在MySQL的服务器上的最近时刻(也就是说,运行在服务器上的最新事物的序号)</td>
</tr>
<tr>
    <td scope="row"><code class="literal">latest_trans_epoch</code></td><td>集群的数据节点所处理的最近时刻</td>
</tr>
<tr>
    <td scope="row"><code class="literal">latest_received_binlog_epoch</code></td><td>二进制日志线程所收到的最近时刻</td>
</tr>
<tr>
    <td scope="row"><code class="literal">latest_handled_binlog_epoch</code></td><td>二进制日志进程所处理的最近时刻 (将写入二进制日志中)</td>
</tr>
<tr>
    <td scope="row"><code class="literal">latest_applied_binlog_epoch</code></td><td>实际已写入二进制日志中的最近时刻</td>
</tr></tbody></table>

欲知更多信息，请参见[Section 17.6, “MySQL Cluster Replication”][17.06.00]。

最可能证明对于监视集群有用的，SHOW ENGINE NDB STATUS所输出的余下行，列出下面这些Name：

* NdbTransaction: 已被创建的NdbTransaction对象的数量和大小。0NdbTransaction每次被创建时，表结构操作（例如CREATE TABLE或者ALTER TABLE) 在NDB表中被执行。

* NdbOperation：已被创建的NdbOperation对象的数量和大小。

* NdbIndexScanOperation：已被创建的NdbIndexScanOperation对象的数量和大小。

* NdbIndexOperation：已被创建的NdbIndexOperation对象的数量和大小。

* NdbRecAttr：已被创建的NdbRecAttr对象的数量和大小。一般来说，它们中的任一个每次被创建时，数据操作语句通过一个SQL节点被执行。

* NdbBlob：已被创建的NdbBlob对象的数量和大小。NdbBlob被创建时，每次新的操作涉及到NDB表中BLOB列。

* NdbReceiver：已被创建的NdbReceiver对象的数量和大小。在created列中的数量与MySQL服务器连接到集群中的数据节点的数量一样。

> ** Note **
>
>当前会话期间，这个语句在MySQL客户端存取的SQL节点上运行，如果没有涉及到NDB表的操作被运行，则SHOW ENGINE NDB STATUS返回一个空结果。

#### 13.7.5.17 [SHOW ENGINES 语法](#13.7.5.17)

```sql
SHOW [STORAGE] ENGINES
```

SHOW ENGINES显示服务器存储引擎相关的状态信息。特别是它可用于检查是否存储引擎被支持，或者查看默认引擎是什么。

```sql
mysql> SHOW ENGINES\G
*************************** 1. row ***************************
      Engine: MEMORY
     Support: YES
     Comment: Hash based, stored in memory, useful for temporary tables
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 2. row ***************************
      Engine: MyISAM
     Support: YES
     Comment: MyISAM storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 3. row ***************************
      Engine: InnoDB
     Support: DEFAULT
     Comment: Supports transactions, row-level locking, and foreign keys
Transactions: YES
          XA: YES
  Savepoints: YES
*************************** 4. row ***************************
      Engine: EXAMPLE
     Support: YES
     Comment: Example storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 5. row ***************************
      Engine: ARCHIVE
     Support: YES
     Comment: Archive storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 6. row ***************************
      Engine: CSV
     Support: YES
     Comment: CSV storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 7. row ***************************
      Engine: BLACKHOLE
     Support: YES
     Comment: /dev/null storage engine (anything you write »
              to it disappears)
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 8. row ***************************
      Engine: FEDERATED
     Support: YES
     Comment: Federated MySQL storage engine
Transactions: NO
          XA: NO
  Savepoints: NO
*************************** 9. row ***************************
      Engine: MRG_MYISAM
     Support: YES
     Comment: Collection of identical MyISAM tables
Transactions: NO
          XA: NO
  Savepoints: NO
```

来自SHOW ENGINES的输出可能会根据所使用的MySQL版本和其他因素而有所不同。如下表中所示，Support列中所显示的值表示支持存储引擎的服务器级别。

<table summary="This table describes values for the Support column in the output of theSHOW ENGINES command." border="1"><colgroup><col><col></colgroup><thead>
<tr>
    <th scope="col">值</th><th scope="col">意义</th>
</tr></thead><tbody>
<tr>
    <td scope="row"><code class="literal">YES</code></td><td>引擎被支持，并处于活动状态</td>
</tr>
<tr>
    <td scope="row"><code class="literal">DEFAULT</code></td><td>像<code class="literal">YES</code>, 且这是默认引擎</td>
</tr>
<tr>
    <td scope="row"><code class="literal">NO</code></td><td>引擎不被支持</td>
</tr>
<tr>
    <td scope="row"><code class="literal">DISABLED</code></td><td>引擎被支持但是已经失效</td>
</tr></tbody></table>

NO值意味着不支持引擎的情况下服务器被编译，因此它不能在运行时间内启动。

DISABLED值发生的原因，或者是因为以禁用引擎这个选项来启动服务器，或者是因为并非所有需要启用它的选项都被给出。在后一种情况下，错误日志文件应该包含一个理由，表明为什么该选项被禁用。请参见[Section 5.2.2, “The Error Log”][05.02.02]。

如果被编译的服务器支持它，但是以--skip-engine_name选项启动的话，你还可能看到存储引擎的DISABLED。对于NDB存储引擎来说，DISABLED表示在支持MySQL集群但是不以--ndbcluster [2296]选项启动的情况下，服务器被编译。

所有的MySQL服务器支持MyISAM表，因为MyISAM是默认存储引擎。禁用MyISAM是不可能的。

Transactions，XA和Savepoints列表示存储引擎是否分别支持事务、XA事务和保存点。

#### 13.7.5.18 [SHOW ERRORS 语法](#13.7.5.18)

```sql
SHOW ERRORS [LIMIT [offset,] row_count]
SHOW COUNT(*) ERRORS
```

这个语句与SHOW WARNINGS类似，但它仅为错误显示信息，而不为错误、警告和注意事项。

LIMIT子句对于SELECT语句有相同的语法。请参见[Section 13.2.9, “SELECT Syntax”][13.02.09]。

SHOW COUNT(*) ERRORS语句显示错误的数量。你也可以从error_count [495]变量中检索这个数量：

```sql
SHOW COUNT(*) ERRORS;
SELECT @@error_count;
```

SHOW ERRORS和error_count [495]仅适用于错误，而不是警告或注意事项。在另一方面，它们与SHOW WARNINGS和warning_count [577]类似。特别是，SHOW ERRORS不能显示超出max_error_count [519]的信息，并且如果错误的数量超过max_error_count[519]，则ERROR_COUNT[495]可以超过max_error_count[519]的值。

欲知更多信息，请参见[Section 13.7.5.41, “SHOW WARNINGS Syntax”][]。

#### 13.7.5.19 [SHOW EVENTS 语法](#13.7.5.19)

```sql
SHOW EVENTS [{FROM | IN} schema_name]
    [LIKE 'pattern' | WHERE expr]
```

这个语句显示关于事件管理器事件的信息。它需要对显示事件的数据库有EVENT [774] 权限。

SHOW EVENTS以其最简单的形式在当前模式中列出了所有的事件：

```sql
mysql> SELECT CURRENT_USER(), SCHEMA();
+----------------+----------+
| CURRENT_USER() | SCHEMA() |
+----------------+----------+
| jon@ghidora | myschema |
+----------------+----------+
1 row in set (0.00 sec)

mysql> SHOW EVENTS\G
*************************** 1. row ***************************
                  Db: myschema
                Name: e_daily
             Definer: jon@ghidora
           Time zone: SYSTEM
                Type: RECURRING
          Execute at: NULL
      Interval value: 10
      Interval field: SECOND
              Starts: 2006-02-09 10:41:23
                Ends: NULL
              Status: ENABLED
          Originator: 0
character_set_client: latin1
collation_connection: latin1_swedish_ci
  Database Collation: latin1_swedish_ci
```

为了查看特定的模式的事件，请使用FROM子句。例如，去查看test模式的事件，请使用下面语句：

```sql
SHOW EVENTS FROM test;
```

如果LIKE [1210]子句存在，表示与哪个事件名相匹配。如[Section 20.32, “Extensions to SHOW Statements”][20.32.00]中所讨论的，在使用更多一般的条件下，WHERE子句可以被用来选择行。

SHOW EVENTS输出有下面这些列：

* Db:事件被定义在的架构（数据库）。

* Name：事件的名称。

* Time zone：事件的时区，即用于调度事件的时区并且它在事件执行期间生效。默认值为SYSTEM。

* Definer：创建事件的用户的账户，采用'user_name'@'host_name'格式。

* Type：事件复制的类型，或者是ONE TIME（暂时性），或者是RECURRING（重复性）。
* Execute At：当一个暂时事件开始执行时的日期和时间。显示为DATETIME值。

  对于一个重复事件，该列的值总为NULL。

* Interval Value：对于一个重复事件，表示事件执行之间等待的间隔数。
  
  对于一个暂时事件，该列的值总为NULL。

* Interval Field：用于重复事件在重复之前等待的间隔的时间单位。

  对于一个暂时事件，该列的值总为NULL。

* Starts：重复事件的开始日期和时间。它显示为DATETIME值，并且如果没有为事件定义开始日期和时间，它为NULL。

  对于一个暂时事件，该列的值总为NULL。

* Ends：重复事件的结束日期和时间。它显示为DATETIME值，并且如果没有为事件定义结束日期和时间，它默认为NULL。

  对于一个暂时事件，该列的值总为NULL。

* Status：事件状态。ENABLED和DISABLED中的一个，或者是SLAVESIDE_DISABLED。

  SLAVESIDE_DISABLED显示在另一个MySQL服务器上所发生的创建事件作为复制主从服务器，并复制到当前作为从服务器的MySQL服务器上，但这个事件当前并不在从服务器上执行。

* Originator：事件在MySQL服务器上被创建的服务器ID。默认为0。

* character_set_client是程序被创建时character_set_client [483]系统变量的会话值。collation_connection是程序被创建时collation_connection [485]系统变量的会话值。Database Collation是程序相关联的数据库的排序规则。

更多关于SLAVE_DISABLED和Originator列的信息，请参见[Section 16.4.1.11, “Replication of Invoked Features”][]。

事件活动语句在SHOW EVENTS的输出中并不显示。请使用SHOW CREATE EVENT或者
INFORMATION_SCHEMA.EVENTS表。

如[Section 19.4.4,“Event Metadata”][19.04.04]所讨论的，SHOW EVENTS所显示的时间在事件的时区中被给出。

SHOW EVENTS输出的列和INFORMATION_SCHEMA.EVENTS表中的列相似，但并不完全相同。请参见[Section 20.7, “The INFORMATION_SCHEMA EVENTS Table”][20.07.00]。

#### 13.7.5.20 [SHOW FUNCTION CODE 语法](#13.7.5.20)

```sql
SHOW FUNCTION CODE func_name
```

如果没有存储函数，该语句与SHOW PROCEDURE CODE类似。请参见[Section 13.7.5.28,
“SHOW PROCEDURE CODE Syntax”][]。

#### 13.7.5.21 [SHOW FUNCTION STATUS 语法](#13.7.5.21)

```sql
SHOW FUNCTION STATUS
    [LIKE 'pattern' | WHERE expr]
```

如果没有存储函数，该语句与SHOW PROCEDURE STATUS类似。请参见[Section 13.7.5.29, “SHOW PROCEDURE STATUS Syntax”][]。

#### 13.7.5.22 [SHOW GRANTS 语法](#13.7.5.22)

```sql
SHOW GRANTS [FOR user]
```

该语句列出了GRANT语句，其必须复制授予给MySQL用户帐户的权限。该帐户以对于GRANT语句来说同样的格式被命名；例如，'jeffrey'@'localhost'。如果你仅指定帐户名的用户名，则使用主机名部分'％'。欲知有关指定帐户名的其他信息，请参见[Section 13.7.1.4, “GRANT Syntax”][]。

```sql
mysql> SHOW GRANTS FOR 'root'@'localhost';
+---------------------------------------------------------------------+
| Grants for root@localhost |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION |
+---------------------------------------------------------------------+
```

要列出授予给用来连接到服务器账户的权限，你可以使用下面的语句：

```sql
SHOW GRANTS;
SHOW GRANTS FOR CURRENT_USER;
SHOW GRANTS FOR CURRENT_USER();
```

如果SHOW GRANTS FOR CURRENT_USER（或者任何相等的语法）被用于DEFINER语境中，例如在存储过程中被定义为SQL SECURITY DEFINER，则所显示的授予是定义者的，而不是调用者的。

SHOW GRANTS仅显示明确授予指定帐户的权限。其他权限可用于帐户，但它们却没有显示。例如，如果一个匿名帐户存在，指定帐户可能能够使用它的权限，但是SHOW GRANTS将不显示它们。

SHOW GRANTS需要对mysql数据库有SELECT [775]权限，除了查看当前用户的权限。

#### 13.7.5.23 [SHOW INDEX 语法](#13.7.5.23)

```sql
SHOW {INDEX | INDEXES | KEYS}
    {FROM | IN} tbl_name
   [{FROM | IN} db_name]
   [WHERE expr]
```

SHOW INDEX返回表索引信息。格式类似于调用ODBC的SQLStatistics。该语句需要对表的任意列拥有某些权限。

SHOW INDEX返回下面字段：

* Table

  表的名称。

* Non_unique

  如果索引不包含副本则为0，反之则为1。

* Key_name

  索引的名称。如果索引是主要关键字，则名称总为PRIMARY。

* Seq_in_index

  索引中的列序号，以1开始。

* Column_name

  列名。

* Collation

  列如何在索引中被排序。在MySQL中，它可以有值“A”(升序)或者NULL（不能排序）。
* Cardinality

  索引中唯一值的数目的估计值。它通过运行ANALYZE TABLE或myisamchk -a来更新。Cardinality在被存储数据的基础上计作整数，所以这个值甚至对于小的表也不一定准确。基数越高，当进行连接时MySQL使用索引的机会越大。

* Sub_part

  如果列只被部分地索引，被索引字符的数量，如果整个列都被索引则为NULL。

* Packed

  表示关键字如何被紧缩。如果不是则为NULL。

* Null

  如果列可能包含NULL值则包含YES，反之则为''。

* Index_type

  用于（BTREE, FULLTEXT, HASH, RTREE）的索引方式。

* Comment

  关于没有描述在自己列中的索引信息，例如如果索引被禁用则为disabled。

* Index_comment

  当索引被创建时，含有COMMENT属性的索引所提供的任何注释。

你可以使用db_name.tbl_name作为tbl_name FROM db_name语法的替代。这两个语句是相同的：

```sql
SHOW INDEX FROM mytable FROM mydb;
SHOW INDEX FROM mydb.mytable;
```

如[Section 20.32, “Extensions to SHOW Statements”][20.32.00]中所讨论的，在更多一般的条件下，WHERE子句可以被用来选择行。

你也可以用mysqlshow -k db_name tbl_name命令来列出一张表的索引。

#### 13.7.5.24 [SHOW MASTER STATUS 语法](#13.7.5.24)

```sql
SHOW MASTER STATUS
```

该语句提供关于主服务器的二进制日志文件的状态信息。它要求或者有SUPER[776]权限或者有REPLICATION CLIENT [775]权限。

示例：

```sql
mysql> SHOW MASTER STATUS\G
*************************** 1. row ***************************
             File: master-bin.000002
         Position: 1307
     Binlog_Do_DB: test
 Binlog_Ignore_DB: manual, mysql
Executed_Gtid_Set: 3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5
1 row in set (0.00 sec)
```

Executed_Gtid_Set列被加入到MySQL 5.6.5中。当全局事务IDs在使用中，该列将显示在主服务器上已被执行的事务的GTIDs集。它和全局gtid_executed [2059]系统变量的主服务器的值是一样的（指定的gtid_done [2058]优先于MySQL 5.6.9）。

#### 13.7.5.25 [SHOW OPEN TABLES 语法](#13.7.5.25)

```sql
SHOW OPEN TABLES [{FROM | IN} db_name]
    [LIKE 'pattern' | WHERE expr]
```

SHOW OPEN TABLES列出当前在表缓存中所打开的non-TEMPORARY表。请参见[Section 8.4.3.1, “How MySQL Opens and Closes Tables”][]。如果FROM子句存在，则约束存在于db_name数据库中所显示的表。如果LIKE [1210]子句存在，则表示哪个表名相匹配。如在[Section 20.32, “Extensions to SHOW Statements”][20.32.00]中所讨论的，在更多一般的条件下，WHERE子句被用来选择行。

SHOW OPEN TABLES输出有下面这些列：

* Database

  包含表的数据库。

* Table

  表名。

* In_use

  表锁或对于表的锁请求的数量。例如，如果一个客户端通过使用LOCK TABLE t1 WRITE来获取表锁，则In_use将为1。如果当表仍然被锁定时，另一个客户端发出LOCK TABLE t1 WRITE，则客户端会阻塞等待锁，但锁定请求会导致In_use为2。如果计数为0，则表是打开的，但目前尚未被使用。In_use也通过HANDLER ... OPEN语句来增加，并通过HANDLER ... CLOSE来减少。

* Name_locked
  
  表名是否已被锁定。名称锁被用来进行操作，例如删除表或重命名表。

如果你对表没有任何权限，它将不会显示SHOW OPEN TABLES的输出。

#### 13.7.5.26 [SHOW PLUGINS 语法](#13.7.5.26)

```sql
SHOW PLUGINS
```

SHOW PLUGINS显示关于服务器插件的相关信息。插件信息在INFORMATION_SCHEMA.PLUGINS表中也有用。请参见[Section 20.15, “The INFORMATION_SCHEMA PLUGINS
Table”][20.15.00]。

SHOW PLUGINS输出的示例：

```sql
mysql> SHOW PLUGINS\G
*************************** 1. row ***************************
   Name: binlog
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 2. row ***************************
   Name: CSV
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 3. row ***************************
   Name: MEMORY
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
*************************** 4. row ***************************
   Name: MyISAM
 Status: ACTIVE
   Type: STORAGE ENGINE
Library: NULL
License: GPL
...
```

SHOW PLUGINS输出有下面这些列：

* Name：语句中被用于涉及插件的名称，例如INSTALL PLUGIN和UNINSTALL PLUGIN。

* Status：插件的状态，为ACTIVE、INACTIVE、DISABLED或者DELETED中的某一个。

* Type：插件的类型，例如STORAGE ENGINE、INFORMATION_SCHEMA或者AUTHENTICATION。

* Library：共享对象文件的插件的名称。它是语句中用于涉及到插件文件的名称，例如INSTALL PLUGIN和UNINSTALL PLUGIN。这个文件位于plugin_dir [538]系统变量所命名的目录中。如果库名为NULL，则插件被编译并且不能被UNINSTALL PLUGIN卸载。

* License：插件如何被许可；例如，GPL。

对于用INSTALL PLUGIN安装的插件来说，Name和Library值也会被注册到mysql.plugin表中。

欲知更多信息有关插件数据结构组成SHOW PLUGINS所显示的基础信息，请参见[Section 23.2, “The MySQL Plugin API”][23.02.00]。

#### 13.7.5.27 [SHOW PRIVILEGES 语法](#13.7.5.27)

```sql
SHOW PRIVILEGES
```

SHOW PRIVILEGES显示MySQ服务器所支持的系统权限的清单。权限确切的清单取决于你的服务器的版本。

```sql
mysql> SHOW PRIVILEGES\G
*************************** 1. row ***************************
Privilege: Alter
  Context: Tables
  Comment: To alter the table
*************************** 2. row ***************************
Privilege: Alter routine
  Context: Functions,Procedures
  Comment: To alter or drop stored functions/procedures
*************************** 3. row ***************************
Privilege: Create
  Context: Databases,Tables,Indexes
  Comment: To create new databases and tables
*************************** 4. row ***************************
Privilege: Create routine
  Context: Databases
  Comment: To use CREATE FUNCTION/PROCEDURE
*************************** 5. row ***************************
Privilege: Create temporary tables
  Context: Databases
  Comment: To use CREATE TEMPORARY TABLE
...
```

属于某个特定用户的权限通过SHOW GRANTS语句被显示出来。欲知更多信息，请参见
[Section 13.7.5.22, “SHOW GRANTS Syntax”][]。

#### 13.7.5.28 [SHOW PROCEDURE CODE 语法](#13.7.5.28)

```sql
SHOW PROCEDURE CODE proc_name
```

该语句是一个MySQL的扩展，仅适用于已建成的支持调试的服务器。它显示内部实现指定存储过程的一种表示法。一个类似的语句SHOW FUNCTION CODE，显示有关存储函数的信息（请参见[Section 13.7.5.20, “SHOW FUNCTION CODE Syntax”][]）。

这两个语句都需要你是程序的所有者或者对mysql.proc表拥有SELECT存取权限。

如果指定的程序是有效的，则每个语句会产生一个结果集。结果集的每一行中对应程序中的一个“指令”。第一列是Pos，它是一个从0开始的序数。第二列是Instruction，其包含一个SQL语句（通常转变于源代码），或者一个指令，其仅对于的存储程序处理程序有意义。

```sql
mysql> DELIMITER //
mysql> CREATE PROCEDURE p1 ()
    -> BEGIN
    -> DECLARE fanta INT DEFAULT 55;
    -> DROP TABLE t2;
    -> LOOP
    -> INSERT INTO t3 VALUES (fanta);
    -> END LOOP;
    -> END//
Query OK, 0 rows affected (0.00 sec)

mysql> SHOW PROCEDURE CODE p1//
+-----+----------------------------------------+
| Pos | Instruction                            |
+-----+----------------------------------------+
|   0 | set fanta@0 55                         |
|   1 | stmt 9 "DROP TABLE t2"                 |
|   2 | stmt 5 "INSERT INTO t3 VALUES (fanta)" |
|   3 | jump 2                                 |
+-----+----------------------------------------+
4 rows in set (0.00 sec)
```

在这个示例中，非执行的BEGIN和END已经消失，并且对于DECLARE variable_name语句，只有执行的部分出现（指定为默认的部分）。对于每个来自于源代码的语句，有一个后面跟着类型的代码字stmt（9意为DROP，5意为INSERT等等）。最后一行包含一个指令jump 2,，意思是GOTO instruction #2。

#### 13.7.5.29 [SHOW PROCEDURE STATUS 语法](#13.7.5.29)

```sql
SHOW PROCEDURE STATUS
    [LIKE 'pattern' | WHERE expr]
```

该语句是MySQL的一个扩展。它返回一个存储过程的特性，如数据库、名称、类型、创建者、创建和修改日期以及字符集信息。类似的语句SHOW FUNCTION STATUS显示有关存储函数的信息（请参见[Section 13.7.5.21, “SHOW FUNCTION STATUS Syntax”][]）。

如果LIKE [1210]子句存在，则表示哪个过程或者程序名相匹配。如[Section 20.32,
“Extensions to SHOW Statements”][20.32.00]所讨论的，在更多一般的条件下，WHERE子句可以用来选择行。

```sql
mysql> SHOW PROCEDURE STATUS LIKE 'sp1'\G
*************************** 1. row ***************************
                  Db: test
                Name: sp1
                Type: PROCEDURE
             Definer: testuser@localhost
            Modified: 2004-08-03 15:29:37
             Created: 2004-08-03 15:29:37
       Security_type: DEFINER
             Comment:
character_set_client: latin1
collation_connection: latin1_swedish_ci
  Database Collation: latin1_swedish_ci
```

当程序被创建时，character_set_client是character_set_client[483]系统
变量的会话值，collation_connection是collation_connection[485]系统变量的会话值。Database Collation是与程序相关联的数据库的排序规则。

你也可以从INFORMATION_SCHEMA中的ROUTINES表中获取关于存储程序的信息。请参见
[Section 20.19, “The INFORMATION_SCHEMA ROUTINES Table”][20.19.00]

#### 13.7.5.30 [SHOW PROCESSLIST 语法](#13.7.5.30)

```sql
SHOW [FULL] PROCESSLIST
```

SHOW PROCESSLIST显示你正在运行的线程。你还可以从INFORMATION_SCHEMA PROCESSLIST表或mysqladmin processlist指令得到此信息。如果你有PROCESS [775]权限，那么你可以看到所有线程。否则，你只能看到自己的线程（即你正在使用的MySQL账户相关的线程）。如果你不使用FULL关键字，只有每个语句的前100个字符显示在Info字段。

处理信息来自performance_schema.threads表中也是有效的。然而，访问threads不需要互斥，并且对服务器性能只有最小影响。INFORMATION_SCHEMA.PROCESSLIST和SHOW PROCESSLIST有相反的性能结果，因为他们需要互斥。threads也显示关于后台线程的信息，而INFORMATION_SCHEMA.PROCESSLIST和SHOW PROCESSLIST则不会。这意味着threads可以用来监控活动，这是其他线程信息源代码不能做到的。

如果你得到“太多连接”的错误消息，想搞清楚到底是怎么回事，SHOW PROCESSLIST语句是非常有用的。MySQL保留一个额外的连接以供拥有SUPER[776]权限的帐户使用，以确保管理员应该总是能够连接并检查系统（假设你没有把这个权限给所有的用户）。

线程可以被KILL语句取消掉。请参见[Section 13.7.6.4, “KILL Syntax”][]。

这里有一个SHOW PROCESSLIST输出的示例：

```sql
mysql> SHOW FULL PROCESSLIST\G
*************************** 1. row ***************************
Id: 1
User: system user
Host:
db: NULL
Command: Connect
Time: 1030455
State: Waiting for master to send event
Info: NULL
*************************** 2. row ***************************
Id: 2
User: system user
Host:
db: NULL
Command: Connect
Time: 1004
State: Has read all relay log; waiting for the slave
       I/O thread to update it
Info: NULL
*************************** 3. row ***************************
Id: 3112
User: replikator
Host: artemis:2204
db: NULL
Command: Binlog Dump
Time: 2144
State: Has sent all binlog to slave; waiting for binlog to be updated
Info: NULL
*************************** 4. row ***************************
Id: 3113
User: replikator
Host: iconnect2:45781
db: NULL
Command: Binlog Dump
Time: 2086
State: Has sent all binlog to slave; waiting for binlog to be updated
Info: NULL
*************************** 5. row ***************************
Id: 3123
User: stefan
Host: localhost
db: apollon
Command: Query
Time: 0
State: NULL
Info: SHOW FULL PROCESSLIST
5 rows in set (0.00 sec)
```

SHOW PROCESSLIST所生成的列有下面的意义：

* Id

  连接身份标识。

* User

  发出这个语句的MySQL用户。如果这是system user，它指的是由服务器内部处理任务所生成的非客户端线程。这可能是用在复制从服务器或延迟行处理程序上的I/O 或 SQL线程。unauthenticated user指的是与客户端连接相关的一个线程，但是其客户端用户认证尚未完成。event_scheduler指的是监视预定事件的线程。对于system user 来说，在Host列没有指定的主机。

* Host

  发出这个语句的客户端的主机名（除了没有主机的system user以外）。SHOW PROCESSLIST以host_name:client_port格式来为TCP/IP连接报告主机名，使其容易确定哪些客户端是做什么的。

* db

  默认的数据库，如果一个已经被选择，否则为NULL。

* Command

  线程正在执行的指令的类型。对于线程指令的注释，请参见[Section 8.12.5, “Examining Thread Information”][08.12.05]。这一列的值对应客户端/服务器协议的COM_xxx指令和Com_xxx状态变量。请参见[Section 5.1.6,“Server Status Variables”][05.01.06]。

* Time

  线程一直处于其当前状态的时间,以秒为单位。

* State

  一个活动、事件或者状态表示线程正在做什么。关于State值的描述参见[Section 8.12.5, “Examining Thread Information”][]。
  
  大多数状态对应非常快捷的操作。如果一个线程停留在一个给定的状态许多秒，那么可能有一个需要进行调查的问题。
  
  对于SHOW PROCESSLIST语句来说，State的值为NULL。

* Info

  显示线程正在执行时的语句，或者，如果不执行任何语句则显示NULL。语句可能是被发送给服务器中的一个，或者，如果该语句执行其他语句，则为最里面的语句。例如，如果CALL语句执行正在SELECT语句中执行的存储过程，那么Info值显示SELECT语句。
#### 13.7.5.31 [SHOW PROFILE 语法](#13.7.5.31)

```sql
SHOW PROFILE [type [, type] ... ]
    [FOR QUERY n]
    [LIMIT row_count [OFFSET offset]]
    
type:
    ALL
  | BLOCK IO
  | CONTEXT SWITCHES
  | CPU
  | IPC
  | MEMORY
  | PAGE FAULTS
  | SOURCE
  | SWAPS
```

SHOW PROFILE和SHOW PROFILES语句显示配置信息，其表示在当前会话过程中所执行语句的资源使用情况。

> ** Note **
>
>这个语句在MySQL 5.6.7中已被弃用，并且在未来的MySQL发布版本中会被删除。使用
Performance Schema作为替代；请参见 [Chapter 21,MySQL Performance Schema][21.00.00]。

配置被profiling [539]会话变量所控制，其有一个默认值为0（OFF）。配置通过设置profiling [539]为1或ON来启用：

```sql
mysql> SET profiling = 1;
```

SHOW PROFILES显示最近发送给服务器的语句的列表。这个列表的大小受控于profiling_history_size [539]会话值，其有一个默认值15。最大值为100.将值设置为0对于禁用配置有实际影响。

除了SHOW PROFILE和SHOW PROFILES，所有语句都被配置，所以你不会在配置文件列表中发现这两个语句中的任一个。有缺陷的语句会被配置。例如，SHOW PROFILING是一个非法的语句，如果你尝试执行它会出现一个语法错误，但它会显示在配置列表中。

SHOW PROFILE显示单个语句的详细信息。没有FOR QUERY n子句，输出涉及到最近执行的语句。如果包含FOR QUERY n，则SHOW PROFILE显示关于语句n的信息。n的值相当于SHOW PROFILES所显示的Query_ID值。

LIMIT row_count子句可能被用于限制输出到row_count行。如果LIMIT被给出，OFFSET offset可能从输出offset行开始被添加到整行。

默认情况下，SHOW PROFILE显示Status和Duration列。Status值与SHOW PROCESSLIST所显示的State值一样，尽管可能这两个语句对于一些状态值在解释上稍微有一些小小的不同。（参见[Section 8.12.5, “Examining Thread Information”][08.12.05]）。

任选的type值可能被指定为显示具体的信息的其他类型：

* ALL显示所有信息

* BLOCK IO显示阻塞输入和输出操作的计数

* CONTEXT SWITCHES显示自发和非自发的环境切换的计数

* CPU显示用户和系统的CPU使用时间

* IPC显示消息发送和接受的计数

* MEMORY当前没有实现

* PAGE FAULTS显示最大和最小分页错误的计数

* SOURCE显示来自源代码的程序名，连同程序发生的文件的名称和行号

* SWAPS显示交换计数

配置每个会话都会启用。当一个会话结束时，其配置信息会丢失。

```sql
mysql> SELECT @@profiling;
+-------------+
| @@profiling |
+-------------+
| 0 |
+-------------+
1 row in set (0.00 sec)

mysql> SET profiling = 1;
Query OK, 0 rows affected (0.00 sec)

mysql> DROP TABLE IF EXISTS t1;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> CREATE TABLE T1 (id INT);
Query OK, 0 rows affected (0.01 sec)

mysql> SHOW PROFILES;
+----------+----------+--------------------------+
| Query_ID | Duration | Query                    |
+----------+----------+--------------------------+
| 0        | 0.000088 | SET PROFILING = 1        |
| 1        | 0.000136 | DROP TABLE IF EXISTS t1  |
| 2        | 0.011947 | CREATE TABLE t1 (id INT) |
+----------+----------+--------------------------+
3 rows in set (0.00 sec)

mysql> SHOW PROFILE;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| checking permissions | 0.000040 |
| creating table       | 0.000056 |
| After create         | 0.011363 |
| query end            | 0.000375 |
| freeing items        | 0.000089 |
| logging slow query   | 0.000019 |
| cleaning up          | 0.000005 |
+----------------------+----------+
7 rows in set (0.00 sec)

mysql> SHOW PROFILE FOR QUERY 1;
+--------------------+----------+
| Status             | Duration |
+--------------------+----------+
| query end          | 0.000107 |
| freeing items      | 0.000008 |
| logging slow query | 0.000015 |
| cleaning up        | 0.000006 |
+--------------------+----------+
4 rows in set (0.00 sec)

mysql> SHOW PROFILE CPU FOR QUERY 2;
+----------------------+----------+----------+------------+
| Status               | Duration | CPU_user | CPU_system |
+----------------------+----------+----------+------------+
| checking permissions | 0.000040 | 0.000038 | 0.000002   |
| creating table       | 0.000056 | 0.000028 | 0.000028   |
| After create         | 0.011363 | 0.000217 | 0.001571   |
| query end            | 0.000375 | 0.000013 | 0.000028   |
| freeing items        | 0.000089 | 0.000010 | 0.000014   |
| logging slow query   | 0.000019 | 0.000009 | 0.000010   |
| cleaning up          | 0.000005 | 0.000003 | 0.000002   |
+----------------------+----------+----------+------------+
7 rows in set (0.00 sec)
```

> ** Note **
>
>配置仅在某些体系中有部分功能。对于取决于getrusage（）系统调用的值，NULL在系统上被返回，例如不支持调用的Windows。此外，配置是对于每个进程的而不是每个线程。这意味着不同于你自己的服务器内线程上的活动可能会影响你所见到的时间信息。

你可以从INFORMATION_SCHEMA中的PROFILING table表中得到配置信息。参见
[Section 20.17, “The INFORMATION_SCHEMA PROFILING Table”][20.17.00]。例如，下面查询产生相同的结果：

```sql
SHOW PROFILE FOR QUERY 2;

SELECT STATE, FORMAT(DURATION, 6) AS DURATION
FROM INFORMATION_SCHEMA.PROFILING
WHERE QUERY_ID = 2 ORDER BY SEQ;
```

#### 13.7.5.32 [SHOW PROCESSLIST 语法](#13.7.5.32)

```sql
SHOW PROFILES
```
SHOW PROFILES语句连同SHOW PROFILE都显示配置信息，其表明当前会话过程中所执行语句的资源使用情况。相关更多信息，请参见[Section 13.7.5.31, “SHOW PROFILE Syntax”](###13.07.05.31 SHOW PROFILE Syntax)。

> ** Note **
>
>这些语句在MySQL 5.6.7中已被弃用，并且在未来的MySQL发布版本中会被删除。使用
Performance Schema作为替代；请参见 [Chapter 21,MySQL Performance Schema][21.00.00]。

#### 13.7.5.33 [SHOW RELAYLOG EVENTS 语法](#13.7.5.33)

```sql
SHOW RELAYLOG EVENTS
   [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count]
```

显示复制从服务器中继日志中的事件。如果你不指定'log_name'，将显示第一个中继日志。该语句对主服务器无效。

LIMIT子句对于SELECT语句有相同的语法。请参见[Section 13.2.9, “SELECT Syntax”] [13.02.09]。

> ** Note **
>
>发出一个不带LIMIT子句的SHOW RELAYLOG EVENTS，可以启动一个非常耗费时间和资源的过程，因为服务器会返回给客户端中继日志的完整内容（包括从服务器所接收到的所有语句修改数据）。

> ** Note **
>
>与用户和系统变量的设置相关的一些事件不包含在SHOW RELAYLOG EVENTS的输出。为了得到中继日志中完整范围的事件，请使用mysqlbinlog。

#### 13.7.5.34 [SHOW SLAVE HOSTS 语法](#13.7.5.34)

```sql
SHOW SLAVE HOSTS
```

显示当前在主服务器上注册的复制从服务器列表。

这个列表显示于任何服务器上（不仅仅主服务器）。输出像这样：

```sql
mysql> SHOW SLAVE HOSTS;
+-----------+-----------+-------+-----------+--------------------------------------+
| Server_id | Host       | Port | Master_id | Slave_UUID                           |
+-----------+-----------+-------+-----------+--------------------------------------+
| 192168010  | iconnect2 | 3306 | 192168011 | 14cb6624-7f93-11e0-b2c0-c80aa9429562 |
| 1921680101 | athena    | 3306 | 192168011 | 07af4990-f41f-11df-a566-7ac56fdaf645 |
+------------+-----------+------+-----------+--------------------------------------+
```

* Server_id：从服务器的唯一服务器ID，其配置于服务器的选项文件中，或在以--server-id=value [1991]的命令行上。

* Host：从服务器的主机名，其配置于服务器的选项文件中，或在以--report-host=host_name [2015]的命令行上。请注意，这可以区别于配置在操作系统中的机器名。

* Port：从无服务器正在监听的端口。

  在MySQL 5.6.5和之后的版本中，该列中的零意味着从服务器端口（(--report-port [2016]）没有被设置。MySQL 5.6.5之前的版本中，3306被用于作为该情况下的默认值（错误 #13333431）。

* Master_id：从服务器复制于主服务器的唯一服务器ID。

* Slave_UUID：该从服务器的全局唯一ID，其在从服务器上生成并且在从服务器的auto.cnf文件中被找到。
  
  这一列在MySQL 5.6.0.被添加。

#### 13.7.5.35 [SHOW SLAVE STATUS 语法](#13.7.5.35)

```sql
SHOW SLAVE STATUS
```

此语句提供关于从服务器线程基本参数的状态信息。它需要或者SUPER [776]权限或者REPLICATION CLIENT [775]权限。

如果你使用mysql客户端发出这个语句，你可以使用\G语句结束符而不是分号来获取更可读的垂直布局。

```sql
mysql> SHOW SLAVE STATUS\G
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: localhost
                  Master_User: root
                  Master_Port: 13000
                Connect_Retry: 60
              Master_Log_File: master-bin.000002
          Read_Master_Log_Pos: 1307
               Relay_Log_File: slave-relay-bin.000003
                Relay_Log_Pos: 1508
        Relay_Master_Log_File: master-bin.000002
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB:
          Replicate_Ignore_DB:
           Replicate_Do_Table:
       Replicate_Ignore_Table:
      Replicate_Wild_Do_Table:
  Replicate_Wild_Ignore_Table:
                   Last_Errno: 0
                   Last_Error:
                 Skip_Counter: 0
          Exec_Master_Log_Pos: 1307
              Relay_Log_Space: 1858
              Until_Condition: None
               Until_Log_File:
                Until_Log_Pos: 0
           Master_SSL_Allowed: No
           Master_SSL_CA_File:
           Master_SSL_CA_Path:
              Master_SSL_Cert:
            Master_SSL_Cipher:
               Master_SSL_Key:
        Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
                Last_IO_Errno: 0
                Last_IO_Error:
               Last_SQL_Errno: 0
               Last_SQL_Error:
  Replicate_Ignore_Server_Ids:
             Master_Server_Id: 1
                  Master_UUID: 3e11fa47-71ca-11e1-9e33-c80aa9429562
             Master_Info_File: /var/mysqld.2/data/master.info
                    SQL_Delay: 0
          SQL_Remaining_Delay: NULL
      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it
           Master_Retry_Count: 10
                  Master_Bind:
      Last_IO_Error_Timestamp:
     Last_SQL_Error_Timestamp:
               Master_SSL_Crl:
           Master_SSL_Crlpath:
           Retrieved_Gtid_Set: 3e11fa47-71ca-11e1-9e33-c80aa9429562:1-5
            Executed_Gtid_Set: 3e11fa47-71ca-11e1-9e33-c80aa9429562:1-5
                Auto_Position: 1
1 row in set (0.00 sec)
```

下面的列表描述了SHOW SLAVE STATUS所返回的字段。欲知更多有关解释其意义的信息，请参见[Section 8.12.5.6, “Replication Slave I/O Thread States”](####08.12.05.06 Replication Slave I/O Thread States)。

* Slave_IO_State

  SHOW PROCESSLIST为从服务器I/O线程输出的State字段的拷贝。这告诉你线程是这样做的：试图连接到主服务器，等待来自主服务器的事件，重新连接到主服务器，以此类推。可能出现的状态的列表，请参见[Section 8.12.5.6,“Replication Slave I/O Thread States”](#### 08.12.05.06 Replication Slave I/O Thread States )。

* Master_Host

  从服务器所连接到的主机。

* Master_User

  用来连接主服务器的账户的用户名。

* Master_Port

  用来连接主服务器的端口。

* Connect_Retry

  重试连接之间的秒数（默认为60）。它可以通过CHANGE MASTER TO语句来进行设置。

* Master_Log_File

  I/O线程当前读取的主服务器二进制日志文件的名称。

* Read_Master_Log_Pos

  I/O线程读取到当前主服务器二进制日志文件的位置。

* Relay_Log_File

  SQL线程当前读取和执行的中继日志文件的名称。

* Relay_Log_Pos

  SQL线程读取并执行到当前中继日志文件的位置。

* Relay_Master_Log_File

  包含被SQL线程执行的最近事件的主服务器二进制日志文件的名称。

* Slave_IO_Running

  I/O线程是否启动，并且是否已经成功连接到主服务器。内在地，这个线程的状态用下面三个值中的一个代表：
  
  * MYSQL_SLAVE_NOT_RUN。   从服务器I/O线程不在运行中。关于这个状态，Slave_IO_Running为No。
 
  * MYSQL_SLAVE_RUN_NOT_CONNECT。   从服务器I/O线程在运行中，但并没连接到复制主服务器。关于这个状态，Slave_IO_Running取决于显示在下面表中的服务器版本。
    <table summary="For the MYSQL_SLAVE_RUN_NOT_CONNECT state,Slave_IO_Running depends on theMySQL server version. This table shows MySQL version dependency for Slave_IO_Running." border="1"><colgroup><col><col></colgroup><thead>
<tr>
    <th scope="col">MySQL版本</th><th scope="col"><code class="literal">Slave_IO_Running</code></th>
</tr> </thead><tbody>
<tr>
    <td scope="row">4.1 (4.1.13及其之前版本); 5.0 (5.0.11及其之前版本)</td><td><code class="literal">Yes</code></td>
</tr>
<tr>
    <td scope="row">4.1 (4.1.14及其之后版本); 5.0 (5.0.12及其之后版本)</td><td><code class="literal">No</code></td>
</tr>
<tr>
    <td scope="row">5.1 (5.1.45及其之前版本)</td><td><code class="literal">No</code></td>
</tr>
<tr>
    <td scope="row">5.1 (5.1.46及其之后版本); 5.5; 5.6</td><td><code class="literal">Connecting</code></td>
</tr></tbody></table>

  * MYSQL_SLAVE_RUN_CONNECT。   从服务器I/O线程正在运行，并连接到复制主服务器。关于这个状态，Slave_IO_Running为Yes。
  
    Slave_running [614]系统状态变量的值与这个值一致。

* Slave_SQL_Running

  SQL线程是否启动。

* Replicate_Do_DB, Replicate_Ignore_DB

  如果有的话，以--replicate-do-db [2010]和replicate-ignore-db [2011]选项所指定的数据库列表。

* Replicate_Do_Table, Replicate_Ignore_Table, Replicate_Wild_Do_Table,
Replicate_Wild_Ignore_Table

  如果有的话，以--replicate-do-table [2012]，--replicate-ignore-table [2013]，--replicate-wild-do-table [2014]及--replicate-wildignore-table [2014]选项所指定的表的列表。

* Last_Errno, Last_Error

  这两列是Last_SQL_Errno和Last_SQL_Error的别名。
  
  发出RESET MASTER或RESET SLAVE来重新设置显示在这两列中的值。
  
  > ** Note **
  >
  >当从服务器SQL线程接收到一个错误时，首先它会报错，然后停止该SQL线程。这意味着，即使Slave_SQL_Running仍然显示Yes，有一个小的时间窗口SHOW SLAVE STATUS 会显示一个非零值。

* Skip_Counter

  sql_slave_skip_counter [2034]系统变量的当前值。请参见[Section 13.4.2.4,“SET GLOBAL sql_slave_skip_counter Syntax”](#### 13.04.02.04 SET GLOBAL sql_slave_skip_counter Syntax)。

* Exec_Master_Log_Pos

  SQL线程在当前主服务器二进制日志文件中读取和执行到的位置，标记着下一个要处理的事务或事件的开始。当从一个存在的从服务器中启动新的从服务器时，你可以使用该值和CHANGE MASTER TO语句的MASTER_LOG_POS选项，从而新的从服务器从这个点开始读取。主服务器的二进制日志中（Relay_Master_Log_File，Exec_Master_Log_Pos）所给出的坐标对应中继日志中（RELAY_LOG_FILE，RELAY_LOG_POS）所给出的坐标。
  
  当使用多线程的从服务器时（在MySQL5.6.3和更高版本通过设置slave_parallel_workers[2029]为非零值），在此列中的值实际上代表“低水平”标志，在这之前没有未提交的事务存在。因为当前实现所允许的在不同的数据库上以不同的顺序执行的事务在从服务器上，而不在主服务器上，这不一定是最近执行的事务的位置。
  
* Relay_Log_Space

  所有存在的中继日志文件的总大小。

* Until_Condition, Until_Log_File, Until_Log_Pos
  
  START SLAVE语句的UNTIL子句中指定的值。

  Until_Condition包含这些值：
  
  * 若没有UNTIL子句被指定，则为None
  
  * 若从服务器一直读到主服务器二进制日志中的给定位置，则为Master
  
  * 若从服务器一直读到中继日志中的给定位置，则为Relay

  Until_Log_File和Until_Log_Pos表示日志文件名称和定义为SQL线程停止执行所在坐标的位置。

* Master_SSL_Allowed, Master_SSL_CA_File, Master_SSL_CA_Path, Master_SSL_Cert,Master_SSL_Cipher, Master_SSL_CRL_File, Master_SSL_CRL_Path, Master_SSL_Key,Master_SSL_Verify_Server_Cert

  如果有，则这些字段显示用于从服务器连接到主服务器的SSL参数。
  
  Master_SSL_Allowed包含这些值：
  
  * 若SSL连接到主服务器被允许，则为Yes
  
  * 若SSL连接到主服务器不被允许，则为No
  
  * 若SSL连接被允许但是从服务器禁用SSL支持，则为Ignored

  其他SSL相关字段的值对应MASTER_SSL_CA，MASTER_SSL_CAPATH MASTER_SSL_CERT，MASTER_SSL_CIPHER MASTER_SSL_CRL，MASTER_SSL_CRLPATH，MASTER_SSL_KEY的值，以及CHANGE MASTER TO语句的MASTER_SSL_VERIFY_SERVER_CERT选项。参见[Section 13.4.2.1, “CHANGE MASTER TO Syntax”](#### 13.04.02.01 CHANGE MASTER TO Syntax)。
  
  Master_SSL_CRL_File和Master_SSL_CRL_Path被添加入MySQL 5.6.3。
  
* Seconds_Behind_Master

  这个字段象征从服务器如何“晚”：
  
  * 当从服务器积极处理更新时，此字段显示从服务器上的时间戳，以及登录在主服务器上为当前正在从服务器上处理的大部分事件的以前的时间戳之间的区别。
  
  * 当没有事件运行在在从服务器上时，这个值为0。
  
  从本质上讲，这个字段测量短时间内从服务器SQL线程和从服务器I/O线程之间的时间差。如果主服务器和从服务器之间的网络连接速度快，则从服务器I/O线程非常接近于主服务器，所以该字段是一个很好的近似值，表明与主服务器相比从服务器SQL线程如何“晚”。如果网络速度慢，这是不是一个很好的近似值;从服务器SQL线程可能经常被慢读从服务器I/O线程赶上，所以Seconds_Behind_Master经常显示一个值为0，即使与主服务器相比I/O线程延迟。换句话说，这一列仅对较快的网络有用。

  假如从服务器I/O线程启动时所计算的时间差从那时候开始保持不变，即使主服务器和从服务器有不同的钟点，时间差计算也有效。任何更改——包括NTP更新——可能会导致可以计算Seconds_Behind_Master的时钟脉冲相位差不太可靠。
  
  在MySQL 5.6.9和更高版本中，如果从服务器SQL线程不在运行中，或者SQL线程已经消耗完所有的中继日志并且从服务器I/O线程不在运行中，则该字段为NULL（没有被定义或者未知的）。在以前，如果从服务器SQL线程或从服务器I/O线程不在运行中，或者没有连接到主服务器，则该字段为NULL。（错误#12946333）例如，如果（MySQL5.6.9之前版本）从服务器I/O线程正在运行中但是没有连接到主服务器，并且在连接之前CHANGE MASTER TO语句或者--master-connect-retry [2023]选项（默认值为60）所给定的秒数都处于休眠状态，该值为 NULL。现在在这种情况下，到主服务器的连接没有被测试;相反，如果I/O线程正在运行中但中继日志被用尽，则Seconds_Behind_Master被设置为0。

  Seconds_Behind_Master的值以存储在事件中的时间戳为基础，它通过复制被保存。这意味着，如果主服务器M1本身是从服务器M0，则来源于M0二进制日志的M1二进制日志中的任何事件有对该事件的M0的时间戳。这使得MySQL复制TIMESTAMP能成功。然而，如果M1也从客户端收到直接更新，则Seconds_Behind_Master的问题是Seconds_Behind_Master的值随机波动，因为有时M1的最后一个事件来源于M0，有时是在M1上直接更新的结果。
  
  当使用多线程的从服务器（MySQL5.6.3和更高版本）时，你应该记住这个值以Exec_Master_Log_Pos为基础，所以可能无法反映最近已提交事务的位置。

* Last_IO_Errno, Last_IO_Error

  导致I/O线程停止的最后错误的错误数和错误信息。错误数0和空字符串的信息意味着“没有错误”。如果Last_IO_Error值非空，则错误值也会出现在从服务器中的错误日志中。
  
  从MySQL 5.6.1开始，I/O错误信息包含一个时间戳，显示最近的I/O线程错误所发生的时间。该时间戳使用YYMMDD HH:MM:SS格式。
  
  MySQL 5.6.3之前版本中，该时间戳前置到显示于Last_IO_Error列中的错误信息文本。在MySQL 5.6.3和更高版本中，该时间戳相反在Last_SQL_Error_Timestamp列中出现。
  
  发出RESET MASTER或者RESET SLAVE重新设置显示于这些列中的值。

* Last_SQL_Errno, Last_SQL_Error

  导致SQL线程停止的最后错误的错误数和错误信息。错误数0和空字符串的信息意味着“没有错误”。如果Last_SQL_Error值非空，则错误值也会出现在从服务器中的错误日志中。
  
  从MySQL 5.6.1开始，SQL错误信息包含一个时间戳，显示最近的SQL线程错误所发生的时间。该时间戳使用YYMMDD HH:MM:SS格式。
  
  MySQL 5.6.3之前版本中，该时间戳前置到显示于Last_SQL_Error列中的错误信息文本。在MySQL 5.6.3和更高版本中，该时间戳相反在Last_SQL_Error_Timestamp列中出现。
  
  发出RESET MASTER或者RESET SLAVE重新设置显示于这些列中的值。

* Replicate_Ignore_Server_Ids

  在MySQL 5.6中，你可以使用CHANGE MASTER TO语句中的IGNORE_SERVER_IDS选项，告知从服务器从0或者更多主服务器中忽略事件。当使用循环或者其它多主机复制设置时，这通常仅仅是兴趣。
  
  Replicate_Ignore_Server_Ids所显示的信息包含一个或者多个空格隔开的列表，第一个值表示被忽略的服务器数量；如果不为0（默认值），这个服务器计数值后面跟着实际服务器IDs。例如，如果包含IGNORE_SERVER_IDS = (2,6,9)选项的CHANGE MASTER TO语句已经被发出，告知从服务器忽略具有服务器ID为2、6或9的主服务器，则该信息显示如下：
  
  ```sql
  Replicate_Ignore_Server_Ids: 3 2 6 9
  ```

* Master_Server_Id

  来自主服务器的server_id [552]值。

* Master_UUID

  来自主服务器的server_uuid [1992]值。该字段被添加于MySQL 5.6.0中。

* Master_Info_File

  master.info文件的位置。该字段被添加于MySQL 5.6.0中。

* SQL_Delay

  从服务器必须延迟于主服务器的秒数。该字段被添加于MySQL 5.6.0中。

* SQL_Remaining_Delay

  当Slave_SQL_Running_State是Waiting until MASTER_DELAY seconds after master executed event时，该字段包含剩余延迟的秒数。在其它时候，该字段为NULL。该字段被添加于MySQL 5.6.0中。

* Slave_SQL_Running_State

  SQL线程的状态（与Slave_IO_State相似）。这个值与SHOW PROCESSLIST所显示的SQL线程的State值相同；参见[Section 8.12.5.7, “Replication Slave SQL Thread States”](#### 08.12.05.07 Replication Slave SQL Thread States)，提供可能状态的列表。该字段被添加于MySQL 5.6.0中。

* Master_Retry_Count

  在丢失连接的事件中，从服务器可以试图重新连接到主服务器的次数。通过使用CHANGE MASTER TO语句中的MASTER_RETRY_COUNT选项（首选的）或者较旧的--master-retry-count [2006]服务器选项（仍然支持向后兼容），该值可以被设置。该字段被添加于MySQL 5.6.1中。

* Master_Bind

  显示从服务器绑定到的网络接口，若有的话，使用CHANGE MASTER TO语句的MASTER_BIND选项来进行设置。
  
  该列被添加于MySQL 5.6.2中。

* Last_IO_Error_Timestamp

  YYMMDD HH:MM:SS格式的时间戳显示最近的I/O错误所发生的时间。
  
  该列被添加于MySQL 5.6.3中。MySQL 5.6之前的版本中，该时间戳前置到显示于Last_IO_Error中的错误文本。

* Last_SQL_Error_Timestamp

  YYMMDD HH:MM:SS格式的时间戳显示最近的SQL错误所发生的时间。
  
  该列被添加于MySQL 5.6.3中。MySQL 5.6之前的版本中，该时间戳前置到显示于Last_SQL_Error中的错误文本。

* Retrieved_Gtid_Set

  与从服务器所接收到的所有事物相一致的全局事务IDs的设置。如果GTIDs不被使用，则为空。
  
  该列被添加于MySQL 5.6.5中。
  
  MySQL 5.6.10之前的版本中，该值使用大写字母印刷。在MySQL 5.6.10和更高版本中，它总是使用小写字母印刷。（错误#15869441）

* Executed_Gtid_Set

  与随后在从服务器上执行的所有被接收的事物相一致的全局事务IDs的设置。如果GTIDs不被使用，则为空。
  
  该列被添加于MySQL 5.6.5中。
  
  MySQL 5.6.10之前的版本中，该值使用大写字母印刷。在MySQL 5.6.10和更高版本中，它总是使用小写字母印刷。（错误#15869441）

* Auto_Position

  如果自动定位在使用中，则该列的值为1；否则它为0。
  
  该列被添加于MySQL 5.6.10中。（错误#15992220）


#### 13.7.5.36 [SHOW STATUS 语法](#13.7.5.36)

```sql
SHOW [GLOBAL | SESSION] STATUS
    [LIKE 'pattern' | WHERE expr]
```

SHOW STATUS提供服务器状态信息。信息也能通过使用mysqladmin extended-status指令被获取。若LIKE [1210]子句存在，则表示哪个变量名称相匹配。如[Section 20.32, “Extensions to SHOW Statements”][20.32.00]所讨论的，WHERE子句可以在更多一般条件下用来选择行。这个语句不需要任何权限。它仅需要能连接到服务器。

部分输出显示如下。名称和值的列表可能对你的服务器来说不同。每个变量的意思在[Section 5.1.6, “Server Status Variables”][05.01.06]中被给出。

```sql
mysql> SHOW STATUS;
+--------------------------+------------+
| Variable_name            | Value      |
+--------------------------+------------+
| Aborted_clients          | 0          |
| Aborted_connects         | 0          |
| Bytes_received           | 155372598  |
| Bytes_sent               | 1176560426 |
| Connections              | 30023      |
| Created_tmp_disk_tables  | 0          |
| Created_tmp_tables       | 8340       |
| Created_tmp_files        | 60         |
...
| Open_tables              | 1          |
| Open_files               | 2          |
| Open_streams             | 0          |
| Opened_tables            | 44600      |
| Questions                | 2026873    |
...
| Table_locks_immediate    | 1920382    |
| Table_locks_waited       | 0          |
| Threads_cached           | 0          |
| Threads_created          | 30022      |
| Threads_connected        | 1          |
| Threads_running          | 1          |
| Uptime                   | 80380      |
+--------------------------+------------+
```

使用LIKE [1210]子句，该语句仅显示行关于名称匹配该形式的这些变量。

```sql
mysql> SHOW STATUS LIKE 'Key%';
+--------------------+----------+
| Variable_name      | Value    |
+--------------------+----------+
| Key_blocks_used    | 14955    |
| Key_read_requests  | 96854827 |
| Key_reads          | 162040   |
| Key_write_requests | 7589728  |
| Key_writes         | 3813196  |
+--------------------+----------+
```

使用GLOBAL修饰符，SHOW STATUS显示所有连接到MySQL的状态值。使用SESSION，它为当前连接显示状态值。如果没有修饰符存在，默认值为SESSION。LOCAL是SESSION的同义词。

有些状态变量只有一个全局值。对于这些，你会为GLOBAL和SESSION得到相同的值。每个状态变量的范围列在[Section 5.1.6, “Server Status Variables”][05.01.06]中。

SHOW STATUS语句的每次调用都使用一个内部的临时表和全局Created_tmp_tables[604]值的增量。

#### 13.7.5.37 [SHOW TABLE STATUS 语法](#13.7.5.37)

```sql
SHOW TABLE STATUS [{FROM | IN} db_name]
    [LIKE 'pattern' | WHERE expr]
```

SHOW TABLE STATUS像SHOW TABLES一样工作，但是提供许多关于每个非TEMPORARY表的信息。你可以通过使用mysqlshow --status db_name指令获取该列表。若LIKE [1210]子句存在，则表示哪个表名相匹配。如[Section 20.32,“Extensions to SHOW Statements”][20.32.00]所讨论的，WHERE子句可以在使用更多一般条件下被用来选择行。

这个语句也显示视图相关的信息。

SHOW TABLE STATUS输出有下面这些列：

* Name

  表的名称。

* Engine

  表的存储引擎。参见[Chapter 14, Storage Engines][14.00.00]。

* Version

  表的.frm文件的版本号。

* Row_format

  行存储格式（Fixed, Dynamic, Compressed, Redundant, Compact）。对于MyISAM表来说，Dynamic对应myisamchk -dvv报告为Packed。InnoDB表的格式报告为Redundant或Compact。对于InnoDB Plugin的Barracuda文件格式来说，可能是Compressed或Dynamic。

* Rows

  行数。一些存储引擎，例如MyISAM，存储精确的计数。对于其他存储引擎，例如InnoDB，这个值是一个近似值，并且可能会随着实际值变化高达40-50%。在这种情况下，使用SELECT COUNT(*)来得到一个精确的计数。
  
  在INFORMATION_SCHEMA数据库中，表的Rows值为NULL。

* Avg_row_length

  平均行长度。

* Data_length

  数据文件的长度。

* Max_data_length

  数据文件的最大长度。考虑到适用的数据指针的大小，这是可以被存储在表中的数据的总字节数。

* Index_length

  索引文件的长度。

* Data_free

  已分配但未使用的字节数。
  
  对于InnoDB表，该信息也会被显示（以前它在Comment值里面）。InnoDB表报告表所属的表空间的可用空间。对于位于共享表空间的表，这是共享表空间的可用空间。如果你正在使用多重表空间并且表有其自己的表空间，那么可用空间仅对于这个表。可用空间指完全空闲的1MB区间数减去一个安全边际。即使可用空间显示为0时，只要新的区间没有被分配它可能会插入行。

  对于分区表，这个值只是一个估计值，可能不是完全正确的。在这种情况下，获取此信息的一个更准确的方法是查询INFORMATION_SCHEMA.PARTITIONS表，如本例中所示：
  
  ```sql
  SELECT SUM(DATA_FREE)
      FROM INFORMATION_SCHEMA.PARTITIONS
      WHERE TABLE_SCHEMA = 'mydb'
      AND TABLE_NAME = 'mytable';
  ```
  
  欲知更多信息，请参见[Section 20.14, “The INFORMATION_SCHEMA PARTITIONS Table”][20.14.00]。

* Auto_increment

  下一个AUTO_INCREMENT值。

* Create_time

  表被创建的时间。

* Update_time

  数据文件最后更新的时间。对于一些存储引擎，这个值为NULL。例如，InnoDB将多个表存储在其system tablespace中，并且数据文件的时间戳并不适用。即使对单独的.ibd文件中的每个InnoDB表用file-per-table模式，change buffering会延迟写入到数据文件中，使文件的修改时间是从最后插入的时间不同，
更新或删除。对于MyISAM数据文件的时间戳使用，然而，在Windows上的时间戳
不更新的更新，所以价值是不准确的。

* Check_time

  表最后被检查的时间。不是所有存储引擎都在这个时间更新，在这种情况下该值总为NULL。

* Collation

  表的字符集和排序规则。

* Checksum

  现场校验值（若有的话）。

* Create_options

  使用CREATE TABLE的额外选项。当CREATE TABLE被调用时所提供的原有选项被保留，并且这里所记录的选项可能与活动表设置和选项不同。

* Comment

  当创建表时所使用的注释（或为什么MySQL不能访问信息
表信息）。

对于MEMORY表，Data_length，Max_data_length，Index_length值近似
所分配内存的实际数量。分配算法储存大量内存以减少分配操作的数目。

对于NDB表，除了BLOB列不考虑在内，该语句的输出显示Avg_row_length和Data_length列适当的值。

对于视图，除了Name表示视图名和Comment说view，通过SHOW TABLE STATUS显示的所有字段都为NULL。

#### 13.7.5.38 [SHOW TABLES 语法](#13.7.5.38)

```sql
SHOW [FULL] TABLES [{FROM | IN} db_name]
    [LIKE 'pattern' | WHERE expr]
```

SHOW TABLES在给定的数据库中列出非TEMPORARY表。你也可以使用mysqlshow db_name命令来获得此列表。如果有LIKE [1210]子句，则表示哪个表名相匹配。如[Section 20.32, “Extensions to SHOW Statements”][20.32.00]所讨论的，WHERE子句可以在使用更多一般的条件下用来选择行。

由LIKE子句执行的匹配依赖于lower_case_table_names[516]系统变量的设置。

该语句还列出数据库中的所有视图。FULL修饰符支持例如SHOW FULL TABLES 显示第二输出列。第二列的值是表的BASE TABLE和视图的VIEW。
如果你对基表或视图没有任何权限，它将不会通过SHOW TABLES或mysqlshow db_name显示在输出中。

#### 13.7.5.39 [SHOW TRIGGERS 语法](#13.7.5.39)

```sql
SHOW TRIGGERS [{FROM | IN} db_name]
    [LIKE 'pattern' | WHERE expr]
```

SHOW TRIGGERS将当前为表定义的触发器列出在数据库中（除非FROM子句被给出的默认数据库）。该语句仅为你拥有TRIGGER [776]权限的数据库或表返回结果。如果有LIKE [1210]子句，则表示与哪个表名相匹配（不是触发器的名称），使得该语句来显示这些表的触发器。如[Section 20.32,“Extensions to SHOW Statements”][20.32.00]所讨论的，WHERE子句可以在使用更多一般的条件下用来选择行。

对于[Section 19.3, “Using Triggers”][19.03.00]中所定义的触发器ins_sum，该语句的输出显示如此：

```sql
mysql> SHOW TRIGGERS LIKE 'acc%'\G
*************************** 1. row ***************************
             Trigger: ins_sum
               Event: INSERT
               Table: account
           Statement: SET @sum = @sum + NEW.amount
              Timing: BEFORE
             Created: NULL
            sql_mode: NO_ENGINE_SUBSTITUTION
             Definer: me@localhost
character_set_client: utf8
collation_connection: utf8_general_ci
  Database Collation: latin1_swedish_ci
```

SHOW TRIGGERS输出包括以下列：

* Trigger：触发器名称。

* Event：使触发器激活的操作类型。值为'INSERT'，'UPDATE'或'DELETE'。

* Table：触发器定义的表。

* Statement：触发器的主体，也就是，当触发器激活时所执行的语句。
* Timing：触发器激活是否在触发事件之前或者之后。值为'BEFORE'或者'AFTER'。

* Created：当前，这一列的值总为NULL。

* sql_mode：当触发器执行时生效的SQL模式。

* Definer：创建触发器的用户的账户，用'user_name'@'host_name'格式。

* character_set_client：当触发器被创建时，character_set_client [483]系统变量的会话值。

* collation_connection：当触发器被创建时，collation_connection [485]系统变量的会话值。

* Database Collation：触发器相关的数据库的排序规则。

你也可以从包含TRIGGERS表的INFORMATION_SCHEMA中获得关于触发器对象的信息。参见[Section 20.27, “The INFORMATION_SCHEMA TRIGGERS Table”][20.27.00]。

#### 13.7.5.40 [SHOW VARIABLES 语法](#13.7.5.40)

```sql
SHOW [GLOBAL | SESSION] VARIABLES
    [LIKE 'pattern' | WHERE expr]
```

SHOW VARIABLES显示MySQL系统变量的值。该信息也可以使用 mysqladmin variables命令得到。如果有LIKE [1210]子句，则表示
与哪个变量名相匹配。如[Section 20.32, “Extensions to SHOW Statements”][20.32.00]中所讨论的，WHERE子句可以在使用更多一般的条件下用来选择行。这个语句不需要任何权限。它仅需要能连接到服务器。

使用GLOBAL修饰符，SHOW VARIABLES显示被用来与MySQL进行新连接的值。在MySQL 5.6中，如果一个变量没有全局值，则没有值被显示出来。使用SESSION，SHOW VARIABLES显示对当前连接生效的值。如果没有修饰符，默认值为SESSION。LOCAL与SESSION为同义词。

SHOW VARIABLES受制于版本依赖显示宽度限制。对于有非常长的值的变量来说，其不能完全被显示出来，使用SELECT作为一个工作区。例如：

```sql
SELECT @@GLOBAL.innodb_data_file_path;
```

如果默认系统变量值不适合，你可以在mysqld启动时使用命令选项来设置它，并且用SET语句大部分都可以在执行期间被改变。请参见[Section 5.1.5, “Using System Variables”][05.01.05]及[Section 13.7.4, “SET Syntax”][13.07.04]。

部分输出显示于此。名称和额值的列表可能与你的服务器不同。请参见[Section 5.1.4, “Server System Variables”][05.01.04]，描述每个变量的意思，并且[Section 8.11.2,“Tuning Server Parameters”][08.11.02]提供了关于调整它们的信息。

```sql
mysql> SHOW VARIABLES;
+-----------------------------------------+---------------------------+
| Variable_name                           | Value                     |
+-----------------------------------------+---------------------------+
| auto_increment_increment                | 1                         |
| auto_increment_offset                   | 1                         |
| autocommit                              | ON                        |
| automatic_sp_privileges                 | ON                        |
| back_log                                | 50                        |
| basedir                                 | /home/jon/bin/mysql-5.5   |
| big_tables                              | OFF                       |
| binlog_cache_size                       | 32768                     |
| binlog_direct_non_transactional_updates | OFF                       |
| binlog_format                           | STATEMENT                 |
| binlog_stmt_cache_size                  | 32768                     |
| bulk_insert_buffer_size                 | 8388608                   |
...
| max_allowed_packet                      | 1048576                   |
| max_binlog_cache_size                   | 18446744073709547520      |
| max_binlog_size                         | 1073741824                |
| max_binlog_stmt_cache_size              | 18446744073709547520      |
| max_connect_errors                      | 10                        |
| max_connections                         | 151                       |
| max_delayed_threads                     | 20                        |
| max_error_count                         | 64                        |
| max_heap_table_size                     | 16777216                  |
| max_insert_delayed_threads              | 20                        |
| max_join_size                           | 18446744073709551615      |
...
| thread_handling                         | one-thread-per-connection |
| thread_stack                            | 262144                    |
| time_format                             | %H:%i:%s                  |
| time_zone                               | SYSTEM                    |
| timed_mutexes                           | OFF                       |
| timestamp                               | 1316689732                |
| tmp_table_size                          | 16777216                  |
| tmpdir                                  | /tmp                      |
| transaction_alloc_block_size            | 8192                      |
| transaction_prealloc_size               | 4096                      |
| tx_isolation                            | REPEATABLE-READ           |
| unique_checks                           | ON                        |
| updatable_views_with_limit              | YES                       |
| version                                 | 5.5.17-log                |
| version_comment                         | Source distribution       |
| version_compile_machine                 | x86_64                    |
| version_compile_os                      | Linux                     |
| wait_timeout                            | 28800                     |
| warning_count                           | 0                         | 
+-----------------------------------------+---------------------------+
```

使用一个LIKE [1210]子句，该语句仅为这些名称与模式相匹配的变量显示行。为了获得某个特定变量的行，使用LIKE [1210]子句显示如下：

```sql
SHOW VARIABLES LIKE 'max_join_size';
SHOW SESSION VARIABLES LIKE 'max_join_size';
```

为了获取其名称与模式相匹配的变量的列表，在LIKE [1210]子句中使用通配符“%”：

```sql
SHOW VARIABLES LIKE '%size%';
SHOW GLOBAL VARIABLES LIKE '%size%';
```

通配符可以用于要匹配的模式之间的任何位置。严格说来，由于“_”是一个匹配任意单字符的通配符，你应该在字面上以“\_”去匹配来避用它。实际上，这不太必要。

#### 13.7.5.41 [SHOW WARNINGS 语法](#13.7.5.41)

```sql
SHOW WARNINGS [LIMIT [offset,] row_count]
SHOW COUNT(*) WARNINGS
```

SHOW WARNINGS显示情况（错误，警告和通知）相关的信息，其源于当前生成消息的会话中的最后一个语句。如果最后一个语句使用表并且没有生成任何消息，则它什么也不显示。（也就是说，使用表但是没有生成任何消息的一个语句会清除消息列表。）没有使用表并且没有生产消息的语句对消息列表不会有任何作用。

警告生成于DML语句，例如INSERT，UPDATE以及LOAD DATA INFILE，同样地，DDL语句例如CREATE TABLE和ALTER TABLE。

SHOW WARNINGS也被用于跟在EXPLAIN EXTENDED后面，当EXTENDED关键字被使用时以此显示通过EXPLAIN生成的额外信息。请参见[Section 8.8.3, “EXPLAIN EXTENDED Output Format”][08.08.03]。

LIMIT子句具有对于SELECT语句来说相同的语法。请参见[Section 13.2.9, “SELECT Syntax”][13.02.09]。

一个相关的语句SHOW ERRORS仅显示错误情况（它排除了警告和通知）。请参见[Section 13.7.5.18, “SHOW ERRORS Syntax”](#### 13.7.5.18)。GET DIAGNOSTICS可以被用来为单独的情况检查信息。请参见[Section 13.6.7.3, “GET DIAGNOSTICS Syntax”](#### 13.6.7.3)。

SHOW COUNT(*) WARNINGS语句显示错误、警告和通知的总数量。你也可以从warning_count [577]系统变量中检索到这个数量：

```sql
SHOW COUNT(*) WARNINGS;
SELECT @@warning_count;
```

这里有一个简单的示例，为CREATE TABLE显示语法警告，为INSERT显示会话警告：

```sql
mysql> CREATE TABLE t1
     >   (a TINYINT NOT NULL, b CHAR(4))
     >   TYPE=MyISAM;
Query OK, 0 rows affected, 1 warning (0.00 sec)
mysql> SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Warning
   Code: 1287
Message: 'TYPE=storage_engine' is deprecated, use
         'ENGINE=storage_engine' instead
1 row in set (0.00 sec)

mysql> INSERT INTO t1 VALUES(10,'mysql'),
    -> (NULL,'test'), (300,'Open Source');
Query OK, 3 rows affected, 4 warnings (0.01 sec)
Records: 3 Duplicates: 0 Warnings: 4

mysql> SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Warning
   Code: 1265
Message: Data truncated for column 'b' at row 1
*************************** 2. row ***************************
  Level: Warning
   Code: 1263
Message: Data truncated, NULL supplied to NOT NULL column 'a' at row 2
*************************** 3. row ***************************
  Level: Warning
   Code: 1264
Message: Data truncated, out of range for column 'a' at row 3
*************************** 4. row ***************************
  Level: Warning
   Code: 1265
Message: Data truncated for column 'b' at row 3
4 rows in set (0.00 sec)
```

max_error_count [519]系统变量控制服务器储存信息为错误、警告和通知消息的最大数量，因此就是SHOW WARNINGS所显示的消息数量。默认情况下，max_error_count [519]为64。为了改变服务器能够储存的消息的数量，改变max_error_count [519]的值。

如果被生成的消息数量超过max_error_count [519]，则warning_count [577]的值并不受限于max_error_count [519]。

在下面这个示例中，ALTER TABLE语句产生三个警告消息（如warning_count [577]的值所显示），但是由于max_error_count [519]已经被设置为1，所以只有一个消息被储存：

```sql
mysql> SHOW VARIABLES LIKE 'max_error_count';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_error_count | 64    |
+-----------------+-------+
1 row in set (0.00 sec)

mysql> SET max_error_count=1;
Query OK, 0 rows affected (0.00 sec)

mysql> ALTER TABLE t1 MODIFY b CHAR;
Query OK, 3 rows affected, 3 warnings (0.00 sec)
Records: 3 Duplicates: 0 Warnings: 3

mysql> SELECT @@warning_count;
+-----------------+
| @@warning_count |
+-----------------+
|               3 |
+-----------------+
1 row in set (0.01 sec)

mysql> SHOW WARNINGS;
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Warning | 1263 | Data truncated for column 'b' at row 1 |
+---------+------+----------------------------------------+
1 row in set (0.00 sec)
```

为了禁用警告，将max_error_count [519]设置为0.在这种情况下，warning_count [577]仍然表示多少个警告已经发生，但是没有一个消息被储存。

下面的DROP TABLE语句导致一个通知：

```sql
mysql> DROP TABLE IF EXISTS test.no_such_table;
Query OK, 0 rows affected, 1 warning (0.01 sec)
mysql> SHOW WARNINGS;
+-------+------+------------------------------------+
| Level | Code | Message                            |
+-------+------+------------------------------------+
| Note  | 1051 | Unknown table 'test.no_such_table' |
+-------+------+------------------------------------+
```

如果sql_notes [560]系统变量被设置为0，通知不会增加warning_count [577]，并且服务器不会记录它们。

MySQL服务器返回一个计数表示源于最后一个语句的错误、警告和通知的总数量。从C应用程序界面，这个值可以通过调用mysql_warning_count()来获得。请参见[Section 22.8.7.73, “mysql_warning_count()”](#### 22.8.7.73)。



//注释：链接


[20.32.00]: ./Chapter_20/20.32.00_Extensions_to_SHOW_Statements.md
[22.00.00]: ./Chapter_22/22.00.00_Connectors_and_APIs.md
[20.00.00]: ./Chapter_20/20.00.00_INFORMATION_SCHEMA_Tables.md
[13.02.09]: ./Chapter_13/13.02.09_SELECT_Syntax.md
[04.06.08]: ./Chapter_04/04.06.08_mysqlbinlog—Utility_for_Processing_Binary_Log_Files.md
[13.08.01]: ./Chapter_13/13.08.01_DESCRIBE_Syntax.md
[13.07.05]: ./Chapter_13/13.07.05_SHOW_Syntax.md
[05.01.04]: ./Chapter_05/05.01.04_Server_System_Variables.md
[20.27.00]: ./Chapter_20/20.27.00_The_INFORMATION_SCHEMA_TRIGGERS_Table.md
[20.29.00]: ./Chapter_20/20.29.00_The_INFORMATION_SCHEMA_VIEWS_Table.md
[17.06.00]: ./Chapter_17/17.06.00_MySQL_Cluster_Replication.md
[05.02.02]: ./Chapter_05/05.02.02_The_Error_Log.md
[13.02.09]: ./Chapter_13/13.02.09_SELECT_Syntax.md
[19.04.04]: ./Chapter_19/19.04.04_Event_Metadata.md
[20.07.00]: ./Chapter_20/20.07.00_The_INFORMATION_SCHEMA_EVENTS_Table.md
[20.15.00]: ./Chapter_20/20.15.00_The_INFORMATION_SCHEMA_PLUGINS_Table.md
[23.02.00]: ./Chapter_23/23.02.00_The_MySQL_Plugin_API.md
[20.19.00]: ./Chapter_20/20.19.00_The_INFORMATION_SCHEMA_ROUTINES_Table.md
[08.12.05]: ./Chapter_08/08.12.05_Examining_Thread_Information.md
[05.01.06]: ./Chapter_05/05.01.06_Server_Status_Variables.md
[21.00.00]: ./Chapter_21/21.00.00_MySQL_Performance_Schema.md
[20.17.00]: ./Chapter_20/20.17.00_The_INFORMATION_SCHEMA_PROFILING_Table.md
[14.00.00]: ./Chapter_14/14.00.00_Storage_Engines.md
[05.01.05]: ./Chapter_05/05.01.05_Using_System_Variables.md
[13.07.04]: ./Chapter_13/13.07.04_SET_Syntax.md
[08.11.02]: ./Chapter_08/08.11.02_Tuning_Server_Parameters.md
[08.08.03]: ./Chapter_08/08.08.03_EXPLAIN_EXTENDED_Output_Format.md 
