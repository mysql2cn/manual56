乔婧 CB_110000 第十一章整章 页码1132-1171 共40页

# 第十一章 列类型

MySQL支持多种列类型：数值类型、日期/时间类型和字符串(字符)类型。本章对这些列类型进行了概述，并且更加详细地描述了各种列的类型，以及列类型存储需求的总结。概述很简单。关于具体列类型的详细信息请查阅本章后面各类型的详细描述，例如，您可以指定值允许的格式。

MySQL支持处理空间数据的扩展名。有关空间类型的信息参见[12.18章节 “空间扩展”](12.18)。

列类型描述使用了下述惯例：

* *M* 
    
    表示整数类型最大显示宽度。

    对于浮点定点类型，表示可以存储的数字（精度）的总位数。

    对于字符串类型，表示最大长度。

    最大允许值取决于列类型。

* *D*

    适用于浮点和定点类型，并表示小数点后面的位数。

    最大可能的值是30，但不应大于 *M* -2。

* *fsp* 【5.6新增】

    适用于TIME，DATETIME和TIMESTAMP，并代表秒的小数部分的精度。
    就是说，秒的小数部分的小数点之后的位数。
    如果赋值的话，取值范围必须为0〜6。值为0表示没有小数部分。省略默认为0。（不同于标准的SQL默认值为6，与以前的MySQL版本兼容性。）

* 方括号(‘[’和‘]’)表示类型定义可选部分。


## 11.1 列类型概述

### 11.1.1 数值类型概述

下面为数值列类型的概述。有关数值类型的属性和存储性能的要求，详细信息参见[11.2节“数值类型”](11.2)，列存储需求参见[11.6节“列类型存储需求”](11.6)。

 *M* 表示最大显示宽度。最大显示宽度为255。显示宽度与存储大小或类型包含的值的范围无关，相关描述参见[11.2节“数值类型”](11.2)。对于浮点和定点类型， *M* 表示可以存储的数字的总位数。

如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性。

数值类型允许UNSIGNED属性和SIGNED.属性。然而，默认为SIGNED.属性，因此SIGNED.属性没有任何影响。

SERIAL是BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE的一个别名。


在整数列定义中，SERIAL DEFAULT VALUE是NOT NULL AUTO_INCREMENT UNIQUE的一个别名。

> **警告**
> 
> 当使用在整数值（其中一个是UNSIGNED类型）之间使用减号时，结果是无符号的，除非NO_UNSIGNED_SUBTRACTION[621]SQL模式被启动。详情参见[12.10章节“Cast函数和操作符”](12.10)。

* BIT[( *M* )]

    位字段类型。M表示每个值的位数，范围为从1到64。如果M被省略， 默认为1。

* TINYINT[( *M* )] [UNSIGNED] [ZEROFILL]

    非常小的整数。带符号的范围是-128到127。无符号的范围是0到255。

* BOOL, BOOLEAN
    这个类型是TINYINT(1)的同义词。zero值视为假，非zero值视为真。

###
    mysql> SELECT IF(0, 'true', 'false');
    +------------------------+
    | IF(0, 'true', 'false') |
    +------------------------+
    | false                  |
    +------------------------+
    mysql> SELECT IF(1, 'true', 'false');
    +------------------------+
    | IF(1, 'true', 'false') |
    +------------------------+
    | true                   |
    +------------------------+
    mysql> SELECT IF(2, 'true', 'false');
    +------------------------+
    | IF(2, 'true', 'false') |
    +------------------------+
    | true                   |
    +------------------------+

然而，TRUE和FALSE分别是1和0的别名，如下所示：
### 
    mysql> SELECT IF(0 = FALSE, 'true', 'false');
    +--------------------------------+
    | IF(0 = FALSE, 'true', 'false') |
    +--------------------------------+
    | true                           |
    +--------------------------------+
    mysql> SELECT IF(1 = TRUE, 'true', 'false');
    +-------------------------------+
    | IF(1 = TRUE, 'true', 'false') |
    +-------------------------------+
    | true                          |
    +-------------------------------+
    mysql> SELECT IF(2 = TRUE, 'true', 'false');
    +-------------------------------+
    | IF(2 = TRUE, 'true', 'false') |
    +-------------------------------+
    | false                         |
    +-------------------------------+
    mysql> SELECT IF(2 = FALSE, 'true', 'false');
    +--------------------------------+
    | IF(2 = FALSE, 'true', 'false') |
    +--------------------------------+
    | false                          |
    +--------------------------------+


最后两段结果表明2既不等于1也不等于0。

* SMALLINT[( *M* )] [UNSIGNED] [ZEROFILL]

    小整数。带符号的范围是-32768到32767。无符号的范围是0到65535。

* MEDIUMINT[( *M* )] [UNSIGNED] [ZEROFILL]

    中等大小的整数。带符号的范围是-8388608到8388607。无符号的范围是0到16777215。

* INT[( *M* )] [UNSIGNED] [ZEROFILL]

    普通大小的整数。带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295。

* INTEGER[( *M* )] [UNSIGNED] [ZEROFILL]

    这是INT的同义词。

* BIGINT[( *M* )] [UNSIGNED] [ZEROFILL]

    大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。

    SERIAL是BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE的一个别名。

    应该清楚BIGINT列的下述内容：

    * 使用带符号的BIGINT或DOUBLE值进行所有算法，因此除了位函数，不应使用大于9223372036854775807(63位)的无符号的大整数! 如果这样做，结果中的最后几位可能出错，这是由于将BIGINT值转换为DOUBLE进行四舍五入时造成的错误。

    MySQL可以在以下情况下处理BIGINT：

    * 当使用整数在BIGINT列存储一个大的无符号值时。

    * 在MIN（ *col_name* ） [1305]或MAX（ *col_name* ）[1305]中，其中col_name表示一个BIGINT列。

    * 当使用运算符（+ [ 1220 ] [ 1220 ]，-，* [ 1220 ]，等等），两个操作数都是整数时。

    * 总是可以使用一个字符串在BIGINT列中保存精确整数值。在这种情况下，MySQL执行字符串-数字转换，其间不存在双精度表示。

    * 当两个操作数均为整数值时，-、+和*操作符使用BIGINT算法。这说明如果乘两个大整数(或来自返回整数的函数)，当结果大于9223372036854775807时，会得到意想不到的结果。

* DECIMAL[( *M* [, *D* ])] [UNSIGNED] [ZEROFILL]

    一个压缩的“精确”定点数。 *M* 是数值总位数（精度）， *D* 是小数点后的位数（刻度）。小数点和(负数)的‘-’符号不包括在 *M* 中。如果 *D* 是0，那么该值没有小数点和小数部分。DECIMAL数值（ *M* ）的最大位数是65，支持的DECIMAL数值（ *D* ）的最大位数是30。如果省略 *D* ，默认值是0。如果省略M，默认值是10。

    如果指定UNSIGNED，不允许负值。

    所有DECIMAL列的基本计算(+，-，*，/)用65位精度完成。

* DEC[( *M* [, *D* ])] [UNSIGNED] [ZEROFILL], NUMERIC[( *M* [, *D* ])] [UNSIGNED] [ZEROFILL], FIXED[( *M* [, *D* ])] [UNSIGNED] [ZEROFILL]

    DECIMAL的同义词。FIXED的同义词可用于与其他数据库系统的兼容性。

* FLOAT[( *M* , *D* )] [UNSIGNED] [ZEROFILL]

    单精度浮点数。允许值范围从-3.402823466E+38到-1.175494351E-38, 0，1.175494351E-38到3.402823466E+38。这些都是基于IEEE标准理论上的限制。根据您的硬件或操作系统，实际的允许值范围会略小。

     *M* 是总位数， *D* 是小数点后数字的位数。如果省略 *M* 和 *D* ，该值存储硬件能够允许的最大限制数。单精度浮点数字精确到大约7位小数。

    如果指定UNSIGNED，不允许负值。

    采用浮动可能会给你一些意想不到的问题，因为在MySQL数据库中所有的计算都是使用双精度的。参见[C.5.5.7,"没有匹配行的解决问题"](C.5.5.7)

* DOUBLE[( *M* , *D* )] [UNSIGNED] [ZEROFILL]

    双精度浮点数。允许值范围从-1.7976931348623157E+308到-2.2250738585072014E-308，2.2250738585072014E-308到1.7976931348623157E+308。这些都是基于IEEE标准理论上的限制。根据您的硬件或操作系统，实际的允许值范围会略小。

     *M* 是总位数， *D* 是小数点后数字的位数。如果省略 *M* 和 *D* ，该值存储硬件能够允许的最大限制数。双精度浮点数字精确到大约15位小数。

    如果指定UNSIGNED，不允许负值。

* DOUBLE PRECISION[( *M* , *D* )] [UNSIGNED] [ZEROFILL], REAL[( *M* , *D* )] [UNSIGNED] [ZEROFILL]

    DOUBLE的同义词。除了：如果的REAL_AS_FLOAT[623]SQL模式被启用，REAL是FLOAT的同义词，而不是DOUBLE的同义词。

* FLOAT( *p* ) [UNSIGNED] [ZEROFILL]

    浮点数。 *p* 表示精度（以位数表示），但MySQL只使用该值来确定结果的列类型是否使用FLOAT或者DOUBLE。如果 *p* 是从0到24，列类型为没有 *M* 或 *D* 值的FLOAT。如果 *p* 是从25到53，列类型为没有 *M* 或 *D* 值的DOUBLE。结果列值的范围与本节前面描述的单精度FLOAT或双精度DOUBLE相同。

    FLOAT( *p* ) 语法与ODBC兼容。
