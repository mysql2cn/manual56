### 11.1.1 数值类型概述

下面为数值列类型的概述。有关数值类型的属性和存储性能的要求，详细信息参见 [Section 1.3.2, “The Main Features of MySQL”] [1.3.2] [11.2节，“数值类型”][11.02.00]，列存储需求参见[11.6节，“列类型存储需求”](./11.6.0_Data_Type_Storage_Requirements.md)。

 *M* 表示最大显示宽度。最大显示宽度为255。显示宽度与存储大小或类型包含的值的范围无关，相关描述参见[11.2节，“数值类型”](./11.2.0_Numeric_Types.md)。对于浮点和定点类型， *M* 表示可以存储的数字的总位数。

如果为一个数值列指定ZEROFILL，MySQL自动为该列添加UNSIGNED属性。

数值类型允许UNSIGNED属性和SIGNED.属性。然而，默认为SIGNED.属性，因此SIGNED.属性没有任何影响。

SERIAL是BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE的一个别名。


在整数列定义中，SERIAL DEFAULT VALUE是NOT NULL AUTO_INCREMENT UNIQUE的一个别名。

> **警告**
> 
> 当使用在整数值（其中一个是UNSIGNED类型）之间使用减号时，结果是无符号的，除非NO_UNSIGNED_SUBTRACTION[621]SQL模式被启动。详情参见[12.10节，“Cast函数和操作符”](../Chapter_12/12.10.0_Cast_Functions_and_Operators.md)。

* BIT[( *M* )]

    位字段类型。M表示每个值的位数，范围为从1到64。如果M被省略， 默认为1。

* TINYINT[( *M* )] [UNSIGNED] [ZEROFILL]

    非常小的整数。带符号的范围是-128到127。无符号的范围是0到255。

* BOOL, BOOLEAN
    这个类型是TINYINT(1)的同义词。zero值视为假，非zero值视为真。

```
mysql> SELECT IF(0, 'true', 'false');
+------------------------+
| IF(0, 'true', 'false') |
+------------------------+
| false                  |
+------------------------+
mysql> SELECT IF(1, 'true', 'false');
+------------------------+
| IF(1, 'true', 'false') |
+------------------------+
| true                   |
+------------------------+
mysql> SELECT IF(2, 'true', 'false');
+------------------------+
| IF(2, 'true', 'false') |
+------------------------+
| true                   |
+------------------------+
```

然而，TRUE和FALSE分别是1和0的别名，如下所示：

``` 
mysql> SELECT IF(0 = FALSE, 'true', 'false');
+--------------------------------+
| IF(0 = FALSE, 'true', 'false') |
+--------------------------------+
| true                           |
+--------------------------------+
mysql> SELECT IF(1 = TRUE, 'true', 'false');
+-------------------------------+
| IF(1 = TRUE, 'true', 'false') |
+-------------------------------+
| true                          |
+-------------------------------+
mysql> SELECT IF(2 = TRUE, 'true', 'false');
+-------------------------------+
| IF(2 = TRUE, 'true', 'false') |
+-------------------------------+
| false                         |
+-------------------------------+
mysql> SELECT IF(2 = FALSE, 'true', 'false');
+--------------------------------+
| IF(2 = FALSE, 'true', 'false') |
+--------------------------------+
| false                          |
+--------------------------------+
```

最后两段结果表明2既不等于1也不等于0。

* SMALLINT[( *M* )] [UNSIGNED] [ZEROFILL]

    小整数。带符号的范围是-32768到32767。无符号的范围是0到65535。

* MEDIUMINT[( *M* )] [UNSIGNED] [ZEROFILL]

    中等大小的整数。带符号的范围是-8388608到8388607。无符号的范围是0到16777215。

* INT[( *M* )] [UNSIGNED] [ZEROFILL]

    普通大小的整数。带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295。

* INTEGER[( *M* )] [UNSIGNED] [ZEROFILL]

    这是INT的同义词。

* BIGINT[( *M* )] [UNSIGNED] [ZEROFILL]

    大整数。带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615。

    SERIAL是BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE的一个别名。

    应该清楚BIGINT列的下述内容：

    * 使用带符号的BIGINT或DOUBLE值进行所有算法，因此除了位函数，不应使用大于9223372036854775807(63位)的无符号的大整数! 如果这样做，结果中的最后几位可能出错，这是由于将BIGINT值转换为DOUBLE进行四舍五入时造成的错误。

    MySQL可以在以下情况下处理BIGINT：

    * 当使用整数在BIGINT列存储一个大的无符号值时。

    * 在MIN（ *col_name* ） [1305]或MAX（ *col_name* ）[1305]中，其中col_name表示一个BIGINT列。

    * 当使用运算符（+ [ 1220 ] [ 1220 ]，-，* [ 1220 ]，等等），两个操作数都是整数时。

    * 总是可以使用一个字符串在BIGINT列中保存精确整数值。在这种情况下，MySQL执行字符串-数字转换，其间不存在双精度表示。

    * 当两个操作数均为整数值时，-、+和*操作符使用BIGINT算法。这说明如果乘两个大整数(或来自返回整数的函数)，当结果大于9223372036854775807时，会得到意想不到的结果。

* DECIMAL[( *M* [, *D* ])] [UNSIGNED] [ZEROFILL]

    一个压缩的“精确”定点数。 *M* 是数值总位数（精度）， *D* 是小数点后的位数（刻度）。小数点和(负数)的‘-’符号不包括在 *M* 中。如果 *D* 是0，那么该值没有小数点和小数部分。DECIMAL数值（ *M* ）的最大位数是65，支持的DECIMAL数值（ *D* ）的最大位数是30。如果省略 *D* ，默认值是0。如果省略M，默认值是10。

    如果指定UNSIGNED，不允许负值。

    所有DECIMAL列的基本计算(+，-，*，/)用65位精度完成。

* DEC[( *M* [, *D* ])] [UNSIGNED] [ZEROFILL], NUMERIC[( *M* [, *D* ])] [UNSIGNED] [ZEROFILL], FIXED[( *M* [, *D* ])] [UNSIGNED] [ZEROFILL]

    DECIMAL的同义词。FIXED的同义词可用于与其他数据库系统的兼容性。

* FLOAT[( *M* , *D* )] [UNSIGNED] [ZEROFILL]

    单精度浮点数。允许值范围从-3.402823466E+38到-1.175494351E-38, 0，1.175494351E-38到3.402823466E+38。这些都是基于IEEE标准理论上的限制。根据您的硬件或操作系统，实际的允许值范围会略小。

     *M* 是总位数， *D* 是小数点后数字的位数。如果省略 *M* 和 *D* ，该值存储硬件能够允许的最大限制数。单精度浮点数字精确到大约7位小数。

    如果指定UNSIGNED，不允许负值。

    采用浮动可能会给你一些意想不到的问题，因为在MySQL数据库中所有的计算都是使用双精度的。参见[C.5.5.7,"没有匹配行的解决问题"](C.5.5.7)。

* DOUBLE[( *M* , *D* )] [UNSIGNED] [ZEROFILL]

    双精度浮点数。允许值范围从-1.7976931348623157E+308到-2.2250738585072014E-308，2.2250738585072014E-308到1.7976931348623157E+308。这些都是基于IEEE标准理论上的限制。根据您的硬件或操作系统，实际的允许值范围会略小。

     *M* 是总位数， *D* 是小数点后数字的位数。如果省略 *M* 和 *D* ，该值存储硬件能够允许的最大限制数。双精度浮点数字精确到大约15位小数。

    如果指定UNSIGNED，不允许负值。

* DOUBLE PRECISION[( *M* , *D* )] [UNSIGNED] [ZEROFILL], REAL[( *M* , *D* )] [UNSIGNED] [ZEROFILL]

    DOUBLE的同义词。除了：如果的REAL_AS_FLOAT[623]SQL模式被启用，REAL是FLOAT的同义词，而不是DOUBLE的同义词。

* FLOAT( *p* ) [UNSIGNED] [ZEROFILL]

    浮点数。 *p* 表示精度（以位数表示），但MySQL只使用该值来确定结果的列类型是否使用FLOAT或者DOUBLE。如果 *p* 是从0到24，列类型为没有 *M* 或 *D* 值的FLOAT。如果 *p* 是从25到53，列类型为没有 *M* 或 *D* 值的DOUBLE。结果列值的范围与本节前面描述的单精度FLOAT或双精度DOUBLE相同。

    FLOAT( *p* ) 语法与ODBC兼容。
