#### YEAR(2)迁移至YEAR(4)

如果你决定将YEAR(2)列转换为YEAR(4)，你随时可以手动操作而不用升级。另外，你可以升级到一个已经减少对YEAR(2)支持的MySQL版本（MySQL5.6.6或更高版本），到时MySQL会自动将YEAR(2)转换为YEAR(4)。对于后者，因为使用导出和重新导入数据会改变值的内容，所以不要使用这种方式升级。此外，如果你使用了复制，有升级的计划，那么必须仔细考虑。

使用ALTER TABLE手动将YEAR(2)列转换为YEAR(4)。假定表t1有这样的定义：

```
CREATE TABLE t1 (ycol YEAR(2) NOT NULL DEFAULT '70');
```

使用ALTER TABLE修改列如下。请记住列所包含的属性，如NOT NULL或DEFAULT：

```
ALTER TABLE t1 MODIFY ycol YEAR(4) NOT NULL DEFAULT '1970';
```

ALTER TABLE语句转换表但不会改变YEAR(2)的值。如果服务器是复制中的主库，ALTER TABLE语句会复制到从库并对每一个变化的表执行相应的操作。

另一种迁移的方法是执行二进制升级：安装MySQL5.6.6或更高版本但不导出和重新导入数据。然后执行mysql\_upgrade，它会使用REPAIR TABLE将YEAR(2)转换为YEAR(4)但不会改变值内容。如果服务器是复制中的主库，REPAIR TABLE语句会复制到从库并对每一个变化的表执行相应的操作，除非在调用mysql\_upgrade时使用--skip-write-binlog[255]选项。

对于复制服务器的升级通常倡导先将从库升级到MySQL新版本，然后升级主库。例如，如果主从同时运行着MySQL5.5，典型的升级顺序是倡导升级从库到5.6，然后升级主库到5.6。关于从MySQL5.6.6开始对YEAR(2)有不同的处理，升级顺序会导致一些问题：
假设从库已经升级而主库还没有升级。然后在主库上创建含有YEAR(2)列的表，而从库上的结果是表字段为YEAR(4)。所以，如果你使用基于语句的复制，那么这些操作在主从库上会有不同的结果：

* 插入数字0。主库上产生的内置值是2000，而从库上是0000。

* 转换YEAR(2)到字符串。主库是YEAR(2)的显示值，而从库是YEAR(4)的显示值。

为了避免这些问题，使用以下策略之一：

* 使用基于行的复制，而不是基于语句的复制。

* 在主库升级之前修改所有的YEAR(2)列为YEAR(4)。（如前所述，使用ALTER TABLE。）然后你可以正常升级（先从库，后主库）而不会发生YEAR(2)到YEAR(4)的差异（在主从之间）。

应当避免的一个迁移方法是：在升级后不要使用mysqldump导出数据，然后将导出文件重新导入。如前所述，这样做很可能会改变YEAR(2)的值。

从YEAR(2)迁移至YEAR(4)还应当检查应用程序代码在变更行为条件下的可能性。如下：

* 一种代码，期望查询一个年份列恰好为两位数。

* 一种代码，没有考虑到插入数字0的不同处理：插入0到YEAR(2)或YEAR(4)，结果内置值分别是2000和0000。
