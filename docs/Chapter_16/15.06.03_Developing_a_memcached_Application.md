# 15.6.3. 开发 memcached 应用程序

### 15.6.3. 开发 memcached 应用程序

许多语言接口可以使应用程序在 **memcached** 服务器存储和读取信息。你可以使用流行语言例如Perl，PHP，Python，Ruby，C和Java来开发 **memcached** 应用程序。




到memcached服务器中存储的数据被称为由一个单一的字符串（键），到高速缓存中的存储和检索从缓存中使用的键作为参考。因此，缓存像一个大的关联数组或哈希表。这是不可能的结构，或以其他方式组织存储在缓存中的信息。为了模拟数据库的概念，如多个表或复合键值，则必须使用到的字符串作为键编码的额外信息。例如，存储或查找的地址对应一个特定的纬度和经度，你可能会打开这两个数值到一个逗号分隔的字符串使用的一个关键。

#### 15.6.3.1 基本`memcached`操作

`memcached`的接口支持如下方法来存储和检索缓存中的信息，这些在所有不同的API上是一致的，尽管语言特定的机制可能不一样：

* `get(key)`：从缓存中获取信息。如果指定的键存在返回与键关联的值。返回`NULL`，`nil`，`undefined`，或者如果指定的键不存在，返回相应语言中最相近的等价值。
* `set(key, , value, [, expiry])`：在缓存中设置条目把键和特定的值关联起来。注意如果键已经存在这会更新已存在的条目，或者如果键不存在则添加一个新的键/值对。如果过期时间被指定，条目在过期时间到的时候会失效(并被删除)。此时间以秒来指定，如果值少于30天(30 * 24 * 60 * 60)会被作为一个相对时间，大于则被作为绝对时间。
* `add(key, , value, [, expiry])`：如果指定的键不存在，将关联的键值加入缓存。
* `replace(key, , value, [, expiry])`：替换与特定的`key`关联的条目,仅当键已存在时。新值通过`value`参数给定。
* `delete(key, [, time])`:删除缓存中的`key`和它相关联的条目。如果你提供了一个`time`，会添加另外一个有指定的`key`的条目阻塞到指定的时期。
* `incr(key, [, value])`:将与`key`关联的条目加1或者用可选的`value`。
* `decr(key, [, value])`:将与`key`关联的条目减1或者用可选的`value`。
* `flush_all`:将缓存中所有的当前条目作废(或使其过期)。技术上他们仍然存在(他们没被删除)，但是它们会在下一次你视图访问它们的时候被安静的销毁。

在所有的实现中，大部分或者全部的函数都和本地语言接口的功能重复。

当实际使用时，使用`memcached`存储完整的条目，而不是在数据库中缓存一个单独列的值。例如，当显示一个关于对象的记录时(发票，用户历史，或者博客发布)，为关联来自数据库的实体加载所有的数据，并把它编译到通常会被应用程序所需要的内部结构中。保存完整的对象在缓存中。

复杂的数据结构不能被直接存储。大部分接口将为你序列化数据，也就是，把它放在一个可以重建原始指针和嵌套的文本形式中。Perl使用`Strorable`,PHP使用`serialize`，Python使用`cPickle`时（或`Pickle`），Java使用`Serializable`接口。在大多数情况下，使用的序列化接口是可定制的。为了在不同语言接口中共享存储在memcached实例中的数据，可以考虑使用一个通用的的序列化解决方案，例如JSON（JavaScript 对象符号）。

####　15.6.3.2　使用`memcached`作为一个MySQL缓存层

当使用`memcached`缓存MySQL数据时，您的应用程序必须从数据库中检索数据并加载适当的键-值对到缓存中。然后，可以直接从缓存中做后续查找。

因为MySQL有其自身的内存内查询数据的缓存机制，如`InnoDB`[缓冲池](#)和MySQL查询缓存，寻找机会超越加载各个列值或行到缓存中。
最好缓存复合值，如那些通过联接查询从多个表检索的
，或从多行集合的结果集。

> **警告**
>
> 将高速缓存中限制为非敏感数据的信息，因为没有保密的需要来访问或更新`memcached`实例中的信息。访问机器的任何人有能力读取，查看并可能更新信息。为了保持数据安全，缓存之前请加密信息。要限制用户连接到服务器，要么禁用网络访问，要么使用ipTables或类似的技术来限制`memcached`的端口被选定的一组主机访问。

----
----

你可以引入`memcached`到现有的应用程序，即使缓存不是原设计的一部分。应用在许多语言和环境中程序将只有短短的几行改变，首次加载数据时试图从缓存中读取，如果信息没有被缓存回到老方法，并一旦数据已被读取更新缓存中的信息。

在任何语言中使用`memcached`作为一个MySQL的缓存解决方案的一般顺序如下：

1. 从缓存请求条目
2. 如果条目存在，使用条目数据
3. 如果该条目不存在，从MySQL加载数据，把值存储到缓存中。这意味着该值在下一个客户端请求时在高速缓存中可用。

对于这个顺序的流程图，请见[Figure 15.8, “Typical `memcached` Application Flowchart”](#)

表 15.8 典型`memcached`应用流程图

[](!)

**`memcached`应用适应数据库的最佳实践**

缓存MySQL数据最直接的方式是使用一个两列的表，第一列是[主键](#)。因为`memcached`键的唯一性需求，要确保数据库架构适当的使用主键和[唯一约束](#)。

如果您将多个列的值组合成单个`memcached`条目值，选择数据类型容易解析值为其组成部分，例如，在数值之间使用分隔符。

最简单的映射到`memcached`查找的查询是单一的`WHERE`子句，使用一个`=`或者`IN`操作符。对于复杂的`WHERE`子句，或使用如`<`，`>`，`BETWEEN`，或`LIKE`这样的操作符，`memcached`不提供一个简单有效的方式来扫描或过滤键或者相关的值，所以通常用SQL查询对底层数据库执行这些操作。

#### 15.6.3.3 使用`libmemcached`与C和C++

`libmemcached`库提供了到`memcached`的C和C++接口，也是
一些不同的额外的API实现，包括Perl，Python和Ruby的​​基础。了解` libmemcached`的核心功能可以帮助使用这些其他的接口。

C库是`memcachedand`最全面的接口库,提供的函数和业务系统并不总是暴露在不以`libmemcached`库为基础的接口中。

不同的函数可以根据其基本操作分开。除了核心API接口的函数之外，大量的实用函数提供了扩展功能，如附加和准备数据。

生成和安装`libmemcached`，下载`libmemcached`的包，运行`configure`，然后生成并安装：

	shell> tar xjf libmemcached-0.21.tar.gz
	shell> cd libmemcached-0.21
	shell> ./configure
	shell> make
	shell> make install

在很多Linux操作系统上，可以通过惯用的`yum`，`apt-get`或者类似的命令安装相应的`libmemcached`包。

要构建一个使用该库的应用程序，首先设置服务器列表。要么在主要的`memcached_st`结构内直接操纵服务器配置，或者分别填入服务器列表，然后添加此列表到`memcached_st`结构。后一种方法在下面的示例中被使用。一旦服务器列表已设置，你可以调用函数来存储或检索数据。此处提供了一个设置预设值到`localhostis`的简单的应用程序：

	#include <stdio.h>
	#include <string.h>
	#include <unistd.h>
	#include <libmemcached/memcached.h>
	int main(int argc, char *argv[])
	{
		memcached_server_st *servers = NULL;
		memcached_st *memc;
		memcached_return rc;
		char *key= "keystring";
		char *value= "keyvalue";
		memcached_server_st *memcached_servers_parse (char *server_strings);
		memc= memcached_create(NULL);
		servers= memcached_server_list_append(servers, "localhost", 11211, &rc);
		rc= memcached_server_push(memc, servers);
		if (rc == MEMCACHED_SUCCESS)
			fprintf(stderr,"Added server successfully\n");
		else
			fprintf(stderr,"Couldn't add server: %s\n",memcached_strerror(memc, rc));
		rc= memcached_set(memc, key, strlen(key), value, strlen(value), (time_t)0, (uint32_t)0);
		if (rc == MEMCACHED_SUCCESS)
			fprintf(stderr,"Key stored successfully\n");
		else
			fprintf(stderr,"Couldn't store key: %s\n",memcached_strerror(memc, rc));
		return 0;
	}

为了检测一个操作的成功，对于一个给定的函数，使用返回值，或填充结果码。如果操作成功，值始终设置为`MEMCACHED_SUCCESS`。在发生故障时，使用`memcached_strerror9()`函数将结果码翻译成可打印的字符串。

要构建应用程序，指定`memcached`库：

	shell> gcc -o memc_basic memc_basic.c -lmemcached

运行上面的示例应用程序，在启动`memcached`服务器后，应该返回一个成功消息：
	
	shell> memc_basic
	Added server successfully
	Key stored successfully

##### 15.6.3.3.1 `libmemcached`基本函数

基本的`libmemcached`函数允许你创建，销毁和复制的用于连接`memcached`服务器的主要`memcached_st`结构。主要的函数定义如下：

	memcached_st *memcached_create (memcached_st *ptr);

创建一个新的`memcached_stlib`结构和其他的`libmemcached`API函数一起使用。你可以提供一个存在的，静态的`memcached_st`结构，或者提供`NULL`来分配新的结构。返回一个指针指向创建的结构，失败则返回`NULL`。

	void memcached_free (memcached_st *ptr);

释放先前创建的`memcached_st`结构的结构和内存分配。

	memcached_st *memcached_clone(memcached_st *clone, memcached_st *source);

从指定的源复制一个现有的`memcached`的结构，复制默认值和
结构中定义的服务器列表。

##### 15.6.3.3.2 `libmemcached`服务器函数

`libmemcached`提供的设置相关的函数和`memcached`协议支持的核心功能提供相同的功能。不同函数的完整定义对于
所有基本功能（`add`,`replace`,`prepend`,`append`）是相同的。例如，`memcached_set()`的函数的定义为：

	memcached_return
		memcached_set (memcached_st *ptr,
					   const char *key,
					   size_t key_length,
					   const char *value,
					   size_t value_length,
					   time_t expiration,
					   uint32_t flags);

`ptr`是`memcached_st`结构。`key`和`key_length`定义了键的名称和长度，`value`和`value_length`对应的值和长度。你还可以设置过期和可选的标志。更多的信息，见[Section 15.6.3.3.5, “Controlling `libmemcached` Behaviors”](#)

此表列出了`libmemcached`的设置相关函数的其余部分和等效的`memcached`协议支持的核心函数。



<style type="text/css">
	table
  	{
  		border-collapse:collapse;
		margin-bottom: 10px;	 
		border-spacing: 0px;
		border-collapse: collapse;
	}
</style>

<table><thead><tr><th scope="col"><code>libmemcached</code>函数</th><th scope="col">等价的核心函数</th></tr></thead><tbody><tr><td scope="row">memcached_set(memc, key, key_length, value, value_length,expiration, flags)</code></td><td>通用的<code>set()</code>操作。</td></tr><tr><td scope="row">memcached_add(memc, key, key_length, value, value_length,expiration, flags)</code></td><td>通用的<code>add()</code>函数。</td></tr><tr><td scope="row">memcached_replace(memc, key, key_length, value, value_length,expiration, flags)</code></td><td>通用的<code>replace()</code>。</td></tr><tr><td scope="row">memcached_prepend(memc, key, key_length, value, value_length,expiration, flags)</code></td><td>准备指定的`value`在当前指定`key`的值之前。</td></tr><tr><td scope="row">memcached_append(memc, key, key_length, value, value_length,expiration, flags)</code></td><td>附加指定的`value`在当前指定`key`的值之后。</td></tr><tr><td scope="row">memcached_cas(memc, key, key_length, value, value_length,expiration, flags, cas)</code></td><td>覆盖给定键的值，只要服务器内对应的`cas`值仍然相同。</td></tr><tr><td scope="row">memcached_set_by_key(memc, master_key, master_key_length, key,key_length, value, value_length, expiration,flags)</code></td><td>和通用的 <code>set()</code>相似, 但是有一个额外的主键可以被用来识别一个单独的服务器。</td></tr><tr><td scope="row">memcached_add_by_key(memc, master_key, master_key_length, key,key_length, value, value_length, expiration,flags)</code></td><td>和通用的 <code>add()</code>相似, 但是有一个额外的主键可以被用来识别一个单独的服务器。</td></tr><tr><td scope="row">memcached_replace_by_key(memc, master_key, master_key_length,key, key_length, value, value_length, expiration,flags)</code></td><td>和通用的 <code>replace()</code>相似, 但是有一个额外的主键可以被用来识别一个单独的服务器。</td></tr><tr><td scope="row">memcached_prepend_by_key(memc, master_key,master_key_length,key, key_length, value, value_length, expiration,flags)</code></td><td>和通用的 <code>memcached_prepend()</code>相似, 但是有一个额外的主键可以被用来识别一个单独的服务器。</td></tr><tr><td scope="row">memcached_append_by_key(memc, master_key, master_key_length,key, key_length, value, value_length, expiration,flags)</code></td><td>和通用的 <code>memcached_append()</code>相似, 但是有一个额外的主键可以被用来识别一个单独的服务器</td></tr><tr><td scope="row">memcached_cas_by_key(memc, master_key, master_key_length, key,key_length, value, value_length, expiration,flags)</code></td><td>和通用的 <code>memcached_cas()</code>相似, 但是有一个额外的主键可以被用来识别一个单独的服务器。</td></tr></tbody></table>

`by_key`方法添加另外两个参数定义主键，使用及应用
在哈希阶段期间来选择服务器。你可以在下面的定义中看到：

	memcached_return
	   memcached_set_by_key(memcached_st *ptr,
							const char *master_key,
							size_t master_key_length,
							const char *key,
							size_t key_length,
							const char *value,
							size_t value_length,
							time_t expiration,
							uint32_t flags);

所有的函数返回一个`memcached_return`类型的值，可以和`MEMCACHED_SUCCESS`常量。

##### 15.6.3.3.4 `libmemcached`获取函数

`libmemcached`函数提供了直接访问单个的条目，和多键的请求机制，在同时获取了大量的键时提供更快的响应。

主要的get风格的函数是`memcached_get()`，相当于通用`get()`的。此函数返回一个字符串指针，指向与指定键相联系的值。

	char *memcached_get (memcached_st *ptr,
						 const char *key, size_t key_length,
						 size_t *value_length,
						 uint32_t *flags,
						 memcached_return *error);

多键的get，`memcached_mget()`，也可用。在一个块中使用多键get操作比单独调用`memcached_get()`检索键值快得多。为启动多键获取，调用`memcached_mget()`:

	memcached_return memcached_mget (memcached_st *ptr,
									 char **keys, size_t *key_length,
									 unsigned int number_of_keys);

返回值是操作成功。`keys`参数应该是一个包含键的字符串数组
，`key_leng`是一个包含每个相应的键的长度的数组。`number_of_keys`是数组内提供键的数量。

为获取单个值，使用`memcached_fetch()`，以获得每个相应的值。

	char *memcached_fetch (memcached_st *ptr,
							const char *key, size_t *key_length,
							size_t *value_length,
							uint32_t *flags,
							memcached_return *error);

该函数返回键值，和用对应的键和长度信息填充的`key`,`key_length`，和`value_length`参数。没有更多的要返回的值时该函数返回`NULL`。这里提供了一个完整的例子，包括填充键数据，返回信息。

```c
#include <stdio.h>
#include <sstring.h>
#include <unistd.h>
#include <libmemcached/memcached.h>

int main(int argc, char *argv[])
{
  memcached_server_st *servers = NULL;
  memcached_st *memc;
  memcached_return rc;
  char *keys[]= {"huey", "dewey", "louie"};
  size_t key_length[3];
  char *values[]= {"red", "blue", "green"};
  size_t value_length[3];
  unsigned int x;
  uint32_t flags;

  char return_key[MEMCACHED_MAX_KEY];
  size_t return_key_length;
  char *return_value;
  size_t return_value_length;

  memc= memcached_create(NULL);

  servers= memcached_server_list_append(servers, "localhost", 11211, &rc);
  rc= memcached_server_push(memc, servers);

  if (rc == MEMCACHED_SUCCESS)
    fprintf(stderr,"Added server successfully\n");
  else
    fprintf(stderr,"Couldn't add server: %s\n",memcached_strerror(memc, rc));

  for(x= 0; x < 3; x++)
    {
      key_length[x] = strlen(keys[x]);
      value_length[x] = strlen(values[x]);

      rc= memcached_set(memc, keys[x], key_length[x], values[x],
                        value_length[x], (time_t)0, (uint32_t)0);
      if (rc == MEMCACHED_SUCCESS)
        fprintf(stderr,"Key %s stored successfully\n",keys[x]);
      else
        fprintf(stderr,"Couldn't store key: %s\n",memcached_strerror(memc, rc));
    }

  rc= memcached_mget(memc, keys, key_length, 3);

  if (rc == MEMCACHED_SUCCESS)
    {
      while ((return_value= memcached_fetch(memc, return_key, &return_key_length,
                                            &return_value_length, &flags, &rc)) != NULL)
        {
          if (rc == MEMCACHED_SUCCESS)
            {
              fprintf(stderr,"Key %s returned %s\n",return_key, return_value);
            }
        }
    }

  return 0;
}
```
运行上面的程序产生如下结果：

```shell
shell> memc_multi_fetch
Added server successfully
Key huey stored successfully
Key dewey stored successfully
Key louie stored successfully
Key huey returned red
Key dewey returned blue
Key louie returned green
```

##### 15.6.3.3.5 控制`libmemcached`行为

通过设置一个或多个行为标志可以修改`libmemcached`的行为。这些可以被全局性设置，或者也可以在调用个别功能函数被应用。一些行为也接受一个额外的设置，如当选择服务器时哈希机制的使用。

为设置全局行为：

```
memcached_return
	memcached_behavior_set (memcached_st *ptr,
							memcached_behavior flag,
							uint64_t data);
```

为获取当前的行为设置：

```
uint64_t
	memcached_behavior_get (memcached_st *ptr,	
							memcached_behavior flag);
```

下表描述了`libmemcached`的行为标志：

<table><thead><tr><th scope="col">行为</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_NO_BLOCK</code></td><td>导致 <code>libmemcached</code> 使用异步I/O。</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_TCP_NODELAY</code></td><td>网络套接字开启无延迟。</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_HASH</code></td><td>如果没有值，设置使用MD5为键的默认哈希算法。
                  其他值包括<code>MEMCACHED_HASH_DEFAULT</code>,<code>MEMCACHED_HASH_MD5</code>,<code>MEMCACHED_HASH_CRC</code>,<code>MEMCACHED_HASH_FNV1_64</code>,<code>MEMCACHED_HASH_FNV1A_64</code>,<code>MEMCACHED_HASH_FNV1_32</code>, 和<code>MEMCACHED_HASH_FNV1A_32</code>。</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_DISTRIBUTION</code></td><td>修改用来选择存储一个给定值服务器的方法。默认的方法是<code>MEMCACHED_DISTRIBUTION_MODULA</code>。你可以通过设置<code>MEMCACHED_DISTRIBUTION_CONSISTENT</code>来启用一致的哈希。<code>MEMCACHED_DISTRIBUTION_CONSISTENT</code>是值的别名<code>MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA</code>。</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_CACHE_LOOKUPS</code></td><td>缓存DNS服务的查找。对于单个主机如果你正在使用主机名而不是IP地址，这可以提高性能。</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_SUPPORT_CAS</code></td><td>支持 CAS 操作。默认情况下，它因为它有性能损失被禁用。</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_KETAMA</code></td><td>设置默认的发行版为<code>MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA</code>哈希算法为<code>MEMCACHED_HASH_MD5</code>.</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_POLL_TIMEOUT</code></td><td>通过<code>poll()</code>修改超时值。为超时值提供<code>signed int</code> 超时指针。</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_BUFFER_REQUESTS</code></td><td>缓冲器IO请求，而不是让它们被发送。Buffers IO requests instead of them being sent. 一个get操作，或关闭连接让数据被刷新。</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_VERIFY_KEY</code></td><td>Forces <code>libmemcached</code> 验证一个指定的key是有效的。</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_SORT_HOSTS</code></td><td>如果设置了，主机被有序的添加到<code>memcached_st</code> 结构的已配置的主机列表中。如果该行为已启用，则打破了一致性哈希。</td></tr><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT</code></td><td>在非阻塞模式，这改变了套接字连接的超时值。</td></tr></tbody></table>

##### 15.6.3.3.6 libmemcached 命令行工具


除了主要的C库接口，`libmemcached`还包括了一些命令行实用程序可以和`memcached`应用程序一起使用并能调试`memcached`。

所有的命令行工具，接受一些参数，其中最关键的是`servers`，指定了当返回信息时要连接的服务器列表。

主要的工具有：

* **memcat**：显示在命令行上给出的每个ID的值：

	```
	shell> memcat --servers=localhost hwkey
	Hello world
	```
* **memcp**：使用文件名作为键，把文件的内容复制到缓存中：

	```
	shell> echo "Hello World" > hwkey
	shell> memcp --servers=localhost hwkey
	shell> memcat --servers=localhost hwkey
	Hello world
	```
* **memslap**:测试一个或多个`memcached`服务器上的负载，模拟get/set和多客户端操作。例如，你可以模拟100个客户端执行get操作的负荷：

	```
	shell> memslap --servers=localhost --concurrency=100 --flush --test=get
	memslap --servers=localhost --concurrency=100 --flush --test=get Threads connecting to servers 100
	Took 13.571 seconds to read data
	```
* **memflush**:刷新（置空）`memcached`缓存的内容。

	```
	shell> memflush --servers=localhost
	```
#### 15.6.3.4 使用MySQL和`memcached`与Perl

`Cache:: Memcached`模给Memcache协议提供了原生的接口，并对`memcached`提供的核心函数支持核心功能的支持。使用你的操作系统的包管理系统来安装模块，或使用`CPAN`：

```
root-shell> perl -MCPAN -e 'install Cache::Memcached'
```

要通过`Cache:: Memcached`模块使用来自`Perl`的`memcached` 中，首先创建定义了用于连接的服务器列表和其它参数的一个新的`Cache:: Memcached`对象。唯一的参数是一个包含用于缓存接口的选项的哈希。例如，要创建一个使用三个`memcached`服务器的新的实例：

```
use Cache::Memcached;

my $cache = new Cache::Memcached {
    'servers' => [
        '192.168.0.100:11211',
        '192.168.0.101:11211',
        '192.168.0.102:11211',
	],
};
```
> **注释**
>
> 当与多台服务器使用`Cache:: Memcached`的接口时，API在群组中所有服务器之间自动执行某些操作。例如，通过`Cache::Memcached`中获取统计信息
返回一个包含以一个主机一个主机为基础的数据的哈希，以及
产生群组中所有的服务器的统计。

你可以在缓存对象实例上设置额外的属性，当它是通过指定选项为哈希选项的一部分创建的。或者，你可以在实例上使用一个对应的方法：

* `servers`或者方法`set_servers()`：指定要使用的服务器列表。服务器列表应该是一个对服务器数组的引用，每个元素是地址和端口号的组合（用冒号分隔）。你也可以通过一个Unix套接字指定一个本地连接（例如 `/tmp/sock/memcached`）。为指定服务器的权重（表示在哈希过程中服务器应该被使用的多频繁），用`memcached`服务器实例和权重数指定的数组引用。越大的数字给予更高的优先权。
* `compress_threshold`或者`set_compress_threshold()`方法：当值被压缩时指定阈值。在存储和检索过程中值超过指定数值会被自动压缩（采用`zlib`）。
* `no_rehash`和方法`set_norehash()`：如果当初选择的是
不可用，禁用寻找新的服务器。
* `readonly`和方法`set_readonly()`:禁用写入`memcached`服务器。

一旦`Cache:: Memcached`实例已配置，你可以使用`set()`和
`get()`方法从`memcached`服务器存储和检索信息。存储在缓存中的对象会被自动序列化，并使用`Storable`模块反序列化。

`Cache:: Memcached`接口支持如下存储/检索数据的方法，并
与表中所示的一般方法相关联。

<table><thead><tr><th scope="col"><code>Cache::Memcached</code> 函数</th><th scope="col">等价一般方法</th></tr></thead><tbody><tr><td scope="row"><code>get()</code></td><td>一般的 <code>get()</code>.</td></tr><tr><td scope="row"><code>get_multi(keys)</code></td><td>使用一个查询获取多个<code>keys</code>。返回一个键/值对的哈希引用。</td></tr><tr><td scope="row"><code>set()</code></td><td>一般的 <code>set()</code>.</td></tr><tr><td scope="row"><code>add()</code></td><td>一般的 <code>add()</code>.</td></tr><tr><td scope="row"><code>replace()</code></td><td>一般的 <code>replace()</code>.</td></tr><tr><td scope="row"><code>delete()</code></td><td>一般的 <code>delete()</code>.</td></tr><tr><td scope="row"><code>incr()</code></td><td>一般的 <code>incr()</code>.</td></tr><tr><td scope="row"><code>decr()</code></td><td>一般的 <code>decr()</code>.</td></tr></tbody></table>

下面是一个与Perl和`Cache::Memcached`模块一起使用`memcached`的完整的例子：

```
#!/usr/bin/perl
use Cache::Memcached;
use DBI;
use Data::Dumper;
# Configure the memcached server
my $cache = new Cache::Memcached {
    'servers' => [
                   'localhost:11211',
                   ],
    };
# Get the film name from the command line
# memcached keys must not contain spaces, so create
# a key name by replacing spaces with underscores
my $filmname = shift or die "Must specify the film name\n";
my $filmkey = $filmname;
$filmkey =~ s/ /_/;
# Load the data from the cache
my $filmdata = $cache->get($filmkey);
# If the data wasn't in the cache, then we load it from the database
if (!defined($filmdata))
{
    $filmdata = load_filmdata($filmname);
    if (defined($filmdata))
    {
# Set the data into the cache, using the key
 if ($cache->set($filmkey,$filmdata))
        {
            print STDERR "Film data loaded from database and cached\n";
        }
        else
        {
            print STDERR "Couldn't store to cache\n";
 }
    }
    else
    {
      die "Couldn't find $filmname\n";
    }
}
else
{
Developing a memcached Application
1903
    print STDERR "Film data loaded from Memcached\n";
}
sub load_filmdata
{
    my ($filmname) = @_;
    my $dsn = "DBI:mysql:database=sakila;host=localhost;port=3306";
    $dbh = DBI->connect($dsn, 'sakila','password');
    my ($filmbase) = $dbh->selectrow_hashref(sprintf('select * from film where title = %s',
                                                     $dbh->quote($filmname)));
    if (!defined($filmname))
    {
      return (undef);
    }
    $filmbase->{stars} =
 $dbh->selectall_arrayref(sprintf('select concat(first_name," ",last_name) ' .
                                         'from film_actor left join (actor) ' .
                                         'on (film_actor.actor_id = actor.actor_id) ' .
                                         ' where film_id=%s',
                                         $dbh->quote($filmbase->{film_id})));
    return($filmbase);
}
```

例子使用了Sakila 数据库，从数据库获取电影数据并写入一个完整的电影和演员记录到`memcached`。当调用它获取一个不存在的电影时，你会得到这样的结果：

```
shell> memcached-sakila.pl "ROCK INSTINCT"
Film data loaded from database and cached
```

当获取一个已经被添加到缓存的电影时：

```
shell> memcached-sakila.pl "ROCK INSTINCT"
Film data loaded from Memcached
```

#### 15.6.3.5 在Python中使用MySQL和`memcached`

Python `memcache`模块是`memcached`服务器的接口，并用纯Python编写(也就是，没有使用C API)。你可以下载安装一个[Python Memcached](#)的拷贝。

为了安装，下载包然后运行Python安装程序：

```
python setup.py install
running install
running bdist_egg
running egg_info
creating python_memcached.egg-info
...
removing 'build/bdist.linux-x86_64/egg' (and everything under it)
Processing python_memcached-1.43-py2.4.egg
creating /usr/lib64/python2.4/site-packages/python_memcached-1.43-py2.4.egg
Extracting python_memcached-1.43-py2.4.egg to /usr/lib64/python2.4/site-packages
Adding python-memcached 1.43 to easy-install.pth file
Installed /usr/lib64/python2.4/site-packages/python_memcached-1.43-py2.4.egg
Processing dependencies for python-memcached==1.43
Finished processing dependencies for python-memcached==1.43
```

一旦安装完成，`memcache`模块为`memcached`服务器提供一个基于类的接口。当你存储Python数据结构作为`memcached`条目时，它们会使用Python`cPickle`或`pickle`模块被自动的序列化(转换成字符串值)。

为创建一个新的`memcache`接口，导入`memcache`模块然后创建一个`memcache.Client`类的新实例。例如，如果`memcached`守护进程在本地主机使用默认端口号运行：

```
import memcache
memc = memcache.Client(['127.0.0.1:11211'])
```

第一个参数是包含了每一个`memcached`实例使用的服务器和端口号的一个字符串数组。为启用调试，设置可选的`debug`参数为1。

默认情况下，用来在多台服务器之间分开条目的哈希机制是`crc32`。为了改变被使用的函数，设置`memcache.serverHashFunction`的值为另外要使用的函数。例如：

```
from zlib import adler32
memcache.serverHashFunction = adler32
```
一旦你在`memcache`实例中已定义了要使用的服务器，核心函数提供了和通用接口说明中相同的功能。下表提供了支持函数的摘要：

<table><thead><tr><th scope="col">Python <code>memcache</code> 函数</th><th scope="col">等价一般函数</th></tr></thead><tbody><tr><td scope="row"><code>get()</code></td><td>一般的 <code>get()</code>.</td></tr><tr><td scope="row"><code>get_multi(keys)</code></td><td>从提供的<code>keys</code>数组中获取多个值。返回一个键/值对的哈希引用。</td></tr><tr><td scope="row"><code>set()</code></td><td>一般的 <code>set()</code>.</td></tr><tr><td scope="row"><code>set_multi(dict [, expiry [, key_prefix]])</code></td><td>根据提供的<code>dict</code>设置多个键/值对。</td></tr><tr><td scope="row"><code>add()</code></td><td>一般的 <code>add()</code>.</td></tr><tr><td scope="row"><code>replace()</code></td><td>一般的 <code>replace()</code>.</td></tr><tr><td scope="row"><code>prepend(key, value [, expiry])</code></td><td>把提供的<code>value</code>加到存在的<code>key</code>值之前。</td></tr><tr><td scope="row"><code>append(key, value [, expiry[)</code></td><td>附加提供的 <code>value</code>到存在的<code>key</code>之后。</td></tr><tr><td scope="row"><code>delete()</code></td><td>一般的 <code>delete()</code>.</td></tr><tr><td scope="row"><code>delete_multi(keys [, expiry [, key_prefix]] )</code></td><td>删除在<code>keys</code>数组中哈希匹配的所有键。</td></tr><tr><td scope="row"><code>incr()</code></td><td>一般的 <code>incr()</code>.</td></tr><tr><td scope="row"><code>decr()</code></td><td>一般的 <code>decr()</code>.</td></tr></tbody></table>

> **注释**
>
> 在Python`memcache`模块中，所有的`*_multi()`函数支持一个可选的`key_prefix`参数。如果被提供，这个字符串被用作所有的键查找的前缀。例如，如果你调用：
```
memc.get_multi(['a','b'], key_prefix='users:')
```
函数从服务器获取`users:a`和`users:b`。

这里是一个展示存储和获取`memcache`实例信息，从MySQL获取原始数据的例子：

```
import sys
import MySQLdb
import memcache
memc = memcache.Client(['127.0.0.1:11211'], debug=1);
try:
    conn = MySQLdb.connect (host = "localhost",
                            user = "sakila",
                            passwd = "password",
                            db = "sakila")
except MySQLdb.Error, e:
     print "Error %d: %s" % (e.args[0], e.args[1])
     sys.exit (1)
popularfilms = memc.get('top5films')
if not popularfilms:
    cursor = conn.cursor()
    cursor.execute('select film_id,title from film order by rental_rate desc limit 5')
    rows = cursor.fetchall()
    memc.set('top5films',rows,60)
    print "Updated memcached with MySQL data"
else:
    print "Loaded data from memcached"
    for row in popularfilms:
        print "%s, %s" % (row[0], row[1])
```

当首次执行时，数据从MySQL数据库被加载并存储到`memcached`服务器中。

```
shell> python memc_python.py
Updated memcached with MySQL data
```

由于数据被自动使用`cPickle`/`pickle`序列化，当你从`memcached`加载回数据时，你可以直接使用对象。在上面的例子中，信息被以行形式从Python DB 游标存储到`memcached`。当获取信息时(在60秒的过期时间内)，数据从`memcached`被加载然后被废弃：

```
shell> python memc_python.py
Loaded data from memcached
2, ACE GOLDFINGER
7, AIRPLANE SIERRA
8, AIRPORT POLLOCK
10, ALADDIN CALENDAR
13, ALI FOREVER
```

序列化和反序列化自动的发生。由于Python反序列化的数据可能和其他的接口和语言不兼容，你可以改变在初始化阶段使用的序列化模块。例如，当用一种语言编写的脚本存储复杂格式的数据结构时你可能会使用JSON格式，并用另外一种语言在脚本中获取它们。

#### 15.6.3.6 在PHP中使用MySQL和`memcached`

PHP通过一个PECL扩展提供Memcache 函数支持。为启用PHP`memcache`扩展支持，使用`--enable-memcache`选项在从源码生成的时候`configure`来生成PHP。

如果你在基于Red Hat的服务器上安装，你可以安装`php-pecl-memcache`RPM：

```
root-shell> yum --install php-pecl-memcache
```

在基于Debian的发行版上，使用`php-memcache`包。

为设置全局运行时配置选项，在`php.ini`文件中指定配置选项值。下表为每个全局运行时配置选项提供了名称，默认值，和描述。

<table><thead><tr><th scope="col">配置选项</th><th scope="col">默认</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code>memcache.allow_failover</code></td><td>1</td><td>指定如果首次选择的服务器失败是否查询列表中的另外一台服务器。
                </td></tr><tr><td scope="row"><code>memcache.max_failover_attempts</code></td><td>20</td><td>指定在错误返回前尝试的服务器数量。</td></tr><tr><td scope="row"><code>memcache.chunk_size</code></td><td>8192</td><td>定义用来和<span class="command"><strong>memcached</strong></span> 服务器交换数据的网络块大小。</td></tr><tr><td scope="row"><code>memcache.default_port</code></td><td>11211</td><td>定义当和Defines the default port to use when communicating with the
                <span class="command"><strong>memcached</strong></span> 服务器通讯时使用的默认端口号.</td></tr><tr><td scope="row"><code>memcache.hash_strategy</code></td><td>standard</td><td>指定使用哪一个哈希策略。Specifies which hash strategy to use. 设置成
                <code>consistent</code> 来让服务器被从连接池中添加和删除而不会导致键被重新分配给其他的服务器。
                当设置成 When set to
                <code>standard</code>时, 会使用更老的(modula)策略使用不同的服务器来存储。</td></tr><tr><td scope="row"><code>memcache.hash_function</code></td><td>crc32</td><td>指定映射键到服务器时使用哪个函数。
                <code>crc32</code> 使用标准的 CRC32 哈希。
                <code>fnv</code> 使用 FNV-1a 哈希算法。</td></tr></tbody></table>

为创建一个到`memcached`服务器的连接，请创建一个新的`Memcache`对象然后指定连接选项，例如：

```
<?php
$cache = new Memcache;
$cache->connect('localhost',11211);
?>
```

它打开一个直接到指定服务器的连接。

为使用多个`memcached`服务器，你需要使用`addServer()`添加服务器到memcache对象：

```
bool Memcache::addServer ( string $host [, int $port [, bool $persistent
                 [, int $weight [, int $timeout [, int $retry_interval
                 [, bool $status [, callback $failure_callback
                 ]]]]]]] )
```

`php-memcache`模块内的服务器管理机制是接口的重要部分，因为它控制到`memcached`实例的主要接口和通过哈希机制不同的实例如何被选择。

为创建到两个`memcached`实例的简单连接：

```
<?php
$cache = new Memcache;
$cache->addServer('192.168.0.100',11211);
$cache->addServer('192.168.0.101',11211);
?>
```

在这种情形下，实例连接没有被显示打开，只有你尝试存储或获取值的时候才会被打开。为启用到`memcached`实例的持久连接，设置`$persistent`参数为true。这是默认设置，并导致连接保持打开状态。

为帮助控制给不同的实例键的分发，请使用全局`memcache.hash_strategy`设置。它设置用来选择的哈希机制。你也可以给每台服务器添加另外的权重，它有效的增加了实例条目出现在实例列表中的次数，因此增加了示例相对于其他实例被选中的可能性。为设置权重，设置`$weight`参数大于1。

设置和获取信息的函数与`memcached`提供的一般的功能性接口相同，如下表所示：

<table><thead><tr><th scope="col">PECL <code>memcache</code> 函数</th><th scope="col">一般函数</th></tr></thead><tbody><tr><td scope="row"><code>get()</code></td><td>一般的 <code>get()</code>.</td></tr><tr><td scope="row"><code>set()</code></td><td>一般的 <code>set()</code>.</td></tr><tr><td scope="row"><code>add()</code></td><td>一般的 <code>add()</code>.</td></tr><tr><td scope="row"><code>replace()</code></td><td>一般的 <code>replace()</code>.</td></tr><tr><td scope="row"><code>delete()</code></td><td>一般的 <code>delete()</code>.</td></tr><tr><td scope="row"><code>increment()</code></td><td>一般的 <code>incr()</code>.</td></tr><tr><td scope="row"><code>decrement()</code></td><td>一般的 <code>decr()</code>.</td></tr></tbody></table>

下面提供了PECL`memcache`接口的完整例子。当用户提供电影名称时，这段代码从Sakila数据库加载电影数据。存储到`memcached`实例的数据被作为`mysqli`结果行记录，API自动的为你序列化信息。

```
<?php
$memc = new Memcache;
$memc->addServer('localhost','11211');
if(empty($_POST['film'])) {
?>
  <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
      <title>Simple Memcache Lookup</title>
    </head>
    <body>
      <form method="post">
        <p><b>Film</b>: <input type="text" size="20" name="film"></p>
        <input type="submit">
      </form>
      <hr/>
<?php
} else {
    
    echo "Loading data...\n";
    
    $film   = htmlspecialchars($_POST['film'], ENT_QUOTES, 'UTF-8');
    $mfilms = $memc->get($film);
    if ($mfilms) {
        printf("<p>Film data for %s loaded from memcache</p>", $mfilms['title']);
        foreach (array_keys($mfilms) as $key) {
            printf("<p><b>%s</b>: %s</p>", $key, $mfilms[$key]);
        }
    } else {
        $mysqli = mysqli('localhost','sakila','password','sakila');
    
        if (mysqli_connect_error()) {
            sprintf("Database error: (%d) %s", mysqli_connect_errno(), mysqli_connect_error());
            exit;
        }
    
        $sql = sprintf('SELECT * FROM film WHERE title="%s"', $mysqli->real_escape_string($film));
        $result = $mysqli->query($sql);
        if (!$result) {
            sprintf("Database error: (%d) %s", $mysqli->errno, $mysqli->error);
            exit;
        }
        $row = $result->fetch_assoc();
        $memc->set($row['title'], $row);
        printf("<p>Loaded (%s) from MySQL</p>", htmlspecialchars($row['title'], ENT_QUOTES, 'UTF-8');
    }
}
?>
  </body>
</html>
```
在PHP中，到`memcached`实例的连接随PHP和相关联的Apache实例运行而保持打开状态。当在运行实例的列表中添加或者移除服务器时(例如，当启动另外的涉及到额外服务器的脚本时)，连接是共享的，但是脚本只选择在被显示配置在脚本中的实例。

为了确保脚本中服务器列表的改变不会引发问题，一定要使用一致的哈希机制。

#### 15.6.3.7 在Ruby中使用MySQL和`memcached`

在Ruby中有若干不同的模块接入`memcached`。`Ruby-MemCache`客户端库为不需要外部库的`memcached`提供了本地接口，如`libmemcached`。你可以从[http://www.deveiate.org/
projects/RMemCache](http://www.deveiate.org/projects/RMemCache)获取安装程序包。

为了安装，解压包然后运行`install.rb`：

```
shell> install.rb
```

如果你有RubyGems，你可以安装`Ruby-MemCache` gem:

```
shell> gem install Ruby-MemCache
Bulk updating Gem source index for: http://gems.rubyforge.org
Install required dependency io-reactor? [Yn]  y
Successfully installed Ruby-MemCache-0.0.1
Successfully installed io-reactor-0.05
Installing ri documentation for io-reactor-0.05...
Installing RDoc documentation for io-reactor-0.05...
```
要在Ruby中使用`memcached`实例，创建一个`MemCache`对象的新实例。

```
require 'memcache'
memc = MemCache::new '192.168.0.100:11211'
```

你可以通过附加权重计数在主机名/端口号字符串之后来给每台服务器添加一个权重以增加服务器在哈希过程中被选中的可能性：

```
require 'memcache'
memc = MemCache::new '192.168.0.100:11211:3'
```

为添加服务器到存在的列表中，你可以直接把它们附加到`MemCache`对象后：

```
memc += ["192.168.0.101:11211"]
```
为设置数据到缓存中，你可以在新的缓存对象中给键分配一个值，它像一个标准的Ruby哈希对象一样起作用。

```
memc["key"] = "value"
```

或者为了获取该值：

```
print memc["key"]
```
为了更明确的行动，你可以使用方法接口，它们模仿了主要的`memcached`API函数，像下表中概括的一样：

<table><thead><tr><th scope="col">Ruby <code>MemCache</code> 方法</th><th scope="col">等价的 <span><strong>memcached</strong></span> API 函数</th> </tr></thead>
<tbody><tr><td scope="row"><code>get()</code></td><td>一般的 <code>get()</code>。</td></tr><tr><td scope="row"><code>get_hash(keys)</code></td><td>获取多个<code>keys</code>的值, 返回信息作为键和它们的值的哈希</td></tr><tr><td scope="row"><code>set()</code></td><td>一般的 <code>set()</code>。</td></tr><tr><td scope="row"><code>set_many(pairs)</code></td><td>设置键的值和哈希<code>pairs</code>的值。</td></tr><tr><td scope="row"><code>add()</code></td><td>一般的 <code>add()</code>。</td></tr><tr> <td scope="row"><code>replace()</code></td><td>一般的 <code>replace()</code>。</td></tr><tr><td scope="row"><code>delete()</code></td><td>一般的 <code>delete()</code>。</td></tr><tr><td scope="row"><code>incr()</code></td><td>一般的 <code>incr()</code>。</td></tr><tr> <td scope="row"><code>decr()</code></td><td>一般的 <code>decr()</code>。</td></tr></tbody></table>

#### 15.6.3.8 在Java中使用MySQL和`memcached`

Java中的`com.danga.MemCached`类向`memcached`实例提供了本地接口。你可以从[https://github.com/gwhalin/Memcached-Java-Client/downloads](https://github.com/gwhalin/Memcached-Java-Client/downloads)获取客户端。Java 类使用和`libmemcached`兼容的哈希，因此你可以混合和匹配Java和`libmemcached`应用来获取相同的`memcached`实例。Java和其他接口不兼容。如果这是一个问题，使用JSON或类似的非二进制序列化格式。

在大多数的系统上，你可以下载包并直接使用`jar`。

为使用`com.danga.MemCached`接口，创建一个`MemCachedClient`实例并通过配置`SockIOPool`来配置服务器列表。通过连接池说明设置服务器列表，权重，和优化客户端和你配置的`memcached`实例连接的连接参数。

通常，你可以在单个类中配置`memcached`接口一次，然后在应用程序的余下部分使用该接口。

例如，为创建基本接口，首先配置`MemCachedClient`和基本的`SockIOPool`设置：

```
public class MyClass {
    protected static MemCachedClient mcc = new MemCachedClient();
    static {
 
        String[] servers =
            {
                "localhost:11211",
            };
 
        Integer[] weights = { 1 };
 
        SockIOPool pool = SockIOPool.getInstance();
 
        pool.setServers( servers );
        pool.setWeights( weights );
```

在上面的例子中，服务器列表通过创建使用一个`memcached`实例数组来配置。你可以接着为每台服务器配置单独的权重。

连接的余下参数是可选的，但是你可以通过设置连接池参数来设置连接号(初始连接，最小连接，最大连接，和空闲超时)：

```
pool.setInitConn( 5 );
pool.setMinConn( 5 );
pool.setMaxConn( 250 );
pool.setMaxIdle( 1000 * 60 * 60 * 6 
```

一旦参数已经被配置了，初始化连接池：

```
pool.initialize();
```

连接池，和到`memcached`实例的连接现在已经准备好使用了。

为了设置用来选择存储给定键的服务器的哈希算法，使用`pool.setHashingAlg()`：

```
pool.setHashingAlg( SockIOPool.NEW_COMPAT_HASH );
```

有效值是`NEW_COMPAT_HASH`，`OLD_COMPAT_HASH`和`NATIVE_HASH`是基本的modula 哈希算法。为使用一致的哈希算法，使用`CONSISTENT_HASH`。这些常量和`libmemcached`中相应的哈希设置是等价的。

下表列出了Java`com.danga.MemCached`方法和`memcached`接口说明中的等价一般方法。

<table>
      <thead><tr><th scope="col">Java <code>com.danga.MemCached</code> 方法</th><th scope="col">等价一般方法</th></tr></thead><tbody><tr><td scope="row"><code>get()</code></td><td>一般的 <code>get()</code>.</td></tr><tr><td scope="row"><code>getMulti(keys)</code></td><td>获取多个<code>keys</code>的值,用Hash map返回信息，
                <code>java.lang.String</code>为键
                <code>java.lang.Object</code>为对应的值</td></tr><tr><td scope="row"><code>set()</code></td><td>一般的 <code>set()</code>.</td></tr><tr><td scope="row"><code>add()</code></td><td>一般的 <code>add()</code>.</td></tr><tr><td scope="row"><code>replace()</code></td><td>一般的 <code>replace()</code>.</td></tr><tr><td scope="row"><code>delete()</code></td><td>一般的 <code>delete()</code>.</td></tr><tr><td scope="row"><code>incr()</code></td><td>一般的 <code>incr()</code>.</td></tr><tr><td scope="row"><code>decr()</code></td><td>一般的 <code>decr()</code>.</td></tr></tbody></table>

#### 15.6.3.9 使用`memcached` TCP 文本协议

和`memcached`服务器通讯可以通过TCP或者UDP协议实现。当使用TCP协议时，你可以使用一个简单的基于文本的接口来交换信息。

当与`memcached`通讯时，你可以使用为服务器配置的端口来连接到服务器。你可以打开一个和服务器的连接而无需认证或登录。一旦你已经连接，可以开始发送命令给服务器。当完成后，你可以终止连接无需发送任何明确的断开命令。客户端被鼓励保持连接以减少延迟和提高性能。

数据被以两种形式发送给`memcached`服务器。

* 文本行，被用来发送命令给服务器，从服务器接收响应。
* 非结构化数据，被用来接收或者发送给定键的值信息。数据被以提供的确切形式返回给客户端。

文本行(命令和响应)和非结构化的数据都总是以`\r\n`字符串结尾。因为被存储的数据可能包含此序列，数据长度(在非结构化数据被发送前返回给客户端)应该被用来确定数据的结束。

服务器的命令根据它们的操作被构造。

* 存储命令：`set`, `add`, `replace`, `append`, `prepend`, `cas`
	服务器的存储命令采用此形式：
	```
command key [flags] [exptime] length [noreply]
	```
	或者当使用比较和交换时(cas)：
	```
cas key [flags] [exptime] length [casunique] [noreply]
	```
	其中：

	* `command`:命令名
		* `set`:存储键值
		* `add`:如果键不存在存储键值
		* `replace`:如果键存在存储键值
		* `append`:附加提供的值到指定键的尾部。`flags`和`exptime`参数不应该被使用。
		* `prepend`:附加缓存中的当前值到到指定键提供的值的尾部。`flags`和`exptime`参数不应该被使用、
		* `cas`:仅当提供的`casunique`匹配时，设置指定键为提供的值。如果从上次获取后没有人更新过它，这实际上等价于改变信息。
	* `key`:键。所有的的数据都用一个指定的键存储。键不能包含控制符或空白符，最多包含250个字符。
	* `flags`:操作标志(作为整形数)。`memcached`中的标志是透明的。`memcached`服务器忽略标志的内容。它们可以被客户端用来确定信息类型。在`memcached`1.2.0或者更低版本此值是一个16位整型数。在`memcached`1.2.1或者更高版本此值是一个32位整型数。
	* `exptime`:过期时间，0为没有过期时间。
	* `length`:提供的字节块值的长度，不包含`\r\n`结束字符。
	* `casunique`:存在条目的64位唯一值。它被用来和存在值进行比较。当发出`cas`更新时用此值通过`gets`命令返回。
	* `noreply`：告知服务器不要回复命令。

例如，为把`abcdef`值存储到键`xyzkey`，你将会使用：

```
set xyzkey 0 0 6\r\nabcdef\r\n
```

从服务器的返回值是一行，指定状态或者错误信息。更多的信息，见[Table 15.3, “`memcached` Protocol Responses”](#)。

* 获取命令：`get`,`gets`

获取命令采用此形式：

```
get key1 [key2 .... keyn]
gets key1 [key2 ... keyn]
```

你可以提供给命令提供多个键，每个被请求的键用空格符隔开。服务器用这种信息行响应：

```
VALUE key flags bytes [casunique]
```

其中：

* `key`：键名。
* `flags`：当值被存储时提供给`memcached`服务器的标志整型值。
* `bytes`：存储值的大小(不包含结束的`\r\n`字符序列)。
* `casunique`：确定条目的64位整型。

信息行后紧跟数据值块。例如：

```
get xyzkey\r\n
VALUE xyzkey 0 6\r\n
abcdef\r\n
```

如果你请求了多个键，一个信息行和每个找到的键的数据块被返回。如果请求键在缓存中不存在，不返回信息。

* 删除命令：`delete`

删除命令采用此形式：

```
delete key [time] [noreply]
```

其中：

* `key`：键名。
* `time`：以秒为单位的时间，用来表示客户端希望服务器拒绝此键上的`add`或`replace`的时间。所有的`add`，`replace`，`get`，和`gets`命令在此期间失败。`set`操作成功。在这段时间后，该键被永远删除所有的命令被接受。

	如果没有被提供，值被假定为0(立即删除)。
* `noreply`：告知服务器不要回复命令。

* 增加/减少：`incr`，`decr`

增加减少命令改变服务器内的键的值而无需执行一个分别的get/set序列。此操作假定当前存储值是64整型。如果存储值不是64位整型，在增加和减少操作被应用前此值被假定为0。

增加或减少命令采用此形式：

```
incr key value [noreply]
decr key value [noreply]
```

其中：

* `key`:键名
* `value`:一个被用来作为增加减少值的整型数。
* `noreply`:告知服务器不要回复命令。
* `NOT_FOUND`:指定键没有找到。
* `value`:指定键相关联的新值。

值被假定为未分配。对于`decr`操作，值永远不会减少到0以下。对于`incr`操作，值被限制在64位整数最大值下。

* 统计命令：`stats`

`stat`命令提供了关于当前`memcached`实例状态和存储数据的详细统计信息。

统计命令采用此形式：

```
STAT [name] [value]
```

其中：

* `name`：统计要返回的可选名称。如果没有被指定，返回一般的统计。
* `value`：当 指定特定的统计操作时使用的指定值。

返回值是一个统计数据列表，格式如下：

```
STAT name value
```

统计以一个单行，`END`结束。

更多的信息，见[Section 15.6.4, “Getting `memcached` Statistics”.](#)

为了参照，下面提供了不同的命令支持及其格式的列表。

表 15.2 `memcached`命令参照

<table><thead><tr><th scope="col">命令</th><th scope="col">命令格式</th></tr></thead><tbody><tr><td scope="row"><code>set</code></td><td><code>set key flags exptime length</code>, <code>set key flags
                exptime length noreply</code></td></tr><tr><td scope="row"><code>add</code></td><td><code>add key flags exptime length</code>, <code>add key flags
                exptime length noreply</code></td></tr><tr><td scope="row"><code>replace</code></td><td><code>replace key flags exptime length</code>, <code>replace
                key flags exptime length noreply</code></td></tr><tr><td scope="row"><code>append</code></td><td><code>append key length</code>, <code>append key length
                noreply</code></td></tr><tr><td scope="row"><code>prepend</code></td><td><code>prepend key length</code>, <code>prepend key length
                noreply</code></td></tr><tr><td scope="row"><code>cas</code></td><td><code>cas key flags exptime length casunique</code>, <code>cas
                key flags exptime length casunique noreply</code></td></tr><tr><td scope="row"><code>get</code></td><td><code>get key1 [key2 ... keyn]</code></td></tr><tr><td scope="row"><code>gets</code></td><td><code></code></td></tr><tr><td scope="row"><code>delete</code></td><td><code>delete key</code>, <code>delete key noreply</code>,
                <code>delete key expiry</code>, <code>delete
                key expiry noreply</code></td></tr><tr><td scope="row"><code>incr</code></td><td><code>incr key</code>, <code>incr key noreply</code>,
                <code>incr key value</code>, <code>incr key
                value noreply</code></td></tr><tr><td scope="row"><code>decr</code></td><td><code>decr key</code>, <code>decr key noreply</code>,
                <code>decr key value</code>, <code>decr key
                value noreply</code></td></tr><tr><td scope="row"><code>stat</code></td><td><code>stat</code>, <code>stat name</code>, <code>stat
name value</code></td></tr></tbody></table>

当给服务器发送一个命令时，从服务器的响应是下表中的设置之一。所有的来自服务器的响应值都通过`\r\n`结束：

表 15.3 `memcached` 协议响应

<table><thead><tr><th scope="col">字符串</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">STORED</code></td><td>值被成功存储</td></tr><tr><td scope="row"><code class="literal">NOT_STORED</code></td><td>值没有被存储，但不是因为错误。用于添加或者更新一个值的命令，如果值存在(如<code class="literal">和</code> and
                <code class="literal">replace</code>)，或者已经被设置成删除的条目。</td></tr><tr><td scope="row"><code class="literal">EXISTS</code></td><td>当使用<code class="literal">cas</code> 命令，你尝试存储的条目已经存在并在最后一次检查之后被修改过。</td></tr><tr><td scope="row"><code class="literal">NOT_FOUND</code></td><td>你尝试存储，更新或者删除的条目不存在或者已经被删除。</td></tr><tr><td scope="row"><code class="literal">ERROR</code></td><td>你提交了一个不存在的命令名。</td></tr><tr><td scope="row"><code class="literal">CLIENT_ERROR errorstring</code></td><td>输入行存在错误，细节包含在
                <code class="literal">errorstring</code>中。</td></tr><tr><td scope="row"><code class="literal">SERVER_ERROR errorstring</code></td><td>服务器中存在错误阻止它返回信息。在极端情况下，服务器可能在错误发生后断开与客户端的连接。</td></tr><tr><td scope="row"><code class="literal">VALUE keys flags length</code></td><td>请求的键已经被找到，存储的<code class="literal">key</code>，
                <code class="literal">flags</code> 和数据块被返回，有指定的长度<code class="literal">length</code>.</td></tr><tr><td scope="row"><code class="literal">DELETED</code></td><td>请求的键被从服务器删除</td></tr><tr><td scope="row"><code class="literal">STAT name value</code></td><td>一行统计数据。</td></tr><tr><td scope="row"><code class="literal">END</code></td><td>统计数据的末尾。</td></tr></tbody></table>

