#  8.9.1. The InnoDB Buffer Pool

### 8.9.1. The InnoDB Buffer Pool
InnoDB维护一个称为[buffer pool](#)的存储区域，将数据和索引缓存在内存中。了解InnoDB的[buffer pool](#)工作原理，并且利用它保持频繁的访问内存中的数据，是优化MYSQL的一个重要的方面。

**Guidelines**

理论上，你将buffer pool的值设置为实际允许的最大值，为服务器上其他进程的运行留下足够的内存避免过度的换页。buffer pool值越大，InnoDB越类似内存数据库。从磁盘上一次读取数据，接下来的读操作中，从内存访问数据。buffer pool甚至缓存插入和更新操作修改的数据，因此磁盘写可以分组以获得更好性能。

依赖于你系统上特有的负载，你可以调整buffer pool中个部分的比例。你可以优化buffer pool一旦它填满选择哪些块缓存的方式，来保持频繁在内存访问数据（尽管会突然出现峰值比如恢复或者报告操作）。

在具有大内存的64位系统上，你可以将buffer pool分裂为多个部分，在并发操作中最小化争夺内存结构。更多细节，[Section 14.2.4.2.27, "Improvements to Performance from Multiple Buffer Pools"][14.02.04.02.27]

[14.02.04.02.27]: ./docs/Chapter_14/14.02.02_Improvements_to_Performance_from_Multiple_Buffer_Pools.md#14.02.04.02.27

**Internal Details**

InnoDB将缓冲池最为列表来管理，使用最少最近访问（LRU）算法的变体。当需要空间增加一个新的块到缓冲池时，InnoDB收回最近最少使用的块，将新块增加到列表中间。这种“中点插入策略”将列表看成两个子列：

- 头，“新”的子列块是最近访问的。
- 尾，“老”的子列块是最早访问的。

这种算法保持查询经常访问的块在新子列表中。老的子列包含较少使用的块；这些块最为回收的候选者。

LRU算法缺省按如下的方式操作：

- 3/8的缓冲池用于老子列表。
- 列表的“中点”是是新子列表的尾部和老子列表的头部的边界线。
- 当InnoDB将一个块读到buffer pool，它最初被插入“中点”（老子列表的头）。一个块能被读入是因为用户指定的操作（例如SQL查询）需要，或者是作为预读操作的部分由InnoDB自动完成。
- 访问老子列表中的块是该块“年轻”，将它移到缓冲池的头（新子列表的头）。如果块是因为需要而被读入，第一次访问立即发生，并且块变得“年轻”。如果块是因为预读而被读入，第一次访问并不立即发生（也可能在块被回收之前根本不发生）。
- 作为数据库操作，缓冲池中的没有被访问的块通过移动到链表的尾部变老。在新和老子列表中的块都会随着其他块变新而变老。老子列表上的块同样随着新块被插入“中点”而变老。最终，一个块长期不适用会到达老子列表的尾部，然后被收回。

缺省，查询读的块会立即移动到新子列表中，意味着它们将相当长的时间在buffer pool中。一个表扫描（例如完成mysqldump操作，或者一个不包含where条件的查询操作）能将大量的块引入到缓冲池中和回收大量的老块，即使新数据从不被使用。同样，块通过预读后台线程载入且仅被访问一次，将被移动到新列表头部。这种情况将频繁访问的块推到老子列表，它们将被回收。

**Configuration Options**
多个InnoDB系统变量控制缓冲池大小和让你优化LRU算法：

- innodb_buffer_pool_size [1745]

指定缓冲池大小。如果你的缓冲池设置小，并且有足够的内存，将缓冲池设置大能改善性能，这是通过减少磁盘IO实现当查询需要访问InnoDB表。

- innodb_buffer_pool_instances [1743]

将缓冲池分隔为用户指定数目的独立区域，每个区域有自己的LRU链表和相关的数据结构，以减少在内存并发读和写时的竞争。这个选项仅在innodb_buffer _ pool _size变量设置为1G或更大时生效。你指定的总大小分配到所有的缓冲池中。为获得更好性能，将innodb _ buffer _ poo l _size [1745]和innodb _ buffer _ pool _ instances [1743]联合使用，因此每个缓冲池实例至少有1GB。

- innodb _old _blocks _pct [1773]

说明缓冲池中InnoDB老子列表大概比例。值的范围是5到95。缺省值是37（那就是说，缓冲池的3/8）。

- innodb _ old _ blocks _time [1774]

说明在老子列表中的块在第一次被访问之后，移动到新列表之前，在老列表放置多少微秒（ms）。缺省值为0：插入在老子列表中的块移动到新子列表当InnoDB从缓冲池中回收1/4插入块页面，不管插入后多久发生访问。如果这个值大于0，块仍然在老子列表上直到新访问发生至少那么多ms（在第一次访问后）。例如，1000使块在老子列表上保留1s（第一次访问后），在它被移动到新子列表之前。

设置innodb _ old _ blocks_time [1774]大于0阻止用于仅一次表访问的块冲击新子列表。扫描读取的块中的记录被快速连续访问多次，之后不再使用这个块。如果innodb _ old _ blocks_time [1774]这个值设置为大于处理块的时间，这块仍然在老子列表中，并且会老化移动的列表的尾部从而被换出。这种方式，仅用于一次扫描的块不会损坏新子列表中频繁访问的块。

innodb _ old _ blocks_time [1774]能在运行时设置，因此你能临时设置这个值当表扫描或者dump操作：

    SET GLOBAL innodb_old_blocks_time = 1000;... perform queries that scan tables ... 
    SET GLOBAL innodb_old_blocks_time = 0; 
这种策略在你的目的是预热（适用表的内容填充缓冲池）并不适用。例如，基准测试通常完成表或索引扫面在系统启动时，因为数据在一段正常适用后会在缓冲池中。在这种情况下，innodb _ old _ blocks_time [1774]设置为0，至少到预热阶段完成。

**Monitoring The Buffer Pool** 

InnoDB标准监控输出包含缓冲池和内存中多个域，这些域和缓冲池LRU算法操作相关：

- Old database pages:缓冲池中老子列表上的页数。
- Pages made young, not young:老的页移动到缓冲池的头（新子列表头）的数目，以及仍然在老子列表上的没有变新的页数。
- youngs/s non-youngs/s:访问老页导致变新或者没有的数目。这个标准和前面的项在下面两种方式不同。首先，它仅和老页相关。其次，它基于被访问的页数而不是总的页数（给定的表可能会多次访问，每次都会计数）。
- young-making rate:使块移动到缓冲池头的访问。
- not:块没有移动到缓冲池头的访问（由于延迟没有满足）。

young-making rate和not通常并不能达到缓冲池全局的访问率。访问老子列表上的块使它们移动到新子列表上，但是访问新子列表上的数据使它们移动到新的子列表上当且仅当离头有一定距离。

前面从监控器获得的信息可以帮助做LRU优化的决定：

- 如果你看到很低youngs/s值当你并没有大的扫描进行，那暗示你要么减少延迟时间，或者增加缓冲池中老子列表的比例。增加比例老子列表增大，因此子列表上的块花更多时间移动到列尾和回收。这增加了它们重新被访问和变年轻的可能性。
- 如果你没有看到很多non-youngs/s当你做大表扫描（和大量的youngs/s），增大你的延迟值。

> **注意**
> 
> 由InnoDB监控器提供每秒平均值基于当前时间和InnoDB打印输出的最后时间的消耗时间。

获取关于InnoDB监控的更多信息，查看[Section 14.02.04.04, "SHOW ENGINE INNODB STATUS and the InnoDB Monitors"][14.02.04.04]

[14.02.04.04]: ./docs/Chapter_14/14.03.02_SHOW_ENGINE_INNODB_STATUS_and_the_InnoDB_Monitors".md#14.02.04.04