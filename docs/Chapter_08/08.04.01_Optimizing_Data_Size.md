#  8.4.1.优化数据所占空间

### 8.4.1.优化数据所占空间

良好的设计可以使你的表尽可能在磁盘占用更小的空间，这对于磁盘的读写操作来说，可能能节省很大的性能开销。并且，在执行查询中时，小表会占用更小的内存。同样表所占的空间越小，索引处理的速度也就越快。

MySQL支持许多不同的存储引擎(表类型)和行格式。对于每个表，可以确定使用哪个存储引擎和索引方法。为应用程序选择合适的表格式可以大大提高性能。参见[Chapter 14, The InnoDB Storage Engine](TODO)，以及[Chapter 15, Alternative Storage Engines](TODO)。

可以使用下面的技术可以使表的性能更好并且使存储空间最小：

#### 表列

* 尽可能地使用最具性价比(最小)的数据类型。MySQL有很多节省磁盘空间和内存的专业化类型。例如，尽可能使用较小的整数类型使表更小。**MEDIUMINT**经常比**INT**好一些，因为**MEDIUMINT**列使用的空间要少25%。 

* 在允许的情况下， 尽量将列声明为非空的。这样做可以更有效的利用索引，并且避免了对每个值测试是否为空的额外开销。同时每列还能节省1bit的空间。如果在应用程序中确实需要NULL，应该毫无疑问使用它，只是避免默认地在所有列为**NULL**。

#### 行格式

* 在 MySQL5.6当中，InnoDB表默认使用的是**COMPACT**格式来储存数据**(ROW_FORMAT=COMPACT)**。这种compact类型的行格式包括**COMPACT**, **DYNAMIC**,以及**COMPRESSED**。他们都是通过一定的CPU开销来压缩数据存储所占的空间。如果你的应用压力主要是在缓存命中，或者磁盘读写速率上，这种格式可能对你有所帮助。如果更多的情况下你的应用受限于CPU的速率，这几种格式可能会使你的速度更慢了。

	在使用诸如**utf8mb3**或者**utf8mb4**这种可变长的字符集的时候，[CHAR](TODO)类型的字段在使用compact类型的格式时，通常能节省一定的空间。比如**ROW_FORMAT=REDUNDANT**的情况下，[CHAR(N)](TODO)最多占用**N***x*的空间来存储。许多语言一般指使用单字节长度的**utf-8**就能够表示了，所以使用定长的数据格式，通常会造成浪费。如果使用**compact**格式的情况下，InnoDB会将所存储的数据去掉空格之后再存储，通常会占用**N**到**N***x*的长度。典型的情况下，会占用**N**字节的长度。更多信息参考[Section 14.8.3, “Physical Row Structure of InnoDB Tables”](TODO)。

* 如果想要通过使用压缩格式来减少所占用的空间，可以在创建**InnoDB**表时指定**ROW_FOTMAT=COMPRESSED**，或者在一个存在的**MyISAM**表运行[myisampack](TODO)命令来减少空间。（**InnoDB**压缩表是可读和可写的，而**MyISAM**压缩表是只读。）

* 对于MyISAM表，如果没有任何变长列(**VARCHAR**、**TEXT**或**BLOB**列)，使用固定尺寸的记录格式。这比较快但是可能会浪费一些空间。参见[Section 15.2.3, “MyISAM Table Storage Formats””](TODO)。你可以通过指定**CREATE**操作中**VARCHAR**列的**ROW_FORMAT=fixed**的方式，来显示的声明你想使用定长列。

#### 索引

* 每张表的主索引应该尽可能短，这样方便对每行进行区分。对于**InnoDB**表，主键列在第二索引条目重复，所以如果你有很多第二索引，一个短的主键能节省相当大的空间。

* 只创建你确实需要提高查询性能的索引。索引对检索有好处，但是会使插入和更新操作变慢。如果主要通过搜索列的组合来存取一个表，将他们组合为一个复合索引而不是单独为每个列索引。索引的第一个部分应该是最常用的列。如果从表中选择时总是使用许多列，索引的第一列应当是重复最多的一列，这样可以更好地压缩索引空间。

* 如果一个长字符串列开头有唯一的前缀，更好地做法是仅对该前缀创建索引。MySQL支持对一个字符列的最左边部分创建一个索引(参见[Section 13.1.13, “CREATE INDEX Syntax”](TODO))。更短的索引会更快，不仅因为它们占较少的磁盘空间，更重要的是，他们在cache中的命中率会提高，并且会减少磁盘的访问次数。参见[Section 5.1.1, “Configuring the Server”](5.1.1ß)。 

#### 连接

*  在一些情形下，将一个经常被扫描的表分割为2个表是有益的。特别是该表会持续增长的情况下，将其中常被访问的列拆分出来，会有很大的帮助。

* 在不同表中具有相同信息的列应该被声明为相同的数据类型，这样可以在连接时，提高列的比较速度。

* 保持列名简单，这样你可以使用相同名字横跨不同的表，并简化连接查询。例如，在customer表中使用name而不是customer_name。为了使名字能移植到其它数据库，应该使名字短于18个字符。 

#### 范式

* 在一般情况下，尝试以非冗余方式(查看数据库理论中的第三范式)保存数据。对于很长的且冗余的字段，给他们定义唯一的ID，而不是在表中对他们进行重复存储。通过引用这些ID来在多个小表中记录这些信息，并在连接语句中使用ID进行关联。

* 如果速度比磁盘空间和维护数据多份复制的开支重要，例如在一个你需要从大表分析所有数据的商业智能场景，你可以放松标准化规则，通过记录冗余信息或者summary表的方式，来优化查询。 