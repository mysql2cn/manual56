#  8.2.1.优化 SELECT 语句

### 8.2.1.优化 SELECT 语句

[SELECT](TODO)形式的语句完成了数据库中的全部查询操作。不管目的是将web页面的响应优化到秒级一下，或者是为长时间运行的大型报告减少数小时的时间，对这些语句的优化，都应该放在首要位置。

除了这些SELECT语句之外，对查询的针对性调优还会影响到像[CREATE TABLE...AS SELECT](TODO)，[INSERT INTO...SELECT](TODO)，以及在[DELETE](TODO)的[WHERE](TODO)子句中的查询。因为上面的语句还涉及到了写操作，所以他们比只读的查询语句需要考虑的性能优化因素更多。

MySQL Cluster supports a join pushdown optimization whereby a qualifying join is sent in its entirety to MySQL Cluster data nodes, where it can be distributed among them and executed in parallel. For more information about this optimization, see [Conditions for NDB pushdown joins](TODO),

优化查询主要考虑如下这几点：

- 要想一个慢速**SELECT ... WHERE**查询更快，第一件事是检查你能不能添加一个[索引][index]。在字段建立索引并在**WHERE**子句使用，来提高预估、过滤和最后结果检索的速度。尽可能的使用最少的索引来覆盖你的应用中常用的查询，这样可以减少你的磁盘占用。

    对于跨表查询，特别是使用了像[joins](TODO)或者[foreign keys](TODO)这样的语句，索引是特别重要的。可以通过使用[EXPLAIN](TODO)语句来查看当前[SELECT](TODO)所使用的具体索引。参考[Section 8.3.1, “How MySQL Uses Indexes”](8.3.1)以及[ Section 8.8.1, “Optimizing Queries with EXPLAIN”](8.8.1)。

- 需要独立的调试查询的每一部分，比如一个比较费时的函数调用。一个函数在查询中的调用次数，取决于查询是如何被构建的。可能是结果集中每一行都被调用了，也可能是在一张表上只被调用了一次。前者会极大的放大一个低效函数带来的影响。

- 在你的查询中，特别是在大表的查询中，尽可能的减少[full table scans](TODO)的次数。

- 定期使用[ANALYZE TABLE](TODO)来更新表的静态数据，来保证优化器创建的执行计划是有效的。

- 学习针对每张表存储引擎的调优技巧，索引技巧和配置参数。**InnoDB**和**MyISAM**两个存储引擎都有很多能使查询成为和维持高性能的指导方针。更详细的信息[Section 8.5.6, “Optimizing InnoDB Queries”](8.5.6)以及[Section 8.6.1, “Optimizing MyISAM Queries”](8.6.1)。

- 特别地，在MySQL5.6.4和更高的版本，你可以使用[Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”](8.5.3)的技巧为**InnoDB**表优化单一查询的事务。

- 不要牺牲SQL的可读性来做一些改变，特别是当优化器也会这样做的时候。

- 如果一个性能问题不容易被基本的指导方针解决，可以通过查看[EXPLAIN](EXPLAIN)计划和调整你的索引、WHERE子句、join子句等等。（当你获得了一定的专业知识后，查看EXPLAIN计划可能是你优化每一次查询的第一步）

- 调整MySQL用来做缓存的内存区域的大小和属性。随着InnoDB[buffer pool](TODO)、MyISAM[key cache](TODO)和MySQL查询缓存的有效使用，重复的查询会变得更快，因为第二次，以及后续的查询可以在内存中获取。

- 即使对于一个使用了内存区域而运行得很快的查询，你还是需要优化得更好，以便它们需要更少的缓存，使你的应用程序更容易扩展。可扩展性意味着你的应用程序能处理更多的用户同时访问、更大的请求等类似的情况，并且性能不会出现一个很大的下降。

- 当你的查询速度会被其他同时操作同一张表的Session影响时，就要处理Locking相关的问题。

#### 8.2.1.1 WHERE Clause Optimization

这个章节将会讨论能用于处理**WHERE**子句的优化。例子中用到的是[SELECT](TODO)语句，但是对应的优化同样适用使用了[WHERE](TODO)子句的[DELETE](TODO)和[UPDATE](TODO)语句。 

> Note
> 
> 因为MySQL优化器相关研发是在持续进行中，所以不是所有的优化策略都在本文档中提及。

你可能会被劝说，需要重写你的查询令到它们执行更快，但是需要牺牲可读性。因为MySQL会自动地做相同的优化的缘故，其实你可以经常避免这种工作，同时还能让查询保持更容易理解和可持续的形式。下面列举了一些Mysql常见的自动优化的点：

- 去掉不需要的括号：

```sql

	   ((a AND b) AND c OR (((a AND b ) AND (c AND d))))
    -> (a AND b AND c ) OR (a AND b AND c AND d)

```

- 常量合并

```sql

	   (a<b AND b=c) AND a=5
    -> b>5 AND b=c AND a=5
 
```

- 移除常量条件（必须的，因为常量可以合并）

```sql

	   (B>=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
	-> B=5 OR B=6

```

- 被索引使用的常量表达式只被计算一次。

- 在一张表进行[COUNT(*)](TODO)操作而没有使用 **WHERE** 时对于 **MyISAM** 和 **MEMORY** 表是可以直接从表信息取到的.对于在一张表使用任何的 **NOT NULL** 语句也是一样的。

- 非法常量表达式的早期检测。MySQL会快速检测一些无作用的[SELECT](SELECT)语句并且返回一个空结果集。

- HAVING is merged with WHERE if you do not use GROUP BY or aggregate functions (COUNT(), MIN(), and so on)。

- 对于join子句中的每一个表，一个更简单的 **WHERE**子句被构造，替换了原来的WHERE子句，用来获得一个更快的 **WHERE** 估算而且会尽可能地跳过无关的行。

- 在查询中所有的静态表会比其他任何表先读取。符合以下任何一种情况都可认为是一张静态表：

	- 一张空表或者只有一行的表。
	
	- 指定表的**WHERE**子句使用了该表的 **PRIMARY KEY**或者**UNIQUE**索引，并且这些索引的每个字段都是一个常量表达式，且不允许为空。

	所有如下的表都被视为静态表：

	```sql

	SELECT * FROM t WHERE primary_key=1;
	SELECT * FROM t1,t2
		WHERE t1.primary_key=1 AND t2.primary_key=t1.id;

	```

- 对于表的连接的最好连接组合是通过尝试所有的可能性来发现的。如果在ORDER BY和GROUP BY子句的所有列都来自同一张表，那么该表在连接的时候将会是优先的。

- 如果在一个连接队列里面有一个ORDER BY子句和一个不同的GROUP BY子句，或者如果ORDER BY或GROUP BY包含的列来自不属于join子句中的第一张表，就会创建一张临时表。

- 如果你使用了 **SQL_SMALL_RESULT** 选项，MySQL会使用一张存在于内存的临时表。

- 每张表的所以都会被查询，而且最好的索引会被使用，除非优化器相信进行全表扫描更有效。同时，全表扫描是否会进行取决于最好的索引是否跨越了表的30%的范围，但是一个固定的比例不再决定选择使用索引还是全表扫描。现在的优化器变得更复杂，同时基于很多其他因素(例如表的大小、行数和I/O块的大小)的衡量。

- 在一些情况下，MySQL能从索引读取行而不需要查询数据文件。如果索引所使用的列都是数值，那么只要使用索引树就可以解决查询了。

- 在每一行输出之前，那些没有匹配HAVING子句的行将会被忽略。

一些查询的例子是非常快的：

```sql

SELECT COUNT(*) FROM tb1_name;

SELECT MIN(key_part1),MAX(key_part1) FROM tb1_name;

SELECT MAX(key_part2) FROM tb1_name
  WHERE key_part1=constant;

SELECT ... FROM tb1_name
  ORDER BY key_part1,key_part2,... LIMIT 10;

SELECT ... FROM tb1_name
  ORDER BY key_part1 DESC, key_part2 DESC,... LIMIT10;

```

下列查询MySQL仅使用索引树就可以解决(假设索引包含的列为数值型)：

```sql

SELECT key_part1, key_part2 FROM tb1_name WHERE key_part1=val;

SELECT COUNT(*) FROM tb1_name
  WHERE key_part1=val1 AND key_part2=val2;

SELECT key_part2 FROM tb1_name GROUP BY key_part1;

```

下列查询使用索引按排序顺序检索行，without a separate sorting pass:

```sql

SELECT ... FROM tb1_name
  ORDER BY key_part1, key_part2,... ;

SELECT ... FROM tb1_name
  ORDER BY key_part1 DESC, key_part2 DESC, ...;

```

#### 8.2.1.2 Range Optimization

[range](TODO) access方法在查询一个表的子集的时候，一次使用一个索引的几个索引值intervals来进行查询。这个方法可以作用于single-part索引和multi-part索引。在接下来的章节中，会详细说明该方法是如何从**WHERE**子句中来找出对应的intervals的。

##### 8.2.1.2.1.针对single-part索引的range access方法

对于single-part索引，索引值intervals恰好等价于**WHERE**子句中的条件，称之为范围条件更恰当一些。

single-part索引范围条件的定义如下：

For both BTREE and HASH indexes, comparison of a key part with a constant value is a range condition when using the =, <=>, IN(), IS NULL, or IS NOT NULL operators.

Additionally, for BTREE indexes, comparison of a key part with a constant value is a range condition when using the >, <, >=, <=, BETWEEN, !=, or <> operators, or LIKE comparisons if the argument to LIKE is a constant string that does not start with a wildcard character.

For all index types, multiple range conditions combined with OR or AND form a range condition.

啦啦啦啦中间缺一段

#### 8.2.1.3 索引合并优化

索引合并，其实就是将多个range scan所获取的列，合并在一起的过程。合并的过程所采用的算法，可能是unions, intersections, 或者 unions-of-intersections。access method将来自同一张表的索引扫描进行合并；而对于分属不同表的索引扫描，access method并不处理。

在[EXPLAIN](TODO)的输出结果中，如果存在索引合并优化，在其`type`列中，显示的值是`index_merge`。此时，`key`这一列中显示的就是所用到的所以的列表，`key_len`这一列则包含了这些索引中，最长的key parts。

举个例子：

```sql
SELECT * FROM tbl_name WHERE key1 = 10 OR key2 = 20;

SELECT * FROM tbl_name
  WHERE (key1 = 10 OR key2 = 20) AND non_key=30;

SELECT * FROM t1, t2
  WHERE (t1.key1 IN (1,2) OR t1.key2 LIKE 'value%')
  AND t2.key1=t1.some_col;

SELECT * FROM t1, t2
  WHERE t1.key1=1
  AND (t2.key1=t1.some_col OR t2.key2=t1.some_col2);

```

索引合并方法有几种access算法 (参见[EXPLAIN](TODO)的`extra`字段的值)：

* Using intersect(...)

* Using union(...)

* Using union(...)

后面几节更加详细地描述了这些方法。

> Note
> 
> 索引合并优化算法具有以下几个已知缺陷
> 
> - 如果你的查询语句中，有一个复杂的`WHERE`语句，并且包含了深度嵌套的AND/OR条件，从而导致MySQL没有选择最佳的方案，可以尝试遵循以下原则，来进行优化：
> 
> ```
> (x AND y) OR z = (x OR z) AND (y OR z)
> (x OR y) AND z = (x AND z) OR (y AND z)
> ```
> 
> - 索引合并不适用于全文索引。我们计划在将来的MySQL发行版中，解决这个问题。
> - 在MySQL 5.6.6这个版本之前，如果存在可用的range scan，则优化器会选择该方案，并且不会考虑索引合并Union Access算法，或者索引合并Sort-Union Access算法。举个例子，参考如下的查询：
> 
> ```
> SELECT * FROM t1 WHERE (goodkey1 < 10 OR goodkey2 < 20) AND badkey < 30;
> ```
> 
> 对于该查询，可以有两个方案：
> 
> - 使用(goodkey1 < 10 OR goodkey2 < 20)条件进行索引合并扫描。
> - 使用badkey < 30条件进行范围扫描。
> 
> 然而，优化器只考虑第2个方案。

在索引合并的不同算法的选择之间，其评估的原则是：不同选择的开销的预估。

##### 8.2.1.3.1. 索引合并Intersection Access算法

该访问算法可以用于当**WHERE**子句结合[AND][AND]被转换为不同的关键字的几个范围条件，每个条件为下面之一：

* 以这种形式，即索引有确切的**N**部分(即包括了所有索引部分)：
```sql
key_part1=const1 AND key_part2=const2 ... AND key_partN=constN
```
* 任何**InnoDB**表的主键的范围条件。

下面是一些例子：
```sql
SELECT * FROM innodb_table WHERE primary_key < 10 AND key_col1=20;

SELECT * FROM tbl_name
  WHERE (key1_part1=1 AND key1_part2=2) AND key2=2;
```
索引合并交集算法同时对所有使用的索引进行扫描，并产生从合并的索引扫描接收的行序列的交集。

如果使用的索引包括查询中使用的所有列，所有表记录均不搜索，并且在这种情况下[EXPLAIN][EXPLAIN]的输出包含**Extra**字段中的**Using index**。下面是一个此类查询的例子：
```sql
SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1;
```
如果使用的索引未包括查询中使用的所有列，只有满足所有使用的关键字的范围条件才搜索所有记录。

如果某个合并条件是InnoDB或BDB表的主键的一个条件，不用于记录查询，但用于过滤使用其它条件搜索的记录。

##### 8.2.1.4.2.索引合并并集访问算法
该算法的适用标准类似于索引合并方法交集算法的标准。算法可以用于当**WHERE**子句结合[OR][OR]被转换为不同的关键字的几个范围条件的时候，每个条件为下面之一：

* 以这种形式，即索引有确切的N部分(即包括了所有索引部分)：
```sql
key_part1=const1 AND key_part2=const2 ... AND key_partN=constN
```
* 任何InnoDB或BDB表的主键的范围条件。

* 索引合并方法交集算法适用的一个条件。

下面是一些例子：
```sql
SELECT * FROM t1 WHERE key1=1 OR key2=2 OR key3=3;
 
SELECT * FROM innodb_table WHERE (key1=1 AND key2=2) OR
  (key3='foo' AND key4='bar') AND key5=5;
```
##### 8.2.1.4.3.索引合并排序并集访问算法
该访问算法可以用于当**WHERE**子句结合[OR][OR]被转换为不同的关键字的几个范围条件，但索引合并方法联合算法并不适用的时候。

下面是一些例子：
```sql
SELECT * FROM tbl_name WHERE key_col1 < 10 OR key_col2 < 20;

SELECT * FROM tbl_name

  WHERE (key_col1 > 10 OR key_col2 = 20) AND nonkey_col=30;
```
排序联合算法和联合算法的区别是排序联合算法必须先索取所有记录的行ID，然后在返回记录前对它们进行排序。

#### 8.2.1.5.引擎条件叠加优化(#08.02.01.05)

这种优化提高了一个索引列和一个常量直接比较的效率。在这种情况下，条件对于存储引擎的评估是“叠加”的。这种优化仅仅能被用于[NDB][NDB]存储引擎。

对于MySQL集群，这种优化能消除通过网络传输不匹配行的花费和MySQL服务器发布的查询，而且能加快那些在多种情况被一个因子使用了5到10次的查询，而这个因子是可以条件叠加，但实际没有。

假设一张MySQL集群定义如下：

```sql    

CREATE TABLE t1 (  
      a INT,  
	  b INT,  
	  KEY(a)  
)ENGINE=NDB;  
```  

条件叠加能与下面的一条查询使用，这条查询包括了一个非索引列和常量的比较：

```sql
SELECT * FROM t1 WHERE b = 10;
```
条件叠加的使用情况可以通过EXPLAIN输出来查看：
```sql
mysql>EXPLAIN SELECT a,b FROM t1 WHERE b = 10\G
*******************1.row**************************
           id: 1
    select_type: SIMPLE
        table: t1
         type: ALL
    possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 10
        Extra: Using where with pushed condition
```
但是，条件叠加不能用在下面两种情况：
```sql
SELECT a,b FROM t1 WHERE a = 10;
SELECT a,b FROM t1 WHERE b + 1 = 10;
```
条件叠加不可应用于第一种查询是因为已经有一个索引在字段**a**了。（一个索引的访问方法可能更有效，所以比条件叠加会被优先选择。）条件叠加不能应用于第二种查询是因为比较间接地涉及到了非索引列**b**。（但是，如果你在**where**子句分解 **b + 1 = 10** 成为**b = 9**条件，条件叠加是可以应用的。）

当用一个**>**或者**<**进行索引列与常量的比较时，条件叠加也许能被应用：

```sql
	mysql> **EXPLAIN SELECT a,b FROM t1 WHERE a<2\G** 
	*************************** 1. row ***************************  
	
	           id: 1  
	
	  select_type: SIMPLE  
	
	        table: t1
	
	         type: range 
 
	possible_keys: a
	
	          key: a
	
	      key_len: 5
	
	          ref: NULL
	
	         rows: 2
	
	        Extra: Using where with pushed condition

```

其他条件叠加支持的比较包括下面这些：

* **column [NOT] LIKE pattern**

  **pattern**必须是一个包括的模式能被匹配的字符串；对于语法，查看章节[12.5.1 字符比较函数][12.5.1]  
   
* **column IS [NOT] NULL**

* **column IN (value_list)**

  每一个**value_list**里面的条目必须是一个常量字面值。

* **column BETWEEN constant1 AND constant2**

  **constant1** 和 **constant2** 每个都必须是一个常量字面值

在前面列表的所有情况里，条件是可能被转换成一个列和一个常量之间的一种或多种直接比较的形式。

引擎条件叠加默认是可行的。要让它失效，在服务器启动的时候设置系统变量**optimizer_switch**。例如在一个**my.cnf**文件，使用下面这些行：

```sql

	[mysqld]  
	optimizer_switch=engine_condition_pushdown=off

```
在运行时让条件叠加失效：
```sql

	SET optimizer_switch='engine_condition_pushdown=off';

```

**局限性**。 引擎条件叠加受下面这些限制的约束：

* 条件叠加只能有[NDB][NDB]存储引擎支持。

* 列或者只会和常量比较；但是这包括了那些评估为常量值的表达式。

* 在表达式里使用的列不能是[BLOB][11.4.3]或者[TEXT][11.4.3]类型。

* 一个字符串值要和一个列比较必须要和这个列是用一种校对。   

* 不直接支持链接；涉及多表的条件在合适的地方是被单独叠加的。使用**EXPLAIN EXTENDED**来决定哪个条件是实际上叠加的。

#### 8.2.1.6.索引条件叠加优化(#08.02.01.06)

索引条件叠加（ICP）是一种MySQL使用索引从一个表检索数据的情况的优化。没有ICP，存储引擎来回移动索引来定位基本表的位置和返回它们到为行评估**WHERE**条件的MySQL服务器。随着ICP的可用，如果**WHERE**条件的部分能通过仅仅使用索引的字段被评估，MySQL服务器会把这部分的**WHERE**条件叠加到存储引擎。存储引擎然后通过使用索引条目评估索引条件叠加，而且只有这样才满足记录是从表读取。ICP能降低存储引擎必须访问基本表的次数和MySQL服务器必须访问存储引擎的次数。

当有需要访问表的所有行时，索引条件叠加优化将被用于**range**,**ref**,**eq_ref**和**ref_or_null**访问方法。这个策略使用于**InnoDB**和**MyISAM**表。但是，对于**InnoDB**表ICP只能用于第二索引。ICP的目标是降低全记录读取从而降低IO操作。对于**InnoDB**簇索引，完整的记录已经被读进**InnoDB**缓存。在这种情况下使用ICP不会减低IO。

要了解这种优化的原理，首先要思考当索引条件叠加不能用时一个索引扫描时怎样进行的：

1.获得下一行，首先通过读取索引元组，然后通过索引元组定位和读取全表行。

2.检验应用于这个表的**WHERE**条件的一部分。接受或者拒绝行取决于检验结果。

当索引条件叠加被使用，扫描反而像这样进行：

1.获取下一行的索引元组（不是全表行）。

2.检验应用于这个表的**WHERE**条件的一部分，并且能被检查仅仅使用索引列。如果条件不满足，进入索引元组的下一行。

3.如果条件满足，使用索引元组来定位和读取全表行。

4.检验应用于这个表的**WHERE**条件的剩下部分，接受或者拒绝行取决于检验结果。

当索引条件叠加被使用，**EXPLAIN**输出的**Extra**列显示了**Using index condition**。它不会显示**Index only**,因为当全表的行被读取时不会被应用。

假如有一个关于人们和他们的地址信息的表和表有一个被定义为**INDEX（zipcode,listname,firstname）**的索引。如果我们知道一个人的**zipcode**值，但不确定lastname,我们可以像这样搜索：

```sql
	SELECT * FROM people
	  WHERE zipcode='95054'
	  AND lastname LIKE '%ertunia%'
	  AND address LIKE '%Main Street%';
```

MySQL能通过**zipcode=‘95054’**使用索引来扫描人们的信息。第二部分（**lastname LIKE '%ertunia'）不能被用于限制必须被扫描的行的数目。所以没有索引条件叠加，这个查询必须为那些**zipcode='95054'**的人们检索全表的行。

因为索引条件叠加，MySQL在读取全表的行之前会检查**lastname LIKE '%etrunia%'**部分。这样就避免了读取全部行相当于所有没有匹配**lastname**条件的索引元组。


索引条件叠加默认是可用的；它也能被**optimizer_switch**系统变量控制通过设置**index_condition_pushdown**标志。查看[章节8.8.5.2,控制可转换的优化][8.8.5.2]

#### 8.2.1.7.索引扩展的使用(#08.02.01.07)

[InnoDB][InnoDB]通过附加主键到第二索引自动地扩展每一个第二索引。考虑如下定义：

```sql

    CREATE TABLE t1 (

    i1 INT NOT NULL DEFAULT 0,

    i2 INT NOT NULL DEFAULT 0,

    d DATE DEFAULT NULL,

    PRIMARY KEY (i1, i2),

    INDEX k_d (d)

    ) ENGINE = InnoDB;

```

这张表在列**（i1,i2）**定义了主键。它也在列**（d）**定义了一个第二索引，但是在内部InnoDB扩展了这个列并且把它作为了列**（d,i1,i2)**。

在MySQL5.6.9之前，优化器当决定怎样或者是否使用一个索引时没有将扩展的第二索引的主键列考虑在内。从MySQL5.6.9起，将主键列考虑在内，这样能带来更高效的查询执行计划和更好地性能。

优化器能为如下几种情况使用扩展的第二索引：**ref**,**range**和**index_merge**索引访问、松散的索引扫描、连接和排序优化、**MIN（）**/**MAX()**优化。

下面的例子展示了优化器是否使用扩展的第二索引是怎样影响执行计划的。假设**t1**是由这些行填充的：

```sql

    INSERT INTO t1 VALUES

    (1, 1, '1998-01-01'), (1, 2, '1999-01-01'),

    (1, 3, '2000-01-01'), (1, 4, '2001-01-01'),

    (1, 5, '2002-01-01'), (2, 1, '1998-01-01'),

    (2, 2, '1999-01-01'), (2, 3, '2000-01-01'),

    (2, 4, '2001-01-01'), (2, 5, '2002-01-01'),

    (3, 1, '1998-01-01'), (3, 2, '1999-01-01'),

    (3, 3, '2000-01-01'), (3, 4, '2001-01-01'),

    (3, 5, '2002-01-01'), (4, 1, '1998-01-01'),

    (4, 2, '1999-01-01'), (4, 3, '2000-01-01'),

    (4, 4, '2001-01-01'), (4, 5, '2002-01-01'),

    (5, 1, '1998-01-01'), (5, 2, '1999-01-01'),

    (5, 3, '2000-01-01'), (5, 4, '2001-01-01'),

    (5, 5, '2002-01-01');

```

现在考虑这个查询：

```sql

    EXPALIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'

```

优化器在这种情况不能使用主键，因为主键包含了列**（i1,i2）**而这个查询没有引用到**i2**。相反，优化器能在**d**使用第二索引**k_d**,执行计划取决于扩展索引是否被使用。

如果优化器不考虑索引扩展，它只会将索引**k_d**看成**（d）**。查询的**EXPLAIN**结果如下：

```sql

	mysql> EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G

    *************************** 1. row ***************************

    id: 1

    select_type: SIMPLE

    table: t1

    type: ref

    possible_keys: PRIMARY,k_d

    key: k_d

    key_len: 4

    ref: const

    rows: 5

    Extra: Using where; Using index

```

当优化器将索引扩展考虑进来，它将**k_d**看作**（d,i1,i2)**。在这种情况下，优化器能使用最左边的索引前缀**（d,i1)**来产生一个更好地执行计划：

```sql

    *************************** 1. row ***************************

			    id: 1
			
        select_type: SIMPLE
			
			    table: t1
			
			    type: ref
			
	  possible_keys: PRIMARY,k_d
			
			    key: k_d
			
			    key_len: 8
			
			    ref: const,const
			
			    rows: 1
			
			    Extra: Using index

```

上面的两种情况，**key**表明优化器都会使用第二索引**k_d**但是**EXPLAIN**输出展示了使用扩展索引的改进：

* **key_len**从4个字节到8个字节，表明了键检查使用了列**d**和**i1**,而不仅仅是**d**。

* **ref**从**const**改变为**const,const**,因为键检查使用了两个键，而不是一个。

* **rows**数从5降到1，表明**InnoDB**需要检查更少的行来产生结果。

* **Extra**值从**Using where；Using index**改变为**Using index**。这样就意味着能仅仅使用索引获取所需的行，没有从数据行里查阅列。

对于使用扩展索引的不同优化器行为也可以通过**SHOW STATUS**来查看：

```sql

	FLUSH TABLE t1;
	
	FLUSH STATUS;
	
	SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01';
	
	SHOW STATUS LIKE 'handler_read%'

```

前面的语句包括了**FLUSH TABLE**和**FLUSH STATUS** 来刷新表缓存和清除状态计数。

没有索引扩张，**SHOW STATUS**产生这样的结果：

```sql
	
	+-----------------------+-------+
	
	| Variable_name         | Value |
	
	+-----------------------+-------+
	
	| Handler_read_first    | 0     |
	
	| Handler_read_key      | 1     |
	
	| Handler_read_last     | 0     |
	
	| Handler_read_next     | 5     |
	
	| Handler_read_prev     | 0     |
	
	| Handler_read_rnd      | 0     |
	
	| Handler_read_rnd_next | 0     |
	
	+-----------------------+-------+

```

因为索引扩展，**SHOW STATUS**	产生了下面的结果，**Handler_read_next**值从5降到1，表明了更有效地使用了索引：

```sql

	+-----------------------+-------+
	
	| Variable_name         | Value |
	
	+-----------------------+-------+
	
	| Handler_read_first    | 0     |
	
	| Handler_read_key      | 1     |
	
	| Handler_read_last     | 0     |
	
	| Handler_read_next     | 1     |

    | Handler_read_prev     | 0     |

    | Handler_read_rnd      | 0     |

    | Handler_read_rnd_next | 0     |

    +-----------------------+-------+

```

**optimizer_switch**系统变量的**use_index_extensions**标志允许控制当决定怎样使用一个**InnoDB**表的第二索引时控制器是否将主键列考虑进来。默认情况下，**use_index_extensions**是可用的。可以只用下面的语句来检查索引扩展是否禁用会提高效率：

```sql

SET optimizer_switch = 'use_index_extensions = off';

```
通过优化器使用索引扩展是受键数目的限制，一个索引是16,而且最大的键长度是3072字节。


#### 8.2.1.8.**IS NULL**优化(#08.02.01.08)

MySQL可以对可以结合**col_name = constant_value**使用的**col_name IS NULL**进行相同的优化。例如，MySQL可以使用索引和范围用**IS NULL**搜索**NULL**。

```sql

	SELECT * FROM tbl_name WHERE key_col IS NULL;
	 
	SELECT * FROM tbl_name WHERE key_col <=> NULL;
	 
	SELECT * FROM tbl_name
	
	    WHERE key_col=const1 OR key_col=const2 OR key_col IS NULL;

```
如果**WHERE**子句包括声明为**NOT NULL**的列的**col_name IS NULL**条件，表达式则优化。当列会产生**NULL**时，不会进行优化；例如，如果来自**LEFT JOIN**左侧的表。

MySQL也可以优化组合**col_name = expr AND col_name IS NULL**，这是解决子查询的一种常用形式。当使用优化时**EXPLAIN**显示**ref_or_null**。

该优化可以为任何关键元素处理**IS NULL**。

下面是一些优化的查询例子，假定表t2的列a和b有一个索引：

```sql

	SELECT * FROM t1 WHERE t1.a=expr OR t1.a IS NULL;
	 
	SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;
	 
	SELECT * FROM t1, t2
	    WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;
	 
	SELECT * FROM t1, t2
	    WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);
	 
	SELECT * FROM t1, t2
	    WHERE (t1.a=t2.a AND t2.a IS NULL AND ...)
	    OR (t1.a=t2.a AND t2.a IS NULL AND ...);

```

**ref_or_null**首先读取参考关键字，然后单独搜索**NULL**关键字的行。

请注意该优化只可以处理一个**IS NULL**。在后面的查询中，MySQL只对表达式**(t1.a=t2.a AND t2.a IS NULL)**使用关键字查询，不能使用**b**的关键元素：

```sql

	SELECT * FROM t1, t2
	     WHERE (t1.a=t2.a AND t2.a IS NULL)
	     OR (t1.b=t2.b AND t2.b IS NULL);

```

#### 8.2.1.9.LEFT JOIN和RIGHT JOIN优化(#08.02.01.09)

在MySQL中，**A LEFT JOIN B join_condition**执行过程如下：

* 根据表**A**和**A**依赖的所有表设置表**B**。

* 根据**LEFT JOIN**条件中使用的所有表(除了**B**)设置表**A**。

* **LEFT JOIN**条件用于确定如何从表**B**搜索行。(换句话说，不使用**WHERE子**句中的任何条件）。

* 可以对所有标准联接进行优化，只是只有从它所依赖的所有表读取的表例外。如果出现循环依赖关系，MySQL提示出现一个错误。

* 进行所有标准**WHERE**优化。

* 如果A中有一行匹配**WHERE**子句，但**B**中没有一行匹配**ON**条件，则生成另一个**B**行，其中所有列设置为**NULL**。

* 如果使用**LEFT JOIN**找出在某些表中不存在的行，并且进行了下面的测试：**WHERE**部分的**col_name IS NULL**，其中**col_name**是一个声明为 **NOT NULL**的列，MySQL找到匹配**LEFT JOIN**条件的一个行后停止(为具体的关键字组合)搜索其它行。

**RIGHT JOIN**的执行类似**LEFT JOIN**，只是表的角色反过来。

联接优化器计算表应联接的顺序。**LEFT JOIN**和**STRAIGHT_JOIN**强制的表读顺序可以帮助联接优化器更快地工作，因为检查的表交换更少。请注意这说明如果执行下面类型的查询，MySQL进行全扫描**b**，因为**LEFT JOIN**强制它在**d**之前读取：

```sql

	SELECT *
	    FROM a,b LEFT JOIN c ON (c.key=a.key) 
		LEFT JOIN d ON (d.key=a.key)
	    WHERE b.key=d.key;

```

在这种情况下修复时用a的相反顺序，b列于FROM子句中：

```sql

	SELECT *
	    FROM b,a LEFT JOIN c ON (c.key=a.key) 
		LEFT JOIN d ON (d.key=a.key)
	    WHERE b.key=d.key;

```

MySQL可以进行下面的**LEFT JOIN**优化：如果对于产生的**NULL**行，**WHERE**条件总为假，**LEFT JOIN**变为普通联接。

例如，在下面的查询中如果**t2.column1**为**NULL**，**WHERE **子句将为false：

```sql

SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;

```

因此，可以安全地将查询转换为普通联接：

```sql

SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;

```

这样可以更快，因为如果可以使查询更佳，MySQL可以在表**t1**之前使用表**t2**。为了强制使用表顺序，使用**STRAIGHT_JOIN**。(查看章节[13.2.9,**SELECT 语法**][SELECT])

#### 8.2.1.10.内循环连接算法(#08.02.01.10)

MySQL执行表之间的连接时使用一个嵌套循环算法或者它的一个变形。

**嵌套循环连接算法**

一个简单的嵌套循环连接（NLJ）算法在一个循环里面从第一个表每次读取一行，然后传递每一行给在连接中处理下一张表的嵌套循环。这个处理过程随着剩余的表被连接循环多次。

假设在**t1**,**t2**和**t3**三张表的一个连接使用如下的连接类型被执行：

```sql
	
	Table   Join Type
	
	t1      range
	
	t2      ref
	
	t3      ALL

```

如果使用了一个简单的NLJ算法，连接过程大概如下：

```sql

	for each row in t1 matching range {
	
	 for each row in t2 matching reference key {
	
	   for each row in t3 {
	
	    if row satisfies join conditions,
	
	    send to client
	
	   }
	
	 }
	
	}

```

因为NLJ算法从外层循环到内层循环是一次传递一行，所以代表性地在内层循环读取表的处理会进行多次。

**块嵌套循环连接算法**

一个块嵌套循环（BNL）连接算法在外层循环使用了行读取的缓冲区来减少表在内循环必须被读到的次数。例如，如果10行被读进缓冲区，而这个缓冲区被传递给下一个内循环，这样内循环的每一行能在缓冲区里面和所有的10行比较。减少了一个内表必须被读取次数的数量级。

MySQL在下面这些条件使用连接缓冲：

* **join_buffer_size**系统变量决定了每一个连接缓冲的大小。

* 当连接是**ALL**或**index**（换句话说，当没有可能的键使用时，一个全表扫描会被执行，数据或索引行，单独地）或**range**类型时连接缓冲会被使用.在MySQL5.6，缓冲的使用被延伸应用到外连接，正如[章节8.2.1.14,块嵌套循环和批键][8.2.1.14]描述。

* 每个能被缓冲的连接都会分配一个缓冲区，所以一个给定的查询应该会使用多个连接缓冲处理。

* 一个连接缓冲从不会被分配到第一个非常量表，即使它是**ALL**或**index**类型。

* 一个连接缓冲区在执行连接之前被分配，而且查询执行之后会被清空。

* 只有连接感兴趣的列会被存储在连接缓冲区，而不是整行。

举一个NLJ算法（没有缓冲）的连接描述例子，连接会像使用连接缓冲执行：

```sql
	
	for each row in t1 matching range {
	
	 for each row in t2 matching reference key {
	
	   store used columns from t1, t2 in join buffer
	
	   if buffer is full {

	    for each row in t3 {
	
	    for each t1, t2 combination in join buffer {
	
	    if row satisfies join conditions,
	
	    send to client
	
	    893
	
	    Optimizing SELECT Statements
	
	    }
	
	    }
	
	    empty buffer
	
	    }
	
	    }
	
	    }
	
	    if buffer is not empty {
	
	    for each row in t3 {
	
	    for each t1, t2 combination in join buffer {
	
	    if row satisfies join conditions,
	
	    send to client
	
	    }
	
	    }
	
	    }

```

如果**S**是每次存储**t1**的大小，**t2**组合是连接缓冲区和**C**是缓冲区里组合的数量，**t3**被扫描的次数是：

	（S * C）/join_buffer_size + 1

**t3**的扫描次数会随着**join_buffer_size**的上升而下降，当**join_buffer_size**上升到它能保存全部之前的行组合的点时，在那个点，不能通过令它更大来获得更高的速度。

#### 8.2.1.11.嵌套连接优化(#08.02.01.11)

表示联接的语法允许嵌套联接。下面的讨论引用了[13.2.9.2节，“JOIN语法”中描述的联接语法][13.2.9.2]。

同SQL标准比较，**table_factor**语法已经扩展了。后者只接受**table_reference**，而不是括号内所列的。

**table_reference**项列表内的每个逗号等价于内部联接，这是一个保留扩展名。例如：

```sql

	SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)

```

等价于：

```sql

	SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
                 ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)

```

在MySQL中，**CROSS JOIN**语法上等价于**INNER JOIN** (它们可以彼此代替。在标准SQL中，它们不等价。**INNER JOIN**结合**ON**子句使用；**CROSS JOIN** 用于其它地方。

总的来说，在只包含内部联接操作的联接表达式中可以忽略括号。删除括号并将操作组合到左侧后，联接表达式：

```sql

	t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
       ON t1.a=t2.a

```
转换为表达式：

```sql

	(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3
    	ON t2.b=t3.b OR t2.b IS NULL

```
但是这两个表达式不等效。要说明这点，假定表**t1**、**t2**和**t3**有下面的状态：

* 表t1包含行{1}、{2}

* 表t2包含行{1,101}

* 表t3包含行{101}

在这种情况下，第1个表达式返回包括行{1,1,101,101}、{2,NULL,NULL,NULL}的结果，第2个表达式返回行{1,1,101,101}、{2,NULL,NULL,101}：

```sql

	mysql> SELECT *
	    -> FROM t1
	    ->      LEFT JOIN
	    ->      (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
	    ->      ON t1.a=t2.a;
	+------+------+------+------+
	| a    | a    | b    | b    |
	+------+------+------+------+
	|    1 |    1 |  101 |  101 |
	|    2 | NULL | NULL | NULL |
	+------+------+------+------+
	 
	mysql> SELECT *
	    -> FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)
	    ->      LEFT JOIN t3
	    ->      ON t2.b=t3.b OR t2.b IS NULL;
	+------+------+------+------+
	| a    | a    | b    | b    |
	+------+------+------+------+
	|    1 |    1 |  101 |  101 |
	|    2 | NULL | NULL |  101 |
	+------+------+------+------+

```

在下面的例子中，外面的联接操作结合内部联接操作使用：

```sql

t1 LEFT JOIN (t2，t3) ON t1.a=t2.a

```sql

该表达式不能转换为下面的表达式：

```sql

t1 LEFT JOIN t2 ON t1.a=t2.a，t3.

```
对于给定的表状态，第1个表达式返回行{1,1,101,101}、{2,NULL,NULL,NULL}，第2个表达式返回行{1,1,101,101}、{2,NULL,NULL,101}：

```sql
	
	mysql> SELECT *
	    -> FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;
	+------+------+------+------+
	| a    | a    | b    | b    |
	+------+------+------+------+
	|    1 |    1 |  101 |  101 |
	|    2 | NULL | NULL | NULL |
	+------+------+------+------+
	 
	mysql> SELECT *
	    -> FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;
	+------+------+------+------+
	| a    | a    | b    | b    |
	+------+------+------+------+
	|    1 |    1 |  101 |  101 |
	|    2 | NULL | NULL |  101 |
	+------+------+------+------+

```

因此，如果我们忽略联接表达式中的括号连同外面的联接操作符，我们会改变原表达式的结果。

更确切地说，我们不能忽视左外联接操作的右操作数和右联接操作的左操作数中的括号。换句话说，我们不能忽视外联接操作中的内表达式中的括号。可以忽视其它操作数中的括号(外部表的操作数)。

对于任何表**t1、t2、t3**和属性**t2.b**和**t3.b**的任何条件**P**，下面的表达式：

```sql

(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)

```

等价于表达式 

```sql

t1，t2 LEFT JOIN t3 ON P(t2.b,t3.b)

```
如果联接表达式(**join_table**)中的联接操作的执行顺序不是从左到右，我们则应讨论嵌套的联接。这样，下面的查询：

```sql

SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a
  WHERE t1.a > 1
 
SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
  WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a > 1

```
联接表：

```sql

t2 LEFT JOIN t3 ON t2.b=t3.b
t2, t3

```
认为是嵌套的。第1个查询结合左联接操作则形成嵌套的联接，而在第二个查询中结合内联接操作形成嵌套联接。

在第1个查询中，括号可以忽略：联接表达式的语法结构与联接操作的执行顺序相同。但对于第2个查询，括号不能省略，尽管如果没有括号，这里的联接表达式解释不清楚。(在外部扩展语法中，需要第2个查询的**(t2，t3)**的括号，尽管从理论上对查询分析时不需要括号：这些查询的语法结构将仍然不清楚，因为**LEFT JOIN**和**ON**将充当表达式**(t2,t3)**的左、右界定符的角色)。

前面的例子说明了这些点：

* 对于只包含内联接(而非外联接)的联接表达式，可以删除括号。你可以移除括号并从左到右评估(或实际上，你可以按任何顺序评估表)。

* 总的来说，对外联接却不是这样。去除括号可能会更改结果。
* 总的来说，对外联接和内联接的结合，也不是这样。去除括号可能会更改结果。

含嵌套外联接的查询按含内联接的查询的相同的管道方式执行。更确切地说，利用了嵌套环联接算法。让我们回忆嵌套环联接执行查询时采用什么算法。

假定我们有一个如下形式的表T1、T2、T3的联接查询：

```sql

SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2)
                 INNER JOIN T3 ON P2(T2,T3)
  WHERE P(T1,T2,T3).

```

这里，**P1(T1,T2)**和**P2(T3,T3)**是一些联接条件(表达式)，其中**P(t1,t2,t3)**是表**T1、T2、T3**的列的一个条件。

嵌套环联接算法将按下面的方式执行该查询：

```sql

	FOR each row t1 in T1 {
	  FOR each row t2 in T2 such that P1(t1,t2) {
	    FOR each row t3 in T3 such that P2(t2,t3) {
	      IF P(t1,t2,t3) {
	         t:=t1||t2||t3; OUTPUT t;
	      }
	    }
	  }
	}

```

符号**t1||t2||t3**表示“连接行**t1、t2**和**t3**的列组成的行”。在下面的一些例子中，出现行名的NULL表示NULL用于行的每个列。例如，**t1||t2||NULL**表示“连接行**t1**和**t2**的列以及**t3**的每个列的**NULL**组成的行”。

现在让我们考虑带嵌套的外联接的查询：

```sql

	SELECT * FROM T1 LEFT JOIN
	              (T2 LEFT JOIN T3 ON P2(T2,T3))
	              ON P1(T1,T2)
	  WHERE P(T1,T2,T3)。

```
对于该查询我们修改嵌套环模式可以得到：

```sql

	FOR each row t1 in T1 {
	  BOOL f1:=FALSE;
	  FOR each row t2 in T2 such that P1(t1,t2) {
	    BOOL f2:=FALSE;
	    FOR each row t3 in T3 such that P2(t2,t3) {
	      IF P(t1,t2,t3) {
	        t:=t1||t2||t3; OUTPUT t;
	      }
	      f2=TRUE;
	      f1=TRUE;
	    }
	    IF (!f2) {
	      IF P(t1,t2,NULL) {
	        t:=t1||t2||NULL; OUTPUT t;
	      }
	      f1=TRUE;
	    }
	  }
	  IF (!f1) {
	    IF P(t1,NULL,NULL) {
	      t:=t1||NULL||NULL; OUTPUT t;
	    }
	  }
	}

```

总的来说，对于外联接操作中的第一个内表的嵌套环，引入了一个标志，在环之前关闭并且在环之后打开。如果对于外部表的当前行，如果匹配表示内操作数的表，则标志打开。如果在循环结尾处标志仍然关闭，则对于外部表的当前行，没有发现匹配。在这种情况下，对于内表的列，应使用NULL值补充行。结果行被传递到输出进行最终检查或传递到下一个嵌套环，但只能在行满足所有嵌入式外联接的联接条件时。

在我们的例子中，嵌入了下面表达式表示的外联接表：

```sql

(T2 LEFT JOIN T3 ON P2(T2,T3))

```

请注意对于有内联接的查询，优化器可以选择不同的嵌套环顺序，例如：

```sql

	FOR each row t3 in T3 {
	  FOR each row t2 in T2 such that P2(t2,t3) {
	    FOR each row t1 in T1 such that P1(t1,t2) {
	      IF P(t1,t2,t3) {
	         t:=t1||t2||t3; OUTPUT t;
	      }
	    }
	  }
	}

```

对于有外联接的查询，优化器可以只选择这样的顺序：外表的环优先于内表的环。这样，对于有外联接的查询，只可能有一种嵌套顺序。在下面的查询中，优化器将评估两个不同的嵌套：

```sql

	SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)
	  WHERE P(T1,T2,T3)

```

嵌套为：

```sql

	FOR each row t1 in T1 {
	  BOOL f1:=FALSE;
	  FOR each row t2 in T2 such that P1(t1,t2) {
	    FOR each row t3 in T3 such that P2(t1,t3) {
	      IF P(t1,t2,t3) {
	        t:=t1||t2||t3; OUTPUT t;
	      }
	      f1:=TRUE
	    }
	  }
	  IF (!f1) {
	    IF P(t1,NULL,NULL) {
	      t:=t1||NULL||NULL; OUTPUT t;
	    }
	  }
	}

```

和

```sql

	FOR each row t1 in T1 {
	  BOOL f1:=FALSE;
	  FOR each row t3 in T3 such that P2(t1,t3) {
	    FOR each row t2 in T2 such that P1(t1,t2) {
	      IF P(t1,t2,t3) {
	        t:=t1||t2||t3; OUTPUT t;
	      }
	      f1:=TRUE
	    }
	  }
	  IF (!f1) {
	    IF P(t1,NULL,NULL) {
	      t:=t1||NULL||NULL; OUTPUT t;
	    }
	  }
	}

```

在两个嵌套中，必须在外环中处理**T1**，因为它用于外联接中。**T2**和**T3**用于内联接中，因此联接必须在内环中处理。但是，因为该联接是一个内联接，**T2**和**T3**可以以任何顺序处理。

当讨论内联接嵌套环的算法时，我们忽略了部分详情，可能对查询执行的性能的影响会很大。我们没有提及所谓的“下推”条件。假定可以用连接公式表示我们的**WHERE**条件**P(T1,T2,T3)**：

```sql

P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3)。

```

在这种情况下，MySQL实际使用了下面的嵌套环方案来执行带内联接得到查询：

```sql
	
	FOR each row t1 in T1 such that C1(t1) {
	  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  {
	    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {
	      IF P(t1,t2,t3) {
	         t:=t1||t2||t3; OUTPUT t;
	      }
	    }
	  }
	}

```

你会看见每个连接 **C1(T1)，C2(T2)，C3(T3)**被从最内部的环内推出到可以对它进行评估的最外的环中。如果**C1(T1)**是一个限制性很强的条件，下推条件可以大大降低从表**T1**传递到内环的行数。结果是查询大大加速。

对于有外联接的查询，只有查出外表的当前的行可以匹配内表后，才可以检查WHERE条件。这样，对内嵌套环下推的条件不能直接用于带外联接的查询。这里我们必须引入有条件下推前提，由遇到匹配后打开的标志保护。

对于带下面的外联接的例子

```sql

P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)

```

使用受保护的下推条件的嵌套环方案看起来应为：

```sql
	
	FOR each row t1 in T1 such that C1(t1) {
	  BOOL f1:=FALSE;
	  FOR each row t2 in T2
	      such that P1(t1,t2) AND (f1?C2(t2):TRUE) {
	    BOOL f2:=FALSE;
	    FOR each row t3 in T3
	        such that P2(t2,t3) AND (f1&&f2?C3(t3):TRUE) {
	      IF (f1&&f2?TRUE:(C2(t2) AND C3(t3))) {
	        t:=t1||t2||t3; OUTPUT t;
	      }
	      f2=TRUE;
	      f1=TRUE;
	    }
	    IF (!f2) {
	      IF (f1?TRUE:C2(t2) && P(t1,t2,NULL)) {
	        t:=t1||t2||NULL; OUTPUT t;
	      }
	      f1=TRUE;
	    }
	  }
	  IF (!f1 && P(t1,NULL,NULL)) {
	      t:=t1||NULL||NULL; OUTPUT t;
	  }
	}

```

总的来说，可以从联接条件（例如**P1(T1,T2)**和**P(T2,T3)**）提取下推前提。在这种情况下，下推前提也受一个标志保护，防止检查由相应外联接操作所产生的NULL-补充的行的断言。

请注意如果从判断式的**WHERE**条件推导出，根据从一个内表到相同嵌套联接的另一个表的关键字进行的访问被禁止。(在这种情况下，我们可以使用有条件关键字访问，但是该技术还未用于MySQL 5.6中）。

#### 8.2.1.12.简化外连接(#08.02.01.12)

在许多情况下，一个查询的**FROM**子句的表的表达式可以简化。

在分析阶段，带右外联接操作的查询被转换为只包含左联接操作的等效查询。总的来说，根据以下原则进行转换：

```sql
	
	(T1, ...) RIGHT JOIN (T2,...) ON P(T1,...,T2,...) =
	(T2, ...) LEFT JOIN (T1,...) ON P(T1,...,T2,...)

```

所有**T1 INNER JOIN T2 ON P(T1,T2)**形式的内联接表达式被替换为**T1,T2、P(T1,T2)**，并根据**WHERE**条件(或嵌入连接的联接条件，如果有)联接为一个连接。

当优化器为用外联接操作的联接查询评估方案时，它只考虑在访问内表之前访问外表的操作的方案。优化器选项受到限制，因为只有这样的方案允许我们用嵌套环机制执行带外联接操作的查询。

假定我们有一个下列形式的查询：

```sql
	
	SELECT * T1 LEFT JOIN T2 ON P1(T1,T2)
	
	  WHERE P(T1,T2) AND R(T2)

```

**R(T2)**大大减少了表**T2**中匹配的行数。如果我们这样执行查询，优化器将不会有其它选择，只能在访问表**T2**之前访问表**T1**，从而导致执行方案非常低。

幸运的是，如果**WHERE**条件拒绝**null**，MySQL可以将此类查询转换为没有外联接操作的查询。如果为该操作构建的**NULL**补充的行评估为**FALSE**或**UNKNOWN**，则该条件称为对于某个外联接操作拒绝null。

因此，对于该外联接：

```sql
	
	T1 LEFT JOIN T2 ON T1.A=T2.A

```

类似下面的条件为拒绝null：

```sql
	
	T2.B IS NOT NULL,
	T2.B > 3,
	T2.C <= T1.C,
	T2.B < 2 OR T2.C > 1
 
```

类似下面的条件不为拒绝null：

```sql
	
	T2.B IS NULL,
	T1.B < 3 OR T2.B IS NOT NULL,
	T1.B < 3 OR T2.B > 3

```

检查一个外联接操作的条件是否拒绝null的总原则很简单。以下情况下为拒绝null的条件：

* 形式为**A IS NOT NULL**，其中**A**是任何内表的一个属性

* 包含内表引用的判断式，当某个参量为**NULL**时评估为**UNKNOWN**

* 包含用于连接的拒绝**null**的条件的联合

* 拒绝**null**的条件的逻辑和

一个条件可以对于一个查询中的一个外联接操作为拒绝null的而对于另一个不为拒绝null的。在下面的查询中：

```sql

	SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
	
	                 LEFT JOIN T3 ON T3.B=T1.B
	
	  WHERE T3.C > 0

```

**WHERE**条件对于第2个外联接操作为拒绝null的但对于第1个不为拒绝null的。

如果**WHERE**条件对于一个查询中的一个外联接操作为拒绝null的，外联接操作被一个内联接操作代替。

例如，前面的查询被下面的查询代替：

```
	
	SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
	
	                 INNER JOIN T3 ON T3.B=T1.B
	
	  WHERE T3.C > 0
```

对于原来的查询，优化器将评估只与一个访问顺序**T1、T2、T3**兼容的方案。在替换的查询中，还考虑了访问顺序**T3、T1、T2**。

一个外联接操作的转化可以触发另一个的转化。这样，查询：

```sql
	
	SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
	
	                 LEFT JOIN T3 ON T3.B=T2.B
	
	  WHERE T3.C > 0

```

将首先转换为查询：

```sql
	
	SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A
	
	                 INNER JOIN T3 ON T3.B=T2.B
	
	  WHERE T3.C > 0
 
```

该查询等效于查询：

```sql

	SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
	
	  WHERE T3.C > 0 AND T3.B=T2.B

```

现在剩余的外联接操作也可以被一个内联接替换，因为条件**T3.B=T2.B**为拒绝null的，我们可以得到一个根本没有外联接的查询：

```sql

	SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
	
	  WHERE T3.C > 0 AND T3.B=T2.B

```

有时我们可以成功替换嵌入的外联接操作，但不能转换嵌入的外联接。下面的查询：

```sql
	
	SELECT * FROM T1 LEFT JOIN
	
	              (T2 LEFT JOIN T3 ON T3.B=T2.B)
	
	              ON T2.A=T1.A
	
	  WHERE T3.C > 0

```

被转换为：

```sql

	SELECT * FROM T1 LEFT JOIN
	
	              (T2 INNER JOIN T3 ON T3.B=T2.B)
	
	              ON T2.A=T1.A
	
	  WHERE T3.C > 0，

```

只能重新写为仍然包含嵌入式外联接操作的形式：

```sql

	SELECT * FROM T1 LEFT JOIN
	
	              (T2,T3)
	
	              ON (T2.A=T1.A AND T3.B=T2.B)
	
	  WHERE T3.C > 0。

```

如果试图转换一个查询中的嵌入式外联接操作，我们必须考虑嵌入式外联接的联接条件和**WHERE**条件。在下面的查询中：

```sql

	SELECT * FROM T1 LEFT JOIN
	              (T2 LEFT JOIN T3 ON T3.B=T2.B)
	              ON T2.A=T1.A AND T3.C=T1.C
	  WHERE T3.D > 0 OR T1.D > 0

```

**WHERE**条件对于嵌入式外联接不为拒绝null的，但嵌入式外联接**T2.A=T1.A AND T3.C=T1.C**的联接条件为拒绝null的。因此该查询可以转换为：

```sql

	SELECT * FROM T1 LEFT JOIN
	
	              (T2, T3)
	
	              ON T2.A=T1.A AND T3.C=T1.C AND T3.B=T2.B
	
	  WHERE T3.D > 0 OR T1.D > 0

```

#### 8.2.1.13.多范围读优化(#08.02.01.13)

当表很大而且没有存储在存储引擎的缓存时，在一个第二索引使用一个范围扫描来读取行会导致很多对基本表的随机磁盘访问。随着磁盘扫描多范围读取（Multi-Range Read，MRR）优化，MySQL试着降低通过仅仅第一次扫描索引和搜集相关行关键字的范围扫描所带来的随机磁盘访问次数。然后被排序的关键字和最终的行通过使用主键的顺序从表检索出来。磁盘扫描MRR推动降低随机磁盘访问的次数，取而代之的是获得一个基本表数据更有次序的扫描。

多范围读优化带来了这些好处：

* MRR能使数据行更有顺序地被访问而不是一个随机的次序，这个是基于索引元组的。服务器包含了一组能满足查询条件的索引元组，服务器会将这些索引元组根据数据行的ID顺序排序，然后使用排好序的元组顺序地来检索数据行。这样使到数据访问更有效和更少开支。

* MRR能使需要通过索引元祖访问数据行的操作的关键字访问请求的批处理可用，例如范围索引扫描和使用了一个索引的连接equi-joins。MRR迭代一个索引范围的序列来获取具有资格的索引元组。随着这些结果的累加，它们被用于访问相应的数据行。在开始读取数据行之前是不需要所有的索引元组。

接下来的情景阐明了MRR优化是有用的：

情景A:MRR能为索引范围扫描和相等连接操作（equi-join）被用于**InnoDB**和**MyISAM**表。

1.一部分索引元祖被累加到缓冲区。

2.缓冲区的元组根据它们的数据行ID来排序。

3.数据行是根据已排序的索引元组序列来访问的。

情景B:MRR能被用于**NDB**表的多范围索引扫描或者通过一个属性执行一个相等连接操作（equi-join）。

1.当查询被提交时，一部分的范围，可能是单关键字范围，会被累加到中心节点的一个缓冲区。

2.范围会被发送到访问数据行的执行节点。

3.被访问的行被打包成数据包和发送回中心节点。

4.带有数据行的包到达后会被放置到一个缓冲区。

5.从缓冲区读取数据行。

当MRR被使用，**EXPLAIN**输出结果的**Extra**列显示**Using MRR**。

如果全表行不需要被访问来产生查询结果，**InnoDB**和**MyISAM**不会使用MRR。这就是如果结果能完全基于索引元组（通过一个[覆盖索引][covering index]）信息产生的情况；MRR提供不了好处。

举一个MRR能被使用的例子，假设有一个索引在**（key_part1,key_part2）**:

```sql
	
	SELECT * FROM t
	  WHERE key_part1 >= 1000 AND key_part1 < 2000
	  AND key_part2 = 10000;

```

索引包含了**（key_part1，key_part2）**值的元组，先由**key_part1**排序后由**key_part2**。

没有MRR，一个索引扫描为**key_part1**的1000到2000范围覆盖了所有的索引元组，不管**key_part2**值在这些元组。扫描做了额外的工作来扩展**key_part2**值不是10000而在这个范围的元组。

有了MRR，扫描被分解成多范围，每一个对应**key_part1**（1000,1001，...，1999）的一个值。这些的每一个扫描只需查看**key_part2**=10000的元组。如果索引包含很多**key_part2**不是10000的元组，MRR导致很多较少索引的元组被读取。

使用间隔符号来表述上面的意思，非MRR扫描必须检查索引范围**[{1000,10000},{2000,MIN_INT}]**,这些索引范围可能包含了很多除了**key_part2**=10000的其他元组。MRR扫描检查多个单点区间**[{1000,10000}],...,[{1999，10000}]，而这些区间仅仅包含**key_part2=10000**的元组。

两个**optimizer_switch**系统变量标志提供了一个接口来使用MRR优化。**mrr**优化控制MRR是否可用。如果**mrr**可用（**on**）,**mrr_cost_based**标志控制着优化器是否会在使用或不使用（**on**）之间尝试做一个成本原则的选择或者只要可能就使用MRR(**off**)。默认情况下，**mrr**是**on**和**mrr_cost_based**也是**on**。查看[章节8.8.5.2,“控制可控制的优化”][8.8.5.2]

对于MRR，一个存储引擎使用**read_rnd_buffer_size**系统变量的值作为它能分配多少内存给它的缓冲区的一个指导方针。引擎使用相当于**read_rnd_buffer_size**的字节和在一次单程扫描中决定范围的数量来处理。

#### 8.2.1.14.块嵌套循环和批关键字访问连接(#08.02.01.14)

在MySQL5.6，一个批关键字访问（BKA）连接算法是可用的，都使用到索引访问连接的表和一个连接缓冲区。BKA算法支持内连接、外连接和半连接操作，包含嵌套外连接。BKA的好处包括提高连接执行，归因于更高效的表扫描。另外，预先只被用于内连接的块嵌套循环（BNL）连接算法被扩展和能被用于外连接和半连接操作，包括嵌套外连接。

接下来的章节讨论成为原始BNL算法、扩展的BNL算法和BKA算法扩展基础的连接缓冲区管理。有关半连接（semi-join）策略的信息，查看[章节8.2.1.18.1，“用半连接转换优化子查询”][8.2.1.18.1]

##### 8.2.1.14.1.块嵌套循环和批关键字访问算法的连接缓冲区管理

在MySQL5.6，MySQL5.6能应用连接缓冲区来执行没有索引访问内层表的内连接和外连接和出现在子查询压扁后的半连接。而且，当一个索引访问内层表时，一个连接缓冲区能有效地被使用。

当存储感兴趣行列的值时，连接缓冲区管理轻微地编码更有效地利用连接缓冲区空间：如果一个行列的值是**NULL**,在缓冲区不会有额外的字节分配给它们，分配给任何值得最小的字节数是**VARCHAR**类型。

编码支持两种类型的缓冲区，常规的和递增的。假设缓冲区**B1**被应用于连接表**t1**和**t2**，而这个操作的结果通过缓冲区**B2**来连接表**t3**：

* 一个常规的连接缓冲区包含每一个连接操作对象的列。如果**B2**是一个常规连接缓冲区，每一个放进**B2**的行**r**都是由**B1**的一行**r1**的列和表**t2**的一个匹配的行里感兴趣的列组成。

* 一个递增的连接缓冲区仅仅包含第二个连接操作对象产生表的行的列。 就是说，从第一个缓冲区增加一行。如果**B2**是一个递增的连接缓冲区，它包含了行**r2**感兴趣的列和一个指向**B1**的行**r1**的链接。

递增的连接缓冲区相对于一个更早的连接操作的连接缓冲区总是递增的，所以第一个连接操作的缓冲区总是一个常规缓冲区。在刚刚给出来的例子，被用于连接表**t1**和**t2**的缓冲区**B1**必须是一个常规缓冲区。

被用于一个连接操作的递增缓冲区的每一行只包含被连接的表的一行中感兴趣的列。这些列增加了一个引用到来自表、由第一个连接操作产生的匹配行的感兴趣列。递增缓冲区的几个行可以参考同一个行**r**,这个行**r**的列被存储在先前的连接缓冲区，这些行都匹配它。

递增缓冲区使更少地频繁从被使用于先前连接操作的缓冲区复制列成为可能。这样提供了缓冲区空间的节省，因为一般情况下，一个由第一个连接操作产生的行能被多个由第二个连接操作产生的行匹配。不需要从第一个操作复制一个行多次。递增缓冲区也提供了处理时间上的节省，因为复制时间的减少。

从MySQL5.6.3开始，**optimizer_switch**系统变量的**block_nested_loop**和**batched_key_access**标志控制着优化器怎样使用块嵌套循环和批关键字访问连接算法。默认情况下，**block_nested_loop**是**on**和**batch_key_access**是**off**状态。查看[章节8.8.5.2,"控制可控制的优化"][8.8.5.2]

在MySQL5.6.3之前，**optimizer_join_cache_level**系统变量控制连接缓冲区管理。对于这个变量的可能值和它们的意义，查看[章节5.1.4,"服务器系统变量"][5.1.4]

有关半连接策略的信息，查看[章节8.2.1.18.1,"用半连接优化子查询"][8.2.1.18.1]

##### 8.2.1.14.2.外连接和半连接的块嵌套循环算法

在MySQL5.6，BNL算法的原始实现被扩展来支持外连接和半连接。

当用了一个连接缓冲区来执行这些操作，每一个被放进缓冲区的行都被提供了一个匹配的标志。

如果使用一个连接缓冲区执行外连接操作，由第二个操作产生的表的行都会被检查与连接缓冲区的行是否匹配。当一个匹配被发现，一个新的扩展行被构建（原始行加上从第二个操作得到的列）和被发送到更长远的扩展通过剩下的连接操作。另外，缓冲区里的匹配行的匹配标志可用。被连接表的所有行被检查后，连接缓冲区将会被扫描。缓冲区里每一个没有它的匹配标志的行会通过**NULL**补充（第二个操作的列的**NULL**值）被扩展和通过剩下的连接操作被发送到更长远的连接。

从MySQL5.6.3开始，**optimizer_switch**系统变量的**block_nested_loop**标志控制着优化器怎样使用块嵌套循环算法。默认情况下，**block_nested_loop**是**on**的。查看[章节8.8.5.2，“控制可控制的优化”][8.8.5.2]

在MySQL5.6.3之前，**optimizer_join_cache_level**系统变量控制着连接缓冲区管理。对于这个变量的可能值和它们的意义，查看[章节5.1.4,"服务器系统变量"][5.1.4]

在**EXPLAIN**输出，当**Extra**值包含**Using join buffer（Block Nested Loop）**和**type**值是**ALL,index**，或**range**值时，是指对该表使用了BNL。

有关半连接策略的信息，查看[章节8.2.1.18.1,“用半连接优化子查询”][8.2.1.18.1]。

##### 8.2.1.14.3.批关键字访问连接

MySQL5.6.3实现了一个连接表的方法叫做批关键字访问（BKA）连接算法。当有一个索引访问由第二个连接操作产生的表时，BKA会被应用。像BNL连接算法，BKA连接算法使用了一个连接缓冲区来累加连接运算的第一个操作数产生的行中感兴趣的列。然后BKA算法建立关键字来访问被连接的表在缓冲区的所有行和一批地提交这些关键字到数据库引擎用来索引查找。关键字通过多范围读（MRR）接口（参见[章节8.2.1.13，“多范围读优化”][8.2.1.13]）提交到引擎。关键字提交后，MRR引擎在一种最佳的方式下函数执行索引的检查，获取连接表中由这些关键字找到的行，和开始将匹配的行供给BKA连接算法。每一行都会与连接缓冲区的一行的引用相结合。

要想BKA被使用，**optimizer_switch**系统变量的**batched_key_access**标志必须设置为**on**。BKA使用MRR,所以**mrr**标志也必须为**on**。一般地，MRR的花费估计会太悲观。因此，对于BKA的被使用是非常有必要设置**mrr_cost_based**为**off**。下面的设置是BKA可用：

```sql

mysql>SET optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';

```

有两种情景MRR功能是会执行的：

* 第一种情景被用于传统的基于磁盘的存储引擎，例如**InnoDB**和**MyISAM**。对于这些引擎，连接缓冲区所有行的关键字通常地会立刻被提交到MRR接口。引擎特定的MRR函数对提交的关键字完成索引检查，从他们获取行ID（或主键），然后通过请求BKA算法一个一个地获取这些被选的行ID对应的行。返回的每一行都会带有一个相关的引用，这个引用可用于访问连接缓冲区里匹配的行。行以一种最佳的方式通过MRR被获取：它们以行ID（或主键）的顺序被获取。这样提高了性能，因为以磁盘顺序读取而不是随机顺序。

* 第二种情景被用于远程存储引擎例如**NDB**。连接缓冲区的一部分行的关键字包，连同它们的关联通过一台MySQL服务器（SQL节点）被发送到MySQL集群数据节点。作为回报，SQL节点收到一个或多个匹配行连同一致的关联的包。BKA连接算法拿这些行和建立新的连接行。然后一个新的关键字集合被发送到数据节点和返回的包中的行被用于建立新的连接行。处理会一直持续到连接缓冲区的最后一个关键字被发送到数据节点，SQL节点接收和连接所有匹配这些关键字的行。这样提高了性能，因为更少的关键字联系包通过SQL节点被发送到数据节点，意味着它和数据节点之间更少的往返来执行连接操作。

第一种情景，连接缓冲区的一部分被留作用来存储那些被索引检查选择和作为一个MRR函数参数传递的IDs（主键）。

没有特定的缓冲区来存储为连接缓冲区的行而建立的关键字。相反，一个在缓冲区为下一行建立关键字的函数被作为一个参数传递给MRR函数。

在**EXPLAIN**输出，当**Extra**值包含**Using join buffer（Batched Key Access ）**和**type**值是**ref**，或**eq_ref**值时，是指对该表使用了BKA。

#### 8.2.1.15.ORDER BY优化(#08.02.01.15)

在某些情况中，MySQL可以使用一个索引来满足**ORDER BY**子句，而不需要额外的排序。

即使**ORDER BY**不确切匹配索引，只要**WHERE**子句中的所有未使用的索引部分和所有额外的**ORDER BY** 列为常数，就可以使用索引。下面的查询使用索引来解决**ORDER BY**部分：

```sql

	SELECT * FROM t1 
	
	    ORDER BY **key_part1,key_part2**,... ;
	
	    
	
	SELECT * FROM t1 
	
	    WHERE **key_part1**=**constant** 
	
	    ORDER BY **key_part2**;
	
	    
	
	SELECT * FROM t1 
	
	    ORDER BY **key_part1** DESC, **key_part2** DESC;
	
	    
	
	SELECT * FROM t1
	
	    WHERE **key_part1**=1 
	
	    ORDER BY **key_part1** DESC, **key_part2** DESC;

```

在某些情况下，MySQL不能使用索引来解决ORDER BY，尽管它仍然使用索引来找到匹配WHERE子句的行。这些情况包括：

* 对不同的关键字使用ORDER BY：

```sql

	SELECT * FROM t1 ORDER BY key1, key2；

```

* 对关键字的非连续元素使用ORDER BY：

```sql

	SELECT * FROM t1 WHERE key2=constant ORDER BY key_part2；

```

* 混合ASC和DESC：

```sql

	SELECT * FROM t1 ORDER BY key_part1 DESC, key_part2 ASC；

```

* 用于查询行的关键字与ORDER BY中所使用的不相同：

```sql

	SELECT * FROM t1 WHERE key2=constant ORDER BY key1；
```

在一个除了关键字列名还包含术语的表达式使用ORDER BY：

```sql

SELECT * FROM t1 ORDER BY ABS(key);
SELECT * FROM t1 ORDER BY -key;

```

* 你正联接许多表，并且ORDER BY中的列并不是全部来自第1个用于搜索行的非常量表。(这是EXPLAIN输出中的没有const联接类型的第1个表）。

* 有不同的ORDER BY和GROUP BY表达式。

* 在一个**ORDER BY**子句中只将列名的一个前缀编入索引中。这种情况，索引不能被用于充分地解决排序顺序。例如，有一个**CHAR(20)**的列，但只将前10个字节编入索引，索引不能区分超过第10个字节的值，就需要文件排序了。

* 使用的表索引的类型不能按顺序保存行。例如，对于HEAP表的HASH索引情况即如此。

一个索引的可用性是受列别名的使用影响的。假设列**t1.a**被添加了索引。在这一句，在选择列表的列名是**a**。它参考**t1.a**,对于在**ORDER BY**里**a**的参照，索引是不能被使用的：

```sql

	SELECT a FROM t1 ORDER BY a;
		
```

在下面一句，在选择列表的列名也是**a**。但它是别名。它参考**ABS(a)**,对于在**ORDER BY**里**a**的参照，索引是不能被使用的：

```sql

	SELECT ABS(a) AS a FROM t1 ORDER BY a;

```

在接下来的这一句，**ORDER BY**参考的名不是选择列表的列名。但**t1**有一列的名是**a**,所以ORDER BY使用了它，而索引能被使用。（当然，作为结果的排序顺序或者从**ABS(a)**得到的顺序完全不同）

```sql

SELECT ABS(a) As b FROM t1 ORDER BY a;

```

默认情况，MySQL会排序所有的**ORDER BY col1,col2,...**查询如同在查询中指定**ORDER BY col1,col2,...**。如果你明确地包含了一个含有相同列项的**ORDER BY**子句，MySQL优化它不会有任何速度上的处罚，尽管排序依然进行。如果一个查询包含**ORDER BY**，但你想避免排序结果的消耗，你可以通过指定**ORDER BY NULL**废止排序。例如：

```sql
	
	INSERT INTO foo
	
	SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;

```
依赖暗示的**GROUP BY**排序在MySQl5.6是弃用的。要获得一个分组结果的指定排序顺序，明确地使用**ORDER BY**子句是更可取的。**GROUP BY**排序是MySQL的一个扩展，这个扩展可能在将来的发行版本有所改变；例如，令它更适合优化器无论采用何种手法它都认为是最有效的和避免排序消耗。

通过**EXPLAIN SELECT ...ORDER BY**，可以检查MySQL是否可以使用索引来解决查询。如果**Extra**列内有**Using filesort**，则不能解决查询。参见[章节8.8.1，“关于EXPLAIN优化查询”][8.8.1]。文件排序使用一个固定长度的行存储格式，类似于被[MEMORY][14.4]使用。可变长度的类型例如**VARCHAR**使用一个固定长度来存储。

对于排序和检索结果，MySQL有两个文件排序的算法。原始方法是仅仅使用**ORDER BY**列。修改后的方法不仅使用**ORDER BY**列，所有列都被使用到查询。

优化器会选择使用哪一种文件排序算法。一般会使用修改后的算法除非有**BLOB**或**TEXT**列被包含，这种情况它会使用原始算法。

原始文件排序算法工作如下：

1. 根据关键字或者表扫描来读取所有的行。没有匹配**WHERE**子句的行被忽略。

2. 对于每一行，在一个缓冲区保存存储一对值（排序的关键字和行指针）。缓冲区的大小是**sort_buffer_size**系统变量的值。

3. 当缓冲区满的时候，在它里面运行一个快排和保存结果在一个临时文件。保存一个指向排好序的块的指针。（如果所有的对值都能放进排序缓冲区，临时文件不会被创建。）

4. 重复前面的步骤，直到所有的行都被读取。

5. 在另一个临时文件做一个相当于一个块的**MERGEBUFF**(7)区域的多路合并。重复直到第一个文件的所有块都在第二个文件。

6. 重复接下来的步骤直到少于离开的**MERGEBUFF2**块。

7. 在最后一次多路合并，只有行的指针（排序关键字的最后部分）被写到一个结果文件。

8. 通过结果文件的行指针依照排序顺序读取行。为了优化这个，我们读取行指针的一个大块，然后排序它们和使用进入一个行缓冲区以排序顺序读取行。

使用这个方法的一个问题是要读取行两次：一次是评估**WHERE**子句的时候，另一次是排序对值后。即使行第一次就被成功读取（例如，进行了表扫描），第二次他们被随机访问。（排序的关键字是顺序的，不过行位置不是。）

修改过的文件排序算法包含了一个优化，例如它不仅记录排序关键字的值和行位置，还记录查询需要的列。这样避免了读取表两次。修改过的文件排序算法工作如下：

1. 读行匹配WHERE子句的行，如前面所示。

2. 对于每个行，记录构成排序关键字和行位置的一系列值，并且记录查询需要的列。

3. 根据排序关键字排序元组

4. 按排序的顺序检索行，但直接从排序的元组读取需要的列，而不是再一次访问表。

使用修改后的文件排序算法，元组会比在原始算法使用的对值要长，更少的它们适合排序缓冲区（这个缓冲区的大小由**sort_buffer_size**分配）。结果是额外的IO会令到修改接近更慢而不是更快。为了避免速度下降，只有排序元组的额外列的总大小不超过**max_length_for_sort_data**系统变量的值时，优化才会被使用。（设置这个变量的值太高的一个症状是高磁盘活动和低CPU活动的组合。）

对于文件排序不会使用的慢查询，尝试降低**max_length_for_sort_data**到一个合适触发一个文件排序的值。

如果想要增加**ORDER BY**的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试下面的策略：

* 增加**sort_buffer_size**变量的大小。

* 增加**read_rnd_buffer_size**变量的大小。

* 更改tmpdir指向具有大量空闲空间的专用文件系统。该选项接受几个使用round-robin(循环)模式的路径。在Unix中路径应用冒号(‘:’)区间开，在Windows、NetWare和OS/2中用分号(‘；’)。可以使用该特性将负载均分到几个目录中。注释：路径应为位于不同物理硬盘上的文件系统的目录，而不是同一硬盘的不同的分区。

如果没有索引用于**ORDER BY**，但出现**LIMIT**子句，优化器可能会避免使用合并文件和在内存排序行。具体参见[章节8.2.1.19，“优化LIMIT查询”][8.2.1.19]

#### 8.2.1.16.GROUP BY优化(#08.02.01.16)

满足GROUP BY子句的最一般的方法是扫描整个表并创建一个新的临时表，表中每个组的所有行应为连续的，然后使用该临时表来找到组并应用累积函数(如果有)。在某些情况中，MySQL能够做得更好，通过索引访问而不用创建临时表。

为GROUP BY使用索引的最重要的前提条件是 所有GROUP BY列引用同一索引的属性，并且索引按顺序保存其关键字(例如，这是B-树索引，而不是HASH索引)。是否用索引访问来代替临时表的使用还取决于在查询中使用了哪部分索引、为该部分指定的条件，以及选择的累积函数。

有两种方法通过索引访问执行GROUP BY查询，如下面的章节所描述。在第1个方法中，组合操作结合所有范围判断式使用(如果有)。第2个方法首先执行范围扫描，然后组合结果元组。

在MySQL，**GROUP BY**被用于排序，所以服务器或者也会应用**ORDER BY**优化到分组。参见[章节8.2.1.15，“ORDER BY优化”][8.2.1.15]

##### 8.2.1.16.1.松散索引扫描

使用索引时最有效的途径是直接搜索组域。通过该访问方法，MySQL使用某些关键字排序的索引类型(例如，B-树)的属性。该属性允许使用 索引中的查找组而不需要考虑满足所有**WHERE**条件的索引中的所有关键字。既然该访问方法只考虑索引中的关键字的一小部分，它被称为松散索引扫描。如果没有**WHERE**子句， 松散索引扫描读取的关键字数量与组数量一样多，可以比所有关键字数小得多。如果**WHERE**子句包含范围判断式(关于**range**联接类型的讨论参见[章节8.8.1，“用EXPLAIN优化查询”][8.8.1])， 松散索引扫描查找满足范围条件的每个组的第1个关键字，并且再次读取尽可能最少数量的关键字。在下面的条件下是可以的：

* 查询针对一个单表。

* **GROUP BY**名只有索引最左前缀形式的列而没有其他列(如果对于**GROUP BY**，查询有一个DISTINCT子句，则所有显式属性指向索引开头)。例如，一张表**t1**有一个索引在**（c1,c2,c3）**,如果查询有**GROUP BY(c1,c2)**,松散索引扫描会被应用。如果查询有**GROUP BY(c2,c3)**（列不是一个最左前缀）或者**GROUP BY(c1,c2，c4)**(**c4**不在索引里面)，它就不会被应用。

* 只使用累积函数(如果有)**MIN()**和**MAX()**，并且它们均指向相同的列。列必须在索引里面和跟随**GROUP BY**里的列。

* 索引的任何其它部分（除了那些来自查询中引用的GROUP BY）必须为常数(也就是说，必须按常量数量来引用它们)，但**MIN()**或**MAX()**函数的参数例外。

* 对于索引里的列，全列值必须被索引，而不仅仅是一个前缀。例如，**c1 VARCHAR(20),INDEX(c1(10))**,索引不能被用于松散索引扫描。
 
如果松散的索引扫描被应用于一个查询，**EXPLAIN**输出会在**Extra**列显示**Using index for group by**。

下面的查询提供该类的几个例子，假定表t1(c1,c2,c3,c4)有一个索引idx(c1，c2，c3)：

```sql

	SELECT c1, c2 FROM t1 GROUP BY c1, c2;
	
	SELECT DISTINCT c1, c2 FROM t1;
	
	SELECT c1, MIN(c2) FROM t1 GROUP BY c1;
	
	SELECT c1, c2 FROM t1 WHERE c1 < const GROUP BY c1, c2;
	
	SELECT MAX(c3), MIN(c3), c1, c2 FROM t1 WHERE c2 > const GROUP BY c1, c2;
	
	SELECT c2 FROM t1 WHERE c1 < const GROUP BY c1, c2;
	
	SELECT c1, c2 FROM t1 WHERE c3 = const GROUP BY c1, c2；

```
由于上述原因，不能用该快速选择方法执行下面的查询：

* 除了MIN()或MAX()，还有其它累积函数，例如：

```sql

     SELECT c1, SUM(c2) FROM t1 GROUP BY c1;
```

* GROUP BY子句中的域不引用索引开头，如下所示：

```sql

     SELECT c1,c2 FROM t1 GROUP BY c2, c3;

```

* 查询引用了GROUP BY部分后面的关键字的一部分，并且没有等于常量的等式，例如：

```sql

     SELECT c1,c3 FROM t1 GROUP BY c1, c2；
```

	如果查询包含了**WHERE c3 = const, 松散索引扫描可能会被用到。

松散索引扫描访问方法能被应用到在选择列表里参考的聚合函数的其他形式，除了**MIN()**和**MAX()**参考已经被支持：

* 支持**AVG(DISTINCT),SUM(DISTINCT)和COUNT(DISTINCT)**。**AVG(DISTINCT),SUM(DISTINCT)**带单一参数。COUNT(DISTINCT)能有超过一个列的参数。

* 子查询必须没有**GROUP BY**或**DISTINCT**子句。

* 松散扫描的早期限制依然适用。

假定表t1(c1,c2,c3,c4)有一个索引idx(c1，c2，c3)。松散索引扫描访问方法能用于接下来的查询：

```sql

	SELECT COUNT(DISTINCT c1), SUM(DISTINCT c1) FROM t1;

    SELECT COUNT(DISTINCT c1, c2), COUNT(DISTINCT c2, c1) FROM t1;

```

松散索引扫描不适用于接下来的查询：

```sql

    SELECT DISTINCT COUNT(DISTINCT c1) FROM t1;

    SELECT COUNT(DISTINCT c1) FROM t1 GROUP BY c1;

```

##### 8.2.1.16.2.紧凑索引扫描

紧凑式索引扫描可以为索引扫描或一个范围索引扫描，取决于查询条件。

如果不满足松散索引扫描条件，GROUP BY查询仍然可以不用创建临时表。如果WHERE子句中有范围条件，该方法只读取满足这些条件的关键字。否则，进行索引扫描。该方法读取由WHERE子句定义的每个范围的所有关键字，或没有范围条件式扫描整个索引，我们将它定义为紧凑式索引扫描。对于紧凑式索引扫描，只有找到了满足范围条件的所有关键字后才进行组合操作。

要想让该方法工作，对于引用GROUP BY关键字元素的前面、中间关键字元素的查询中的所有列，有一个常量等式条件即足够了。等式条件中的常量填充了搜索关键字中的“差距”，可以形成完整的索引前缀。这些索引前缀可以用于索引查找。如果需要排序GROUP BY结果，并且能够形成索引前缀的搜索关键字，MySQL还可以避免额外的排序操作，因为使用有顺序的索引的前缀进行搜索已经按顺序检索到了所有关键字。

假定表t1(c1,c2,c3,c4)有一个索引idx(c1，c2，c3)。上述的第一种方法不适合下面的查询，但第2种索引访问方法可以工作：

* GROUP BY中有一个差距，但已经由条件c2 = 'a'覆盖。

```sql

     SELECT c1，c2，c3 FROM t1 WHERE c2 = 'a' GROUP BY c1，c3;

```

* GROUP BY不以关键字的第1个元素开始，但是有一个条件提供该元素的常量：

```sql

     SELECT c1，c2，c3 FROM t1 WHERE c1 = 'a' GROUP BY c2，c3;
	
```

#### 8.2.1.17.DISTINCT优化(#08.02.01.17)

在许多情况下结合**ORDER BY**的**DISTINCT**需要一个临时表。

请注意因为**DISTINCT**可能使用**GROUP BY**，要清楚MySQL如何使用所选定列的一部分的**ORDER BY**或**HAVING**子句中的列。参见[章节12.17.3，“MySQL的GROUP BY扩展”][12.17.3]。

在大多数情况下，**DISTINCT**子句可以视为**GROUP BY**的特殊情况。例如，下面的两个查询是等效的：

```sql

	SELECT DISTINCT c1, c2, c3 FROM t1 WHERE c1 > const;
	 
	SELECT c1, c2, c3 FROM t1 WHERE c1 > const GROUP BY c1, c2, c3;

```

由于这个等效性，适用于**GROUP BY**查询的优化也适用于有**DISTINCT**子句的查询。这样，关于**DISTINCT**查询的优化的更详细的情况，参见[章节8.2.1.16，“GROUP BY优化”][8.2.1.16]。

结合**LIMIT row_count**和**DISTINCT**后，MySQL发现唯一的**row_count**行后立即停止。

如果不使用查询中命名的所有表的列，MySQL发现第1个匹配后立即停止扫描未使用的表。在下面的情况中，假定t1在t2之前使用(可以用**EXPLAIN**检查)，发现**t2**中的第1行后，MySQL不再(为**t1**中的任何行)读**t2**：

```sql

	SELECT DISTINCT t1.a FROM t1, t2 where t1.a=t2.a;

```

#### 8.2.1.18.子查询优化(#08.02.01.18)

MySQL查询优化器有不同的策略可用于评估子查询。对于**IN**(或者**=ANY**)子查询，优化器有这些选择：

* 半连接

* 具体化

* **EXISTS**策略
* 
对于**NOT IN**(或者**<>ANY**)子查询，优化器有这些选择：

* 具体化

* **EXISTS**策略

接下来的章节提供了更多有关这些优化策略的信息。

##### 8.2.1.18.1.半连接转换优化子查询

从MySQL5.6.5开始，优化器使用了半连接策略来提高子查询的执行，正如本节所描述。

对于两张表的一个内连接，连接会从一张表多次返回一个行，因为该行多次匹配另一张表的行。但是对于一些问题，重要的是是否有匹配，而不是匹配的数目。假设有两张命名为**class**和**roster**的表，这两张表分别列出了一门课程的班级和班级登记表（在每一个班登记的学生）。要列出实际上有学生登记的班，可能用到这个连接：

```sql 
	
	SELECT class.class_num, class.class_name
	FROM class INNER JOIN roster
	WHRER class.class_num = roster.class_num;

```

但是，对于每一个有登记的学生，结果会列出每一个班一次。对于被问及的问题，是不需要重复的信息。

假设**class_num**是**class**表的一个主键，通过使用**SELECT DISTINCT**可以抑制重复，但是首先生成所有匹配的行，再消除重复是非常低效的。

相同的重复不受约束的结果能通过这个查询获得：

```sql 
	
	SELECT class_num, class_name
	FROM class 
	WHRER class_num IN （SELECT class_num FROM roster）;

```

这里，优化器能识别出**IN**子句需要子查询从**roster**表只返回每一个班号码的一个实例。在这种情况，查询能被作为一个半连接执行。也就是说，返回的只有**class**每一行的一个实例的一个操作，这个操作被**roster**行匹配。

在MySQL5.6.5之前，外查询规格说明书被限制在简单表扫描或者使用了逗号语法的内连接之上，而且查看参照是不可能的。从MySQL5.6.6起，外连接和内连接语法在外查询规格说明书是允许的，表必须参照基本表的限制被移除。

在MySQL，子查询必须满足这些条件才会被作为半连接处理：

* 必须是一个**IN**（或**=ANY**）子句，而这个子句出现在**WHERE**或**ON**子句的顶部，可能作为一个**AND**表达式的术语。例如：

```sql

	SELECT ...

	FROM ot1, ...
	
	WHERE (oe1, ...) IN (SELECT ie1, ... FROM it1, ... WHERE ...);

```
	这里，**ot_i**和**it_i**代表查询的外部和内部部分的表，**oe_i**和**ie_i**代表参考外部和内部表的列的表达式。

* 必须是一个没有**UNION**结构的单一**SELECT**。

* 必须没有包含一个**GROUP BY**或**HAVING**子句或者聚集函数。

* 不能有带有**WITH**的**ORDER BY**。

* 外部表和内部表一起的数量必须少于被允许在一个连接的表的最大数目。

如果一个子查询满足前面的条件，MySQL会转换它成为一个半连接和从下面的策略作一个基于代价的选择：

* 将子查询转换成一个连接，或者使用表撤离和作为子查询和外部表之间的一个内连接运行查询。表撤离将表从一个子查询拉出到外查询。

* 去除重复：运行一个半连接就像它是一个连接和通过使用一个临时表去除重复的记录。

* 第一匹配：当为行组合扫描内部表和一个给定的值组有多个实例，会选择一个而不是返回全部。这种“捷径”扫描和消除非所需行的结果。

* 松散扫描：使用一个能使一个单值从每一个子查询的值组被选择成为可能的索引扫描子查询表。

* 将子查询具体化到一个带有索引的临时表，使用这个临时表来执行一个连接。这个索引是用来移除重复的。当临时表和外表连接时索引稍后也会被用于检查；如果没有，就会扫描全表。

以上的策略除了去除重复，其他都可以通过**optimizer_switch**系统变量控制可用或不可用。**semijoin**标志控制是否使用半连接，如果设置为**on**，**firstmatch**、**loosescan**和**materialization**标志可用于更好地控制允许的半连接策略。这些标志默认是**on**，参看[章节8.8.5.2，“控制可控制的优化”][8.8.5.2]

半连接的使用在**EXPLAIN**输出的表明如下：

* 半连接表显示在外select。**EXPLAIN EXTENDED**加**SHOW WARNINGS**显示了重写的查询，展示了半连接的结构。从这个你可以得出一个哪一张表从半连接取出的想法。如果一个子查询被转换为一个半连接，你可以看到这个查询消失了，它的表和**WHERE**子句被整合到外查询连接列表和**WHERE**子句。

* 用于去除重复的临时表通过**start temporary**和**End temporary**表明在**Extra**列。没有被取出和在**EXPLAIN**输出行范围内被**Start temporary**和**End temporary**覆盖的表在临时表有它们的**rowid**。

* **Extra**列的**FirstMatch（tb1_name）**表明了连接捷径。

* **Extra**列的**LooseScan（m..n）**表明了松散扫描策略的使用。**m**和**n**是关键字部分的编号。

* 从MySQL5.6.7开始，用于具体化的临时表是通过带有**MATERIALIZER**的一个**select_type**值和带有**<subqueryN>**的**table**值的行表明的。

  在MySQL5.6.7之前，如果一张单表使用了用于具体化的临时表通过**Extra**列表明，如果多表使用了则通过**Start materialize**和**End materialize**表明。如果出现了扫描，没有临时表索引用于表的读取。否则，一个索引检查是被使用了。

##### 8.2.1.18.2.用子查询实体化优化子查询

从MySQL5.6.5起，优化器使用子查询实体化作为一个使子查询更有效处理成为可能的策略。

如果没有使用实体化，优化器有时会重写一个不相关的子查询作为一个相关的子查询。例如，下面的**IN**子查询是不相关的（**where_condition**仅仅涉及**t2**的列，而没有**t1**）:

```sql

	SELECT * FROM t1
	WHERE t1.a IN (SELECT t2.b FROM t2 WHERE **where_condition**);

```

优化器可能会重写这个作为一个**EXISTS**相关的子查询：

```sql

	SELECT * FROM t1
	WHERE EXISTS (SELECT t2.b FROM t2 WHERE **where_condition** AND t1.a=t2.b);

```

子查询实体化使用一张临时表避免这样的重写和尽可能执行子查询一次而不是根据外部查询的行每行一次。实体化通过产生一个子查询结果集加速查询速度，一般这个产生在内存完成。当MySQL第一次需要子查询结果，它实体化结果到一张临时表。其他时间需要子查询结果时，MySQL会再次参考临时表。表被一个哈希索引编制索引令检查加快和花费降低。索引是唯一的，能令表更少，因为它没有重复。

子查询实体化可能的时候尝试使用一张在内存的临时表，如果表变得太大就会回落到在磁盘的存储。参考[章节8.4.3.3，“MySQL是怎样使用内部临时表的”][8.4.3.3]

要想在MySQL使用子查询实体化,**optimizer_switch**系统变量的**materialization**标志必须为**on**。然后实体化应用到出现在任何地方（在select列表，**WHERE,ON,GROUP BY,HAVING,或ORDER BY**）的子查询谓词，对于落入下面这些使用情况的谓词：

* 谓词这种形式，当没有外部表达式**oe_i**或内部表达式**ie_i**是可空的。**N**可以是1或者更大。

```sql

	(oe_1, oe_2, ..., oe_N) [NOT] IN (SELECT ie_1, i_2, ..., ie_N ...)

```

* 谓词这种形式，当有单一外表达式**oe**和内表达式**ie**。表达式可以为空。

```sql

	oe [NOT] IN (SELECT ie ...)

```

* 谓词是**IN**或**NOT IN**和一个**UNKNOWN(NULL)**的结果是同一个意思，结果就是**FALSE**。
	
下面的例子说明**UNKNOWN**和**FALSE**谓词评价的请求是怎样影响子查询实例化是否能被使用。假设**where_condition**涉及的行只是**t2**的，而不是**t1**，因此子查询是非相关的。

这个查询从属于实例化：

```sql

	SELECT * FROM t1

    WHERE t1.a IN (SELECT t2.b FROM t2 WHERE where_condition);

```

这类，**IN**谓词是否返回**UNKNOWN或FALSE**是没有关系的。不管怎样，**t1**的行是不会包含在查询结果。

一个子查询实体化没有使用的例子是接下来的查询，**t2.b**是一个可空的列。

```sql

	SELECT * FROM t1

    WHERE (t1.a,t1.b) NOT IN (SELECT t2.a,t2.b FROM t2

    WHERE where_condition);

```

对一个查询使用**EXPLAIN**能获得一些优化器是否使用了子查询实体化的指示。对比起没有使用子查询实体化的查询执行，**select_type**从**DEPENDENT SUBQUERY**改变为**SUBQUERY**。这就意味着，一个子查询对于每一个外部行会被执行一次，实体化使子查询仅仅被执行一次成为可能。另外，对于**EXPLAIN EXTENDED**,通过一个紧随的**SHOW WARNINGS**显示的文本会包含**materialize materialize** 和 **materialized-subquery** (MySQL 5.6.6之前是**materialized subselect**).

##### 8.2.1.18.3.在FROM子句（派生表）优化子查询

从MySQL5.6.3开始，优化器更有效地处理**FROM**子句（也就是派生表）的子查询：

* **FROM**子句的子查询实体化暂缓执行直到在查询执行中它们的内容是需要的时候，这样提高了性能：

	* 首先，**FROM**子句的子查询是实体化给**EXPLAIN SELECT**语句。这样导致**SELECT**的部分执行，即使**EXPLAIN**的目的是获得查询计划信息，不是执行查询。这个实体化不再出现，这样**EXPLAIN**对已这些查询就更快了。

    * 对于非**EXPLAIN**查询，实体化的延迟可能会导致它一点也不会执行。考虑一个连接**FROM**子句的子查询的结果到另一张表的查询：如果优化器先处理其他表和发现没有行返回，连接不需要进一步开展，优化器能完全忽略实体化子查询。
    
* 在查询执行期间，优化器可能会添加一个索引到一张派生表来加速它的行检索。

考虑接下来的**EXPLAIN**语句，一个子查询出现在一个**SELECT**查询的**FROM**子句：

```sql

	EXPLAIN SELECT * FROM (SELECT * FROM t1);

```

优化器通过延迟来避免实体化这个子查询直到在**SELECT**执行过程中需要子查询的结果。在这种情况，查询是不会执行的，所以永远不需要结果。

即使查询被执行，子查询实体化的延迟可能允许优化器避免完全地实体化。考虑下面的查询，这个查询连接**FROM**子句的子查询的结果到另一张表：

```sql

    SELECT * FROM t1

    JOIN (SELECT t2.f1 FROM t2) AS derived_t2 ON t1.f2=derived_t2.f1

    WHERE t1.f1 > 0;

```

如果优化先处理**t1**和**WHERE**子句产生一个空结果，连接必须是空和子查询不需要实体化。

最坏情况下（派生表被实体化），查询执行会花费和MySQL5.6.3之前相同的时间，因为没有额外的工作要做。最好的情况下（派生表没有实体化），查询执行等到需要执行实体化时将会更快。

对于**FROM**子句的子查询需要实体化的情况，优化器会为实体化的表添加一个索引来提高访问结果的速度。如果这样的一个索引能允许**ref**访问表，就能在查询执行期间减少大量必须被读取的数据。考虑如下查询：

```sql

	SELECT * FROM t1

    JOIN (SELECT * FROM t2) AS derived_t2 ON t1.f1=derived_t2.f1;

```

如果优化器如下操作则会允许使用**ref**访问来获取最低消耗的执行计划：在**derived_t2**的**f1**列构造一个索引。添加索引后，优化器就会将实体化的派生表和带有索引的普通表一样看待，它同样从形成的索引收益。对比起没有索引的查询执行花费，索引创建的花费是微不足道的。如果**ref**访问会导致比其他访问方法更高的开支，就不会创建索引和优化器也没什么损失。

##### 8.2.1.18.4.用**EXISTS**策略优化查询

特定的优化被用于使用**IN**操作符（或者使用**=ANY**，效果一样的）来测试子查询结果的比较。这一节讨论这些优化，特别关于有空值时变化。讨论的最后一部分包括了一些你可以做一些什么来帮助优化器。

考虑下面的查询比较：

```sql

	outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)


```

MySQL“从外到内”评估查询。也就是说，首先获得外部表达式**outer_expr**的值，然后运行子查询和获得它产生的行。

一个非常有用的优化是“通知”子查询仅仅感兴趣的行是这些内部表达式**inner_expr**等于**outer_expr**的行。通过叠加一个合适的等式到子查询的**WHERE**子句来完成。也就是说，上面那个比较转换成这样：

```sql

	EXISTS (SELECT 1 FROM ... WHERE subquery_where AND outer_expr=inner_expr)

```

转换结束后，MySQl能使用叠加的等式来限制当评估子查询时必须被检查的行的数量。

更一般地，**N**个值和返回**N**个值行的子查询的一个比较从属于相同的转换。**oe_i**和**ie_i**对应代表外部和内部表达式值，这个子查询比较：

```sql

	(oe_1, ..., oe_N) IN

    (SELECT ie_1, ..., ie_N FROM ... WHERE subquery_where)

```
变为：

```sql
  
    EXISTS (SELECT 1 FROM ... WHERE subquery_where

    AND oe_1 = ie_1

    AND ...

    AND oe_N = ie_N)

```
接下来的讨论假设简化一对外部和内部表达式值。

刚刚描述的转换有其局限性。只有我们忽略可能的NULL值，它才是合法的。也就是说，只有这两个条件都是true时，“叠加”策略才会工作：

* **outer_expr**和**inner_expr**不能为空。

* 你不需要从**FALSE**子查询结果区分出**NULL**。（如果子查询是**WHERE**子句里**OR**或**AND**表达式的一部分，MySQL假定你不在乎。）

当这些条件的二者之一或者全部都没拥有，优化是非常复杂的。

假设已经知道**outer_expr**非空，但子查询没有产生一行例如**outer_expr**=**inner_expr**。**outer_expr IN (SELECT ...)**评估如下：

* **NULL**,如果**inner_expr**是**NULL**，**SELECT**产生任何行。

* **FALSE**,如果**SELECT**产生非空值或没有产生东西。

这种情况，关于**outer_expr = inner_expr**查找行的方法不再合法。有必要查找这样的行，但是没有找到，也会查找**inner_expr**是**NULL**的行。大约说来，子查询会被转换成：

```sql

		EXISTS (SELECT 1 FROM ... WHERE subquery_where AND
	
	    (outer_expr=inner_expr OR inner_expr IS NULL))
	
	```
	
	评价额外的**IS NULL**条件的需要是为什么MySQL有**ref_or_null**访问方法：
	
	```sql
	
	mysql> EXPLAIN
	
	   -> SELECT outer_expr IN (SELECT t2.maybe_null_key
	
	   ->                       FROM t2, t3 WHERE ...)
	
	   -> FROM t1;
	
	*************************** 1. row ***************************
	
	    id: 1
	
	 select_type: PRIMARY
	
	    table: t1
	
	...
	
	*************************** 2. row ***************************
	
	    id: 2
	
	 select_type: DEPENDENT SUBQUERY
	
	    table: t2
	
	    type: ref_or_null
	
	possible_keys: maybe_null_key
	
	    key: maybe_null_key
	
	    key_len: 5
	
	    ref: func
	
	    rows: 2
	
	    Extra: Using where; Using index
	
	...
	
```

**unique_subquery**和**and index_subquery**子查询特定的访问方法也有“or **NULL**”变体。但是在**EXPLAIN**输出是不可见的，所以你必须使用**EXPLAIN EXTENDED**然后**SHOW WARNINGS**（注意警告信息的**checking NULL**）：

```sql

	mysql> EXPLAIN EXTENDED
	
	   -> SELECT outer_expr IN (SELECT maybe_null_key FROM t2) FROM t1\G
	
	*************************** 1. row ***************************
	
	    id: 1
	
	 select_type: PRIMARY
	
	    table: t1
	
	...
	
	*************************** 2. row ***************************
	
	    id: 2
	
	 select_type: DEPENDENT SUBQUERY
	
	    table: t2
	
	    type: index_subquery
	
	possible_keys: maybe_null_key
	
	    key: maybe_null_key
	
	    key_len: 5
	
	    ref: func
	
	    rows: 2
	
	    Extra: Using index
	
	mysql> SHOW WARNINGS\G
	
	    Optimizing SELECT Statements
	
	*************************** 1. row ***************************
	
	 Level: Note
	
	  Code: 1003
	
	Message: select (`test`.`t1`.`outer_expr`,
	
	    (((`test`.`t1`.`outer_expr`) in t2 on
	
	    maybe_null_key checking NULL))) AS `outer_expr IN (SELECT
	
	    maybe_null_key FROM t2)` from `test`.`t1`

```

附加条件**OR ... IS NULL**令查询执行变得稍微复杂（和一些优化在子查询里面变成不可用），但是这个是可容忍的。

当**out_expr**能为**NULL**时，情况可能更糟糕。根据**NULL**作为“不可预知值”的SQL解释，**NULL IN (SELECT inner_expre ...)**应该评估为：

**NULL**,如果**SELECT**产生任何行。

**FALSE**，如果**SELECT**没有产生行。

对于合适的评估，有能力检查**SELECT**是否产生任何行是必须的，所以**outer_expr = inner_expr**不能叠加到子查询。这是一个问题，因为很多现实世界的子查询变成非常慢，除非等式能被叠加。

本质上，根据**outer_expr**的值必须有不同的方法来执行子查询。

优化器选择SQL服从而不是速度，所以这就解释了**outer_expr**可能为**NULL**的可能性了

如果**outer_expr**是**NULL**，要评估接下来的表达式，运行**SELECT**来决定它是否产生任何行是必需的：

```sql

	NULL IN (SELECT inner_expr FROM ... WHERE subquery_where)

```

在这里需要运行原始的**SELECT**，不能有前面提到的叠加等式类型。

另一方面，当**outer_expr**不是**NULL**，这个比较：

```sql

	outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)

```

被转换成这个用了一个叠加条件的的表达式是绝对必要的：

```sql

	EXISTS (SELECT 1 FROM ... WHERE subquery_where AND outer_expr=inner_expr)

```

没有这个转换子查询将会很慢，要解决是否叠加条件到子查询的困惑，条件被包装在“触发”函数。因此，一下如下形式的表达式：

```sql

	outer_expr IN (SELECT inner_expr FROM ... WHERE subquery_where)

```

会被转换成：

```sql

	EXISTS (SELECT 1 FROM ... WHERE subquery_where

						    AND trigcond(outer_expr=inner_expr))

```

更一般地，如果子查询比较是建立在几对外部和内部表达式之上，转换和接受这个比较：

```sql

	(oe_1, ..., oe_N) IN (SELECT ie_1, ..., ie_N FROM ... WHERE subquery_where)

```

而且把它转换成这个表达式：

```sql

	EXISTS (SELECT 1 FROM ... WHERE subquery_where

    AND trigcond(oe_1=ie_1)

    AND ...

    AND trigcond(oe_N=ie_N)

    )

```

每个**trigcond(X)是一个用来评估下面值特定的函数：

* **X**，当“连接的”外部表达式**oe_i**不是**NULL**

* **TRUE**，当“连接的”外部表达式**oe_i**是**NULL**

注意，触发函数不是你用**CREATE TRIGGER**创建的触发器类型。

被包装到**trigcond(X)**函数的等式不是查询优化器的第一类谓词。绝大部分的优化不能处理那些在查询执行期间可以开启或者关闭的谓词，所以它们假设任何一个**trigcond（X）**是一个不知道的函数和忽略它。此时，触发等式能被这些优化使用：

* 参照优化：**trigcond(X=Y [OR Y IS NULL])**能用于**ref , eq_ref**, 或 **ref_or_null** 表访问。

* 索引查找基础的子查询执行引擎：**trigcond(X=Y)** 能被用于**constructunique_subquery**或**index_subquery**访问。

* 表条件产生器：如果子查询是一个多表的连接，会尽可能检查触发的条件。

当优化器使用一个触发的条件来创造不错的索引查找基础访问（关于前面提到的几点的开始两项），它必须为当条件关闭时的情况有一个回退策略。这个回退策略总是相同的：做一个全表扫描。在**EXPLAIN**输出，回退表现为**Extra**列的**Full scan on NULL key**:

```sql

mysql> EXPLAIN SELECT t1.col1,

   -> t1.col1 IN (SELECT t2.key1 FROM t2 WHERE t2.col2=t1.col2) FROM t1\G

*************************** 1. row ***************************
	
	    id: 1
	
	 select_type: PRIMARY
	
	    table: t1
	
	    ...
	
	*************************** 2. row ***************************
	
	    id: 2
	
	 select_type: DEPENDENT SUBQUERY
	
	    table: t2
	
	    type: index_subquery
	
	possible_keys: key1
	
	    key: key1
	
	    key_len: 5
	
	    ref: func
	
	    rows: 2
	
	    Extra: Using where; Full scan on NULL key

```

如果你运行**EXPLAIN EXTENDED**然后**SHOW WARNINGS**，你可以看到触发的条件：

```sql

	*************************** 1. row ***************************
	
	Level: Note
	
	Code: 1003
	
	Message: select `test`.`t1`.`col1` AS `col1`,

    <in_optimizer>(`test`.`t1`.`col1`,

    <exists>(<index_lookup>(<cache>(`test`.`t1`.`col1`) in t2

    on key1 checking NULL

    where (`test`.`t2`.`col2` = `test`.`t1`.`col2`) having

    trigcond(<is_not_null_test>(`test`.`t2`.`key1`))))) AS

    `t1.col1 IN (select t2.key1 from t2 where t2.col2=t1.col2)`

    from `test`.`t1`
	
```

触发条件的使用对性能有一些影响。一个**NULL IN (SELECT ...)**表达式之前没有执行过，现在可能引起全表扫描（这个会很慢）。这是为了正确结果的代价（触发条件策略的目标是来提高顺从性（compliance）而不是速度）。

对于多表的子查询，**NULL IN (SELECT ...)**的执行会特别慢，因为连接优化器没有为外部表达式是**NULL**的情况优化。它假设在左边为**NULL**的子查询评价是非常低概率的，虽然有统计表明并非如此。另一方面，如果外部表达式可能为**NULL**，但事实上从来不是，没有任何性能上的损失。

帮助查询优化器更好地执行你的查询，使用这些提示：

* 如果一个列事实上非空，声明它为**NOT NULL**。（这样通过为列简化条件测试也可以帮助优化器的其他方面。）

* 如果你不需要从一个**FALSE**子查询结果区分一个**NULL**，你可以简单地避免慢执行通路。用这个表达式：
	
	```sql 
	
		(**outer_expr** IS NOT NULL) AND (**outer_expr** IN (SELECT **inner_expr** FROM ...))
	
	```
	
	取代像下面的比较：
	
	```sql
	
		**outer_expr** IN (SELECT **inner_expr** FROM ...)
	
	```
	然后 **NULL IN (SELECT ...)**从不会被评估，因为MySQL停止评估**AND**部分只要表达式结果已经清晰。

**subquery_materialization_cost_based**使在子查询实体化和**IN->EXISTS**子查询转换之间选择成为可能。参见[章节8.8.5.2，“控制可转换的优化”][8.8.5.2]

####  8.2.1.19.优化 LIMIT 查询(#08.02.01.19)

如果你只需要从一个结果集的指定数目的行，在查询里使用一个**LIMIT**子句，而不是获取全部结果和丢掉额外的数据。

MySQL有时优化一个有**LIMIT row_count**子句和没有**HAVING**子句的查询：

* 如果你用**LIMIT**只选择一些行，当MySQL选择做完整的表扫描时，它将在一些情况下使用索引。

* 如果你使用**LIMIT row_count**与**ORDER BY**，MySQL一旦找到了排序结果的第一个**row_count**行，将结束排序而不是排序整个表。如果使用索引，将很快。如果必须进行文件排序（filesort），必须选择所有匹配查询没有**LIMIT**子句的行，并且在确定已经找到第1个**row_count**行前，必须对它们的大部分进行排序。在任何一种情况下，一旦找到了行，则不需要再排序结果的其它部分，并且MySQL不再进行排序。

* 当结合**LIMIT row_count**和**DISTINCT**时，MySQL一旦找到**row_count**个唯一的行，它将停止。

* 在一些情况下，**GROUP BY**能通过顺序读取键(或在键上做排序)来解决，然后计算摘要直到关键字的值改变。在这种情况下，**LIMIT row_count**将不计算任何不必要的**GROUP BY**值。

* 只要MySQL已经发送了需要的行数到客户，它将放弃查询，除非你正使用**SQL_CALC_FOUND_ROWS**。

* **LIMIT 0**将总是快速返回一个空集合。这对检查查询的有效性是有用的。当使用MySQL API时，它也可以用来得到结果列的列类型。(该技巧在MySQL Monitor中不工作，只显示**Empty set**；应使用**SHOW COLUMNS**或**DESCRIBE**）。 

* 当服务器使用临时表来进行查询时，使用**LIMIT row_count**子句来计算需要多少空间。

从MySQL5.6.2开始，优化器更有效地处理如下形式的查询（和子查询）：

```sql

	SELECT ... FROM single_table ... ORDER BY non_index_column [DESC] LIMIT [M,]N;

```

这种类型的查询和只从一个大结果集展示一些行的网站应用是共同。例如:

```sql

    SELECT col1, ... FROM t1 ... ORDER BY name LIMIT 10;

    SELECT col1, ... FROM t1 ... ORDER BY RAND() LIMIT 15;

```

排序缓冲区有一个**sort_buffer_size**的大小。如果对于**N**行的排序元素是足够小来装配到排序缓冲区（如果**M**是指定的，**M**+**N**行），服务器能避免使用一个合并文件和通过将排序缓冲区看成一个优先队列完全在内存执行排序：

* 扫描表，在队列里以排序的顺序插入每一个被选择的行的选择列表列。

* 从队列返回开始的**N**行。（如果**M**是指定的，跳过开始的**M**行和返回下一个**N**行。）

以前，服务器为排序通过使用合并文件来执行这个操作：

* 扫描表，重复这些操作直到通过表的底部：

  * 选择行直到排序缓冲区被填充满。

  * 将缓冲区开始的**N**行（**M**+**N**行如果**M**是指定的）写入一个合并文件。

* 排序合并文件和返回开始的**N**行。（如果**M**是指定的，跳过开始的**M**行和返回下一个**N**行。）

队列和合并文件方法的表扫描花费是相同的，所以优化器在他们之间选择是依据其他的花费：

* 队列方法涉及更多CPU用于顺序插入行到队列。

* 合并文件方法需要I/O花费来写和读文件和CPU花费来排序。

对于**N**值和行数量大小，优化器会在这些因素之间考虑平衡。

#### 8.2.1.20.怎样避免全表扫描(#08.02.01.20)

当MySQL使用一个全表扫描来解决一个查询时，**EXPLAIN**输出的**type**列显示**ALL**。这个通常发生在下面这些条件：

* 表太小以致执行表扫描比使用一个关键字查找更快。这对于少于10行和一个短行长度的表都是常见的。

* 对于索引列在**ON**或**WHERE**子句没有可用的限制。

* 用常量值和索引列比较，MySQL计算过（根据索引树）常量覆盖表太大的一部分，表扫描将会更快。查看[章节8.2.1.2,“MySQL怎样优化WHERE子句”][8.2.1.2]

* 你在使用一个低基数的键（很多行匹配这个键值）通过另一个列。在这种情况下，MySQL假设通过使用这个键可能做很多的关键字查找，一个表扫描将会更快。

对于小表，一个表扫描通常是适当的，而且性能影响可以忽略。对于大表，尝试下面的技术来避免令优化器错误地选择一个表扫描：

* 使用**ANALYZE TABLE tb1_name**来为扫描的表更新键分配。查看[章节13.7.2.1，“ANALYZE TABLE 语法”][13.7.2.1]

* 为扫描的表使用**FORCE INDEX**来告诉MySQL对比起使用给定的索引，表扫描时非常昂贵的：

```sql

	SELECT * FROM t1, t2 FORCE INDEX (index_for_column)

	WHERE t1.col_name=t2.col_name;

```

	查看[章节13.2.9.3,“索引提示语法”][13.2.9.3]

* 用**--max-seeks-for-key=1000**选项启动**mysqld**或者使用**SET max_seeks_for_key=1000**来告诉优化器假设没有键扫描会引起超过1000个键查找，查看[章节5.1.4，“服务器系统变量”][5.1.4]


[SELECT]:./docs/Chapter_13/13.02.09_SELECT_Syntax.md

[UNION]:./docs/Chapter_13/13.02.09_SELECT_Syntax.md#13.02.09.04

[index]:../gloaasry.md#index

[joins]:../gloaasry.md#joins

[foreign keys]:../gloaasry.md#foreign_keys

[EXPLAIN]:./docs/Chapter_13/13.08.02_EXPLAIN_Syntax.md

[8.3.1]:./docs/Chapter_08/08.03.01_How_MySQL_Uses_Indexes.md

[8.8.1]:./docs/Chapter_08/08.08.01_Optimizing_Queries_with_EXPLAIN.md

[full table scans]:../gloaasry.md#full_table_scans

[ANALYZE TABLE]:./docs/Chapter_13/13.07.02_Table_Maintenance_Statements.md#13.07.02.01

[8.5.5]:./docs/Chapter_08/08.05.05_Optimizing_InnoDB_Queries.md

[14.2.4.2.3]:./docs/Chapter_14/14.02.4_InnoDB_Performance_Tuning_and_Troubleshooting.md#14.02.4.2#14.02.4.2.03

[buffer pool]:../gloaasry.md#buffer_pool


[8.2.1.3.1]:


[range]:（958页码）

[index_merge]:（958页码）

[eq_range_index_dive_limit]:（494页码）

[NDB]:./docs/Chapter_17/17.00.00_MySQL_Cluster_NDB7.3.md

[12.5.1]:./docs/Chapter_12/12.05.01_String_Comparison_Functions.md

[11.4.3]:./docs/Chapter_11/11.04.03_The_BLOB_and_TEXT_Types.md

[8.8.5.2]:./docs/
Chapter_08/08.08.05_Controlling_the_Query_Optimizer.md#08.08.05.02

[InnoDB]:./docs/Chapter_14/14.02.00_The_InnoDB_Storage_Engine.md

[8.2.1.14]:./docs/Chapter_08/08.02.01_Optimizing_SELECT_Statements.md#08.02.01.14

[13.2.9.2]:./docs/Chapter_13/13.02.09_SELECT_Syntax.md#13.02.09.02

[covering index]:../gloaasry.md#covering_index



[8.2.1.18.1]:



[5.1.4]:./docs/05.01.04_Server_System_Variables.md

[14.4]:./docs/14.04.00_The_MEMORY_Storage_Engine.md

[8.2.1.19]:./docs/Chapter_08/08.02.01_Optimizing_SELECT_Statements.md#08.02.01.19

[8.2.1.15]:./docs/Chapter_08/08.02.01_Optimizing_SELECT_Statements.md#08.02.01.15

[12.17.3]:./docs/Chapter_12/12.17.03_MySQL_Extensions_to_GROUP_BY.md

[8.2.1.16]:./docs/Chapter_08/08.02.01_Optimizing_SELECT_Statements.md#08.02.01.16

[8.4.3.3]:./docs/Chapter_08/08.04.03_How_MySQL_Use_Internal_Temporary_Tables.md#08.04.03.03

[13.7.2.1]:./docs/Chapter_13/13.7.2_Table_Maintenance_Statements.md#13.7.2.1

[13.2.9.3]:./docs/Chapter_13/13.02.09_SELECT_Syntax.md#13.02.09.03




备注：1.在一张表进行COUNT(*)[1303][] 这里还没有连接，因为是关于页数连接的。
2.（例如COUNT(*)[1303][],MIN()[1305][]等）这里还没有连接，因为是关于页数连接的
3.#### 8.2.1.3.范围优化 下面的range还没有连接
4.dive未翻译
5.pushdown翻译成叠加？
6.**range**,**ref**,**eq_ref**和**ref_or_null**连接到    
  8.8.2.EXPALIN EXTENDED
7.optimizer_switch 连接到5.1.4.Server System Variables
