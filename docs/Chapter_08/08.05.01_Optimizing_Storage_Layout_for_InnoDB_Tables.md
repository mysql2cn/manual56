### 8.5.1  InnoDB存储层优化

* 一旦数据大小稳定或者某个表增加了10M到几百M的时候，用户就可以考虑使用**OPTIMIZE TABLE**语句重新组织表、压缩浪费空间。重新组织后的表在做全表扫描时，减少了磁盘I/O次数。当其他方法不可用，例如改进索引的使用率和优化应用程序代码，这是一个改善性能的直观方法。

    **OPTIMIZE TABLE**语句拷贝表数据并重建索引。优势在于索引内部数据紧密，减少了表空间和磁盘上碎片。这种优势因表而异。你可能会发现这并非对所有表效果显著，或者效果不断下降直到你再次使用OPTIMIZE TABLE。如果表很大或者重建索引不能在buffer pool中完成，操作会很慢。当向表中增加大量数据后运行OPTIMIZE TABLE命令会较过一段时间运行慢很多。
    
* 在**InnoDB**表中，一个长主键(长单列值或者多列组合值)浪费大量磁盘空间。一条记录的主键在所有二级索引中出现。(参考[Section 14.8.9, “Clustered and Secondary Indexes”](TODO))。如果你的主键值很大，那么创建一个**AUTO_INCRUMENT**列做为主键，或者使用**VARCHAR**的前缀做为索引而不是整个列做为索引。

* 使用[VARCHAR](TODO)类型而不是[CHAR](TODO)存储变长String或者有很多**NULL**值的列。一个[CHAR(N)](TODO)列总是占用N个字符存储数据，即使列长度小于N或者为null。小表能更好匹配buffer pool和减少磁盘IO。

     当使用compact行格式(缺省**InnoDB**格式)和变长的字符集，比如utf8或者sjis，[CHAR(N)](TODO)列占用可变数量的空间，但至少N字节。

* 针对大表，或者包含很多重复文本、数值数据，考虑使用**COMPRESSED**格式。减少将数据载入buffer pool的磁盘io或者全表扫描。在做决定之前，先估算使用**COMPRESSED**相对于**COMPACT**格式，能带来多少收益。
