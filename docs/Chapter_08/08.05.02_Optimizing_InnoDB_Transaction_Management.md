# 8.5.2  InnoDB事务管理优化

### 8.5.2  InnoDB事务管理优化

为InnoDB优化事务处理，找出事务功能的性能极限和服务器负载的均衡点。例如，应用程序在每秒提交上千次，以及每隔2-3小时提交一次这两种情况下，遇到的性能问题可能完全不同。

* MySQL缺省**AUTOCOMMIT=1**会在一个繁忙数据库服务器上限制性能。事实上，将相关的DML语句放在一个单一的事务中，通过设置**SET AUTOCOMMIT=0**或者使用**START TRANSACTION**，完成数据库所有修改后使用COMMIT语句。
   
    如果一个事务对数据库进行了修改，那么InnoDB每次事务提交必须刷新日志到磁盘。每次修改后提交(缺省的AUTOCOMMIT设置)，存储设备的IO吞吐量会成为数据库每秒可执行操作的潜在限制因素。
    
* 通常，包含单条SELECT语句的事务，打开AUTOCOMMIT参数有助于InnoDB存储引擎重新组织只读事务并且优化它们。参考[Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”](TODO)获取更多信息。

* 避免在插入、更新、删除大量记录后执行回滚操作。如果一个大事务降低了服务器性能，回滚会使问题更糟，可能会在原始执行时间上增加几倍。杀死数据库进程无助于解决问题，因为数据库启动时会重新执行回滚操作。

	为降低这种问题发生的几率：
	
	* 可以通过增加[buffer pool](TODO)大小从而所有的DML操作缓存在内存中而不需要写回到磁盘

	* 设置[innodb_change_buffering=all](TODO)不仅缓存插入操作同时还有更新、删除

	* 考虑在一个大DML中定期使用commit，可能会将单个删除或更新分解为多个语句，这种语句具有较小的数据集。

    为消除失控的回滚操作，增加buffer pool以使回滚操作在CPU的边界内执行，或者杀掉服务以参数innodb_force_recovery=3启动，这个参数的解释在[Section 14.18.1, “The InnoDB Recovery Process”.](TODO)。

    这个问题在MYSQL5.5及更高版本中被认为不是特别重要了，因为缺省设置innodb_change_buffering=all允许更新和删除操作在内存中完成，使它们第一次执行的时候更快，同样如果需要回滚也更快。确保使用这个参数在运行含有大量插入、更新、删除操作的长事务。

* 如果你能容忍系统崩溃时丢失部分最近提交的事务，你可以设置innodb_flush_log_at_trx_commit=0。innodb试图每秒刷新日志，尽管刷新也不保证。同样，设置innodb_support_xa=0，将减少同步硬盘数据和binary日志的磁盘刷新操作。

* 当数据被一个长时间运行的事务修改或者删除的时候，别的事务如果使用READ COMMITTED或者REPEATABLE READ隔离级别，并且尝试读取这些数据的话，需要花费更多的时间来重新构建旧的数据。

* 当一个长时间运行的事务修改表，这个表上其他事务的查询不能利用覆盖。通常可以使用二级索引检索所有的结果而不是在表中查询合适的值。

    当二级索引页的值**PAGE_MAX_TRX_ID**太新时，或者二级索引中的记录被标记为删除时，InnoDB可能需要聚簇索引查询记录。
