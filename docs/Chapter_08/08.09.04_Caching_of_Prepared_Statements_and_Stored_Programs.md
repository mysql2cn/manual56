#  8.9.4. Caching of Prepared Statements and Stored Programs

### 8.9.4. Caching of Prepared Statements and Stored Programs
对一个客户端的会话中执行多次的某些语句，服务器将查询语句转换为内部结构，然后缓存这个结构在执行时使用。缓存使服务器执行的更高效，因为它避免了在会话中需要重新转换语句的开销。转换和缓存对下面语句有效：

- Prepared 语句，包括在SQL层处理的（使用 [prepared](#)语句）和使用二进制客户端/服务器端协议（使用mysql\_stmt\_prepare() C API函数）。 max\_prepared\_stmt\_count [521]系统变量控制服务器端缓存的语句的总数。（Prepared 语句的总数包括所有会话）
- 存储程序（存储过程和函数、触发器和事件）。在这种情况下，服务器转换和缓存整个程序体。stored\_program\_cache [563]系统变量暗示服务器对每个会话缓存的存储程序的估算数。

服务器在每个会话的基础上维持Prepared 语句和存储程序的缓存。一个会话缓存的语句不能被其他会话访问。当回话结束，服务器丢弃缓存的所有语句。

当服务器使用缓存的内部使用结构，必须小心内部结构是否过期。一个对象可以通过语句修改元数据，使当前的对象定义和内部语句结构代表的定义不匹配。DDL语句修改元数据，例如create, drop, alter, rename, or truncate tables, or that analyze, optimize, or repair tables。表内容修改（比如，插入或更新）不会导致元数据修改，包括查询语句。

下面是问题描述。假设客户端准备下面的语句：

    PREPARE s1 FROM 'SELECT * FROM t1';

[SELECT *](#)扩展内部数据结构到表上所有列。如果表上列集被[ALTER TABLE](#)修改，Prepared 语句过期。如果服务器没有删除本次修改，服务器下次执行s1，Prepared 语句返回错误的结果。

为避免表或试图（与Prepared 语句相关）上元数据修改造成的问题，服务器删除这些变化，并且当下次执行时重新准备这些语句。那就是说，服务器重新解析语句，然后重建内部结构。当引用的表或视图从表定义缓存中刷新时也可能发生重新解析，或者暗示为缓存中的新条目分配空间，或者显示的调用[FLUSH TABLES](#)。

相似的，如果存储程序使用的对象发生改变，服务器在程序内部重新解析影响的语句。（MYSQL5.6.6之前，服务器不删除影响存储程序的元数据，因此这些修改可能造成不正确的结果或者错误。）

服务器同样删除在表达式中修改的元数据。这些可能用在指定的存储程序的语句中，例如DECLARE CURSOR或者流程控制语句比如IF，CASE 和 RETURN 。

为避免重新解析整个存储程序，服务器根据需要在程序内部重新解析受影响的语句或者表达式。例如：

- 假设表或视图的元数据修改了。程序内部对[SELECT *](#)的重解析仅发生在访问的表或视图上，[SELECT *](#)不访问的表或视图不解析。
- 当一个语句受到影响，如果可能服务器仅部分重解析。考虑下面的CASE语句：
      
        CASE case_expr 
          WHEN when_expr1 ... 
          WHEN when_expr2 ... 
          WHEN when_expr3 ... 

           ... 
          END CASE

如果一个元数据修改仅影响了WHEN when\_expr3，这个表达式重解析。case_expr和其他的WHEN表达式不会被重解析。

重解析使用缺省的数据库和SQL模式，事实上从原始的转到到内部格式。

服务器试图重解析三次。如果所有重解析失败一个错误发生。

重解析是自动的，或多或少，减少Prepared 语句和存储程序的性能。

对Prepared 语句，Com_stmt_reprepare [602]状态变量跟踪再处理数。