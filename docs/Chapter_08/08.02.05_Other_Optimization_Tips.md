### 8.2.5.其他优化提示

该节列出了提高查询速度的各种技巧：

* 使用持久的连接数据库以避免连接开销。如果不能使用持久的连接并且你正启动许多新的与数据库的连接，可能要更改thread_cache_size变量的值。参见[章节8.11.2节，“调节服务器参数”][8.11.2]。

* 总是检查所有查询确实使用已经在表中创建了的索引。在MySQL中，可以用EXPLAIN命令做到。参见[章节8.8.1节，“用EXPLAIN优化查询”][8.8.1]”。

* 尝试避免在频繁更新的表上执行复杂的SELECT查询，以避免与锁定表有关的由于读、写冲突发生的问题。

* **MyISAM**支持并发插入：如果一个表没有空的块在数据文件的中间，在有其他进程正在从表读数据的同时可以插入新行。如果这很重要，应考虑按照避免删除行的方式使用表。另一个可能性是在删除大量行后运行**OPTIMIZE TABLE**来为表整理磁盘碎片。这个行为是通过改变**concurrent_insert**变量来改变的。你可以强制附加新行（因此允许并发插入），甚至在删除行的表。参见[章节8.10.3，“并发插入”][8.10.3]

* 要修复任何**ARCHIVE**表可以发生的压缩问题，可以执行**OPTIMIZE TABLE**。参见[章节14.6，“ARCHIVE存储引擎”][14.6]。

* 如果你主要按**expr1，expr2，...**顺序检索行，使用**ALTER TABLE ... ORDER BY expr1, expr2, ...**。对表大量更改后使用该选项，可以获得更好的性能。

* 在一些情况下，使得基于来自其它表的列的信息引入一个“ 哈希”的列有意义。如果该列较短并且有合理的唯一值，它可以比在许多列上的一个大索引快些。在MySQL中，很容易使用这个额外列：

```sql
	
	SELECT * FROM tbl_name
	WHERE hash_col=MD5(CONCAT(col1,col2))
	AND col1='constant' AND col2='constant';

```

* 对于频繁更改的MyISAM表，应试图避免所有变长列(**VARCHAR**、**BLOB**和**TEXT**)。如果表包括单一的变长列则使用动态记录格式。参见[第14章，存储引擎][14]。

* 只是因为行太大，将一张表分割为不同的表一般没有什么用处。为了访问行，最大的性能冲击是磁盘搜索以找到行的第一个字节。在找到数据后，大多数新型磁盘对大多数应用程序来说足够快，能读入整个行。确实有必要分割的唯一情形是如果它是使用动态记录格式使之变为固定的记录大小的**MyISAM**表(见上述)，或如果你需要很频繁地扫描表而不需要大多数列。参见[第14章，存储引擎][14]。

* 如果你需要很经常地计算结果，例如基于来自很多行的信息的计数，引入一个新表并实时更新计数器可能更好一些。下面形式的更新会更快一些：

```sql

	UPDATE tbl_name SET count_col=count_col+1 WHERE key_col=constant;

```
	当你使用象MyISAM那样的只有表级锁定的MySQL存储引擎(多重读/单个写)时，这确实很重要。这也给大多数数据库较好的性能，因为行锁定管理器在这种情况下有较少的事情要做。

* 如果你需要从大的记录文件表中收集统计信息，使用总结性的表而不是扫描整个表。维护总结应该比尝试做“实时”统计要快些。当有变化时从日志重新生成新的总结表比改变运行的应用(取决于业务决策)要快得多。

* 如果可能，应该将报告分类为“实时”或“统计”，这里统计报告所需的数据仅仅基于从实际数据定期产生的总结表中产生。 
* 
* 充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减少MySQL需要做的语法分析从而提高插入速度。
 
* 在一些情况下，包装并存储数据到一个BLOB列中是很方便的。在这种情况下，必须在你的应用中增加额外的代码来打包/解包信息，但是这种方法可以在某些阶段节省很多访问。当有不符合行和列表结构的数据时，这很实用。
 
* 在一般情况下，尝试以非冗余方式(查看数据库理论中的第三正则形式)保存数据，但是为了获得更快的速度，可以复制信息或创建总结表。
	
* 存储过程或UDF(用户定义函数)对于一些任务可能是获得更好性能的一个好方法，详细信息参见[章节19.2，“存储程序和函数”][19.2]和[章节23.3，“为MySQL添加新函数”][23.3]。 

* 总是能通过在应用程序中缓存查询/答案并尝试同时执行很多插入/更新来提高性能。如果数据库支持锁定表(像MySQL)，这应该有助于确保索引缓存只在所有更新后刷新一次。还可以利用MySQL的查询缓存来获得类似的结果；[参见章节8.9.3，“MySQL查询高速缓冲”][08.09.03]。 

* 使用多行**INSERT**语句通过一个SQL命令来存储很多行(这是一种可移植技术)。 

* 使用**LOAD DATA INFILE**装载较大数量的数据。这比使用**INSERT**要快得多。 

* 使用**AUTO_INCREMENT**列构成唯一值。

* 当**MyISAM**使用动态表格式时，偶尔使用**OPTIMIZE TABLE**可以避免碎片。参见[章节14.3.3，“MyISAM表的存储格式”][14.3.3]。 

* 可能时使用**MEMORY**表以得到更快的速度。参见[章节14.4，“MEMORY 存储引擎”][14.4]。**MEMORY**表对于经常访问但不是很重要的数据很有用，例如为那些没有在浏览器启用cookies的用户最后展示的标语信息。会话在很多Web应用环境处理不稳定状态数据的另一种有效交互。

* 在Web服务器中，图象和其它二进制资产应该作为文件存储。也就是仅在数据库中存储的本文件的引用而不是文件本身。大多数Web服务器在缓存文件方面比数据库内容要好得多，因此使用文件一般要快得多

* 在不同表中具有相同信息的列应该被声明为相同数据类型，以致基于相应列的连接能更快。

* 保持列名简单。例如，在**customer**表中使用**name**而不是**customer_name**。为了使名字能移植到其它SQL服务器，应该使名字短于18个字符。 

* 如果确实需要很高的速度，应该研究一下不同SQL服务器支持的数据存储的低层接口！例如直接访问MySQL **MyISAM**存储引擎，比起使用SQL接口，速度可以提高2-5倍。为了能实现，数据必须与应用程序在同一台服务器上，并且通常只应该被一个进程访问(因为外部文件锁定确实很慢)。通过在MySQL服务器中引进低层**MyISAM**命令能消除以上问题(如果需要，这可能是获得更好性能的一个简单的方法)。通过精心设计数据库接口，应该能相当容易地支持这类优化。

* 如果正使用数字数据，在许多情况下，从一个数据库访问信息(使用实时连接)比访问一个文本文件快些。这是因为数据库中的信息比文本文件更紧凑，因此这将涉及更少的磁盘访问。还可以在应用程序中节省代码，因为不须分析文本文件来找出行和列的边界。

* 通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份时主服务器变慢，可以使用一个从服务器来备份。参见[第16章,MySQL中的复制][16]。

* 用**DELAY_KEY_WRITE=1**选项声明**MyISAM**表可以使索引更新更快，因为在表关闭之前它们不刷新到硬盘上。不利之处是当表打开时如果杀掉服务器，应确保用**--myisam-recover**选项运行服务器保证没有问题，或者在重启服务器之前运行**myisamchk**。(然而，即使在这种情况下，应通过使用**DELAY_KEY_WRITE**保证不丢失数据，因为关键字信息总是可以从数据行产生）。

* 当你想**SELECT**语句比插入语句更高优先级时，为支持非事务的表使用**INSERT LOW_PRIORITY**。

* 为支持非事务的表使用**SELECT HIGH_PRIORITY**来获得插队的检索。也就是说，尽管有另一个客户端在等待写，但**SELECT**也会执行。

  **LOW_PRIORITY**和**HIGH_PRIORITY**只为非事务的只使用表级锁的存储引擎有影响。


929

[8.11.2]:./docs/08.11.02_Tuning_Server_Parameters.md
[8.8.1]:./docs/08.08.01_Optimizing_Queries_with_EXPLAIN.md
[8.10.3]:./docs/08.10.03_Concurrent_Inserts.md

[14.6]:./docs/14.06.00_The_ARCHIVE_Storage_Engine.md
[14]:./docs/14.06.00_Storage_Engines.md
[19.2]:./docs/19.02.00_Using_Stored_Routines_Procedures_and_Functions.md

[23.3]:./docs/23.03.00_Adding_New_Functions_to_MySQL.md
[08.09.03]:./docs/08.09.03_The_MySQL_Query_Cache.md
[14.3.3]:./docs/14.03.03_MyISAM_Table_Storage_Formats.md

[14.4]:./docs/14.04.00_The_MEMORY_Storage_Engine.md
[16]:./docs/16.00.00_Replication.md