#  8.1优化概述 

## 8.1优化概述 

数据库性能在数据库层取决于若干因素，例如表，查询和配置设定。你需要尽量减少或优化这些功能的使用，因为他们会操作CPU和I/O。学习性能调优的过程，首先从软件层面的，高层次的规则和指导来学习，并且通过具体的执行时间来评估性能表现。当你成为一位专家，你会了解更多关于内部的原理，并且从CPU周期和I/O操作的粒度来进行性能测量和评估。

典型的用户的目标是用他们现有的软件和硬件配置获得最好的数据库性能。高级用户寻找机会来提高MySQL软件本身，或者开发他们自己的存储引擎和硬件应用到扩展MySQL生态系统。

### 数据库级别的优化

令一个数据库应用程序更快的最重要因素是它的基础设计：

* 表结构设计是否合理？特别是所有列是否有正确的数据类型，以及针对产品，是否所有的表都包含恰当的字段呢？例如，一些频繁执行更新的应用程序经常用到很多表中的少量列，而一些分析大量数据的应用程序经常用到少量表中的很多列。
 
* 正确的[索引](TODO)能适当地使查询高效？

* 你正在为每张表使用合适的存储引擎？所使用的存储引擎你都利用了它们的优势和特点？特别地，选择一个事务性的存储引擎,例如[InnoDB](TODO),还是一个非事务性的存储引擎,例如[MyISAM](MyISAM),对于性能和可扩展性将会是非常重要。 
   
>注意：
>
>在MySQL5.5或者更高的版本，InnoDB是所有新表默认的存储引擎。事实上，InnoDB的高级特性，通常能保证比简单的MyISAM表要做的更好，特别是在一个高负载的数据库。

* 每张表是否都使用了一个合适的行格式？这个选择也是取决于表所使用的存储引擎。特别地，压缩的表使用更少的的磁盘空间和因此需要更少的磁盘I/O去读和写数据。压缩对于各种类型工作量的InnoDB表和只读的MyISAM表都是有效的。
　　
* 应用程序是否使用了一个合适的[锁定策略](TODO)？例如，在可能的情况下通过允许共享访问以便数据库操作能并发执行，而在需要占用的时候请求排他性访问以便关键操作获得最高优先权。再次提醒，存储引擎的选择是十分重要的。[InnoDB](NONE)存储引擎处理绝大部分的锁定问题而和你无关，它允许更好的数据库并发性，并且能减少你调试自己代码的次数。

* 所有[memory areas used for caching](TODO)大小是否正确？也就是说，足够大来保存频繁访问的数据，但又不会太大以致它们超过物理内存的负荷并且引起分页。最重要的内存配置的是InnoDB buffer pool、MyISAM key cache和MySQL query cache。

#### Optimizing at the Hardware Level

随着数据库应用变得越来越复杂，每个数据库应用终究会到达硬件平台的瓶颈。一名DBA必须能估计是通过优化应用程序，还是重新配置服务器，或者是增加硬件资源的方式，来避免这些[bottlenecks](TODO)。系统瓶颈通常由以下这些典型的原因导致：

* 硬盘寻址。硬盘寻址来查询数据，通常需要一定的时间。现代磁盘的平均寻址时间通常少于10毫秒，所以理论上我们能在一秒内进行100次的寻址。对于新磁盘这个时间提高不大，而且很难为单独的表进行优化。优化搜索时间的方法是将数据分布在多个磁盘上。

* 磁盘读/写。当磁盘寻址成功后，需要对磁盘进行读写操作。现代磁盘的传输速率通常在10-20MB/s。这个优化相对容易，可以通过并行读取多个磁盘来进行。

* CPU时钟。当数据读入内存后，我们在处理之前首先要从中读取出来。处理相对于内存总量来说，比较大的表的时候，CPU时钟一般就是一个限制因素。但是对小表来说，这通常不是问题。

* 内存带宽。当CPU需要的数据在cpu cache中未命中，内存带宽就成为了一个瓶颈，这是绝大部分系统不常见的瓶颈，但应该意识到。

#### Balancing Portability and Performance

在一个可移植的MySQL程序里使用面向性能的SQL扩展，你可以在一个语句的/*!  */注释界定符里面隐藏MySQL特定的关键字。其他的SQL服务器忽略注释了的关键字。关于写注释的信息，请看[Section 9.6, “Comment Syntax”](9.6)。
