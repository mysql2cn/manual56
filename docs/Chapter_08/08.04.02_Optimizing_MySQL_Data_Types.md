#  8.4.2.优化MySQL数据类型

### 8.4.2.优化MySQL数据类型

#### 数字类型的优化

* 对于被描述为字符串或数字之一的唯一IDs或其他值，用数值列比字符串列要好。等价的字符串和数字相比，数字会占用更少的空间，并且相比字符串，数字处理起来更快，还会占用更少的内存。

* 如果你正在使用数字数据，在许多情况下从数据库（使用一个实时连接）访问信息比访问一个文本文件要快。这是因为数据库中的信息比文本文件更紧凑，因此这将涉及更少的磁盘访问。还可以在应用程序中节省代码，因为不须分析文本文件来找出行和列的边界。

#### 8.4.2.2 为字符和字符串类型优化

对于字符和字符串列，注意下面的指导方针：

* 如果你不需要特定语言的collation特性的时候，使用binary collation会更快的完成比较和排序操作。可以通过[BINARY](TODO)操作符在一个查询中声明。

* 不同列之间存在比较的时候，要把相关的列的字符集和collation都设置为相同的，这样可以在查询执行时，避免字符串转换的开销。

* 对于大小少于8KB的列值，使用二进制**VARCHAR**而不是**BLOB**。如果原始表没有包含任何**BLOB**列，**GROUP BY**和**ORDER BY**子句能产生临时表，而这些临时表能使用在**MEMORY**存储引擎。

* 如果一张表包含了字符串列，例如名字和地址，但很多查询没有检索这些列，最好把这些列拆分到单独的表中，当查询需要该列的时候，通过外键关联起来。当MySQL检索一个行的任何一个值，它会读取包含那一行所有列的数据块（和邻近的行）。保持每一行小，而且只有最常用的列，允许更多的行来放进每一个数据块。例如压缩会在大部分查询下减少占用更少的磁盘I/O和内存。

* 当你在**InnoDB**表使用一个随机生成的值作为主键，如果可能在它前面加一个升序的前缀，例如当前日期和时间。主键值被连续存储的时候，**InnnoDB**插入和获取他们会更快。

* 参见[8.4.2.1, “Optimizing for Numeric Data”](TODO)，其中说明了为何使用数字列，比使用等价的字符串列更合适。

#### 8.4.2.3 为BLOB类型优化

* 针对一个包含文本数据的大的blob字段，首先要考虑的是如何压缩他。但是当整个表在**InnoDB**或**MyISAM**中已经被压缩时，不要这样处理。

* 当一个表包含多个列时，建议不要使用**BLOB**类型的列，而是考虑把**BLOB**列拆分到别的表当中，并且在需要的时候通过join查询来获取。这样会减少查询时所占用的内存。

* 因为检索和显示一个BLOB值的性能需要可能非常不同于其他数据类型，你可以将BLOB-指定表放到一个不同的存储引擎或者甚至一个单独的数据库实例。例如，检索一个BLOB可能需要一个大的连续磁盘读取，传统的硬盘驱动比一个[SSD device][SSD device]更适合。

* 参考[8.4.2.2, “Optimizing for Character and String Types”](TODO)，其中说明了为什么一个二进制**VARCHAR**列有时比BLOB列更合适。

* 你可以为长字符串列创建一个hash列，并为hash列创建索引。在具体的查询中，可以通过比较hash列来代替对应的长字符串列的比较。（使用**MD5()**或**CRC32()**函数来产生哈希值。）因为对于不同的输入哈希函数能产生重复结果，你仍然包含一个**AND blob_column = long_string_value**到查询来防止错误的匹配；这样做的好处是，通过扫描更小的hash索引，带来的性能上的提升。

#### 8.4.2.4 使用PROCEDURE ANALYSE

```sql
	ANALYSE([max_elements[,max_memory]])
```

**ANALYSE()**检查一个查询的结果集，并返回分析结果。分析中包含对每个列最佳的数据类型的建议，这样可能帮助减少表的大小。要获得这个分析，附加**PROCEDURE ANALYSE**到一个**SELECT**语句的结尾：


```sql
	SELECT ... FROM ... WHERE ... PROCEDURE ANALYSE([max_elements,[max_memory]])
```

例如：

```
    SELECT col1, col2 FROM table1 PROCEDURE ANALYSE(10, 2000);
```

返回的结果中包含了查询结果的一些统计，同时还对列的数据类型给出了一些建议。在你检查已经存在的表，或者新导入一些数据的时候会提供一些帮助。你可能需要尝试设置不同的参数，以便**PROCEDURE ANALYSE()**不会错误的推荐[ENUM](TODO)数据类型。

参数是可选的，其说明如下：

* ***max_elements***（默认256）是**ANALYSE()**通知每个列的唯一值的最大值。这个被**ANALYSE()**用来检查最佳数据类型是否应该为**ENUM**类型；如果有超过**max_elements**唯一值，**ENUM**不是一个建议的类型。

* ***max_memory***（默认8192）是当尝试找到所有唯一值**ANALYSE()**为每个列分配的最大内存。

A PROCEDURE clause is not permitted in a UNION statement.

**PROCEDURE**子句在[UNION](TODO)语句中是不允许使用的。