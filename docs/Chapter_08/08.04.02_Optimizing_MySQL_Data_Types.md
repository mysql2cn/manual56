### 8.4.2.优化MySQL数据类型

#### [8.4.2.1.为数字数据优化](#08.04.02.01)

* 对于被描述为字符串或数字之一的唯一IDs或其他值，用数值列比字符串列要好。因为大的数字值比相应的字符串能被存储在更少的字节，将会更快和花费更少内存来转换和比较它们。

* 如果你正在使用数字数据，在许多情况下从数据库（使用一个实时连接）访问信息比访问一个文本文件要快。这是因为数据库中的信息比文本文件更紧凑，因此这将涉及更少的磁盘访问。还可以在应用程序中节省代码，因为不须分析文本文件来找出行和列的边界。

#### [8.4.2.2.为字符和字符串类型优化](#08.04.02.02)

对于字符和字符串列，注意下面的指导方针：

* 当你不需要语言指定的校对规则特点，为快速比较和排序操作使用二进制校对规则顺序。你可以在一个特殊的查询使用[BINARY][10.1.7.7]操作符来使用二进制校对规则。

* 当从不同的列比较值时，只要可能就声明这些列为相同的字符集和校对规则，来避免当运行查询时字符串的转换。

* 对于大小少于8KB的列值，使用二进制**VARCHAR**而不是**BLOB**。如果原始表没有包含任何**BLOB**列，**GROUP BY**和**ORDER BY**子句能产生临时表，而这些临时表能使用在**MEMORY**存储引擎。

* 如果一张表包含了字符串列，例如名字和地址，但很多查询没有检索这些列，当需要时考虑将这些字符串列分离到一张单独的表和使用带有外键的连接查询。当MySQL检索一个行的任何一个值，它会读取包含那一行所有列的数据块（和邻近的行）。保持每一行小，而且只有最常用的列，允许更多的行来放进每一个数据块。例如紧凑表为常见的查询减少磁盘I/O和内存使用。

* 当你在**InnoDB**表使用一个随机生成的值作为主键，如果可能在它前面加一个上升值的前缀例如当前日期和时间。当连贯的主键值被物理地互相存储相近，**InnoDB**能更快地插入和检索他们。

* 参见[章节8.4.2.1，“为数字数据优化”][8.4.2.1]的理由为什么一个数字列比一个相等的字符串列要好。

#### [8.4.2.3.为BLOB类型优化](#08.04.02.03)

当存储一个包含文本数据大的blob,首先考虑压缩它。当整个表被**InnoDB**或**MyISAM**压缩时，不要使用这个技术。

* 对于一张有若干列的表，为那些不需要使用BLOB列的查询减少内存需要，当需要的时候考虑分离BLOB列到一张单独的表和用一个连接参照它。

* 因为检索和显示一个BLOB值的性能需要可能非常不同于其他数据类型，你可以将BLOB-指定表放到一个不同的存储引擎或者甚至一个单独的数据库实例。例如，检索一个BLOB可能需要一个大的连续磁盘读取，传统的硬盘驱动比一个[SSD device][SSD device]更适合。

* 参考[章节8.4.2.2，“为字符和字符串类型优化”][8.4.2.2]的理由为什么一个二进制**VARCHAR**列有时比相等的BLOB列更可取。

* Rather than testing for equality against a very long text string，你可以存储一个列值的哈希在一个单独的列，索引那个列和在查询测试哈希的值。（使用**MD5()**或**CRC32()**函数来产生哈希值。）因为对于不同的输入哈希函数能产生重复结果，你仍然包含一个**AND blob_column = long_string_value**到查询来防止错误的匹配；性能收益来自为哈希值更小容易的扫描索引。

#### [8.4.2.4.使用**PROCEDURE ANALYSE**](#08.04.02.04)

```sql
	ANALYSE([max_elements[,max_memory]])
```

**ANALYSE()**检查一个查询的结果和返回结果的一个分析，分析为每个列建议最佳的数据类型，这样可能帮助减少表的大小。要获得这个分析，附加**PROCEDURE ANALYSE**到一个**SELECT**语句的结尾：

```sql
	SELECT ... FROM ... WHERE ... PROCEDURE ANALYSE([max_elements,[max_memory]])
```

例如：

```
    SELECT col1, col2 FROM table1 PROCEDURE ANALYSE(10, 2000);
```

结果为由查询返回的值展示一些统计，和为列建议一个最佳的数据类型。这将对你已经存在的表或者输入新数据后有用。你可能需要为不同的参数尝试不同的设置，以便**PROCEDURE ANALYSE()**不会建议**ENUM**数据类型当它不适当的时候。

参数是可选的和使用如下：

* **max_elements**（默认256）是**ANALYSE()**通知每个列的唯一值的最大值。这个被**ANALYSE()**用来检查最佳数据类型是否应该为**ENUM**类型；如果有超过**max_elements**唯一值，**ENUM**不是一个建议的类型。

* **max_memory**（默认8192）是当尝试找到所有唯一值**ANALYSE()**为每个列分配的最大内存。





[10.1.7.7]:./docs/10.01.07_Collation_Issues.md#10.01.07.07

[8.4.2.1]:./docs/08.04.02_Optimizing_MySQL_Data_Types.md#08.04.02.01

[SSD device]:./docs/术语表

[8.4.2.2]:./docs/08.04.02_Optimizing_MySQL_Data_Types.md#08.04.02.02




备注：
1.“Rather than testing for equality against a very long text string” 还没有翻译
2.术语表未链接