# 17.5.10.  MySQL集群信息库ndbinfo ###

### 17.5.10.  MySQL集群信息库ndbinfo ###

ndbinfo是存储包含MySQL集群的特定信息的数据库。
此数据库包含许多表，每一张表提供了集群节点状态，资源使用率，以及操作的不同排序数据信息，接下来的章节你将看到每一个表的更详细的信息：   
   
ndbinfo包含在MySQL服务器的MySQL集群支持，不需要特殊的编译或配置步骤，当它连接到MySQL集群的时候表已经通过MySQL服务器被创建了，在给定的MySQL服务实例中使用SHOW PLUGINS命令你可以验证ndbinfo支持是生效的，如果ndbinfo支撑是生效的，你应该可以看到在Name列中包含ndbinfo和在Status列中包含ACTIVE的一行记录，如下所示（着重文本）：  
 
	mysql> SHOW PLUGINS;
	+----------------------------------+--------+--------------------+---------+---------+
	| Name                             | Status | Type               | Library | License |
	+----------------------------------+--------+--------------------+---------+---------+
	| binlog                           | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| mysql_native_password            | ACTIVE | AUTHENTICATION     | NULL    | GPL     |
	| mysql_old_password               | ACTIVE | AUTHENTICATION     | NULL    | GPL     |
	| CSV                              | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| MEMORY                           | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| MRG_MYISAM                       | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| MyISAM                           | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| PERFORMANCE_SCHEMA               | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| BLACKHOLE                        | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| ARCHIVE                          | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| ndbcluster                       | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| ndbinfo                          | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| ndb_transid_mysql_connection_map | ACTIVE | INFORMATION SCHEMA | NULL    | GPL     |
	| InnoDB                           | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	| INNODB_TRX                       | ACTIVE | INFORMATION SCHEMA | NULL    | GPL     |
	| INNODB_LOCKS                     | ACTIVE | INFORMATION SCHEMA | NULL    | GPL     |
	| INNODB_LOCK_WAITS                | ACTIVE | INFORMATION SCHEMA | NULL    | GPL     |
	| INNODB_CMP                       | ACTIVE | INFORMATION SCHEMA | NULL    | GPL     |
	| INNODB_CMP_RESET                 | ACTIVE | INFORMATION SCHEMA | NULL    | GPL     |
	| INNODB_CMPMEM                    | ACTIVE | INFORMATION SCHEMA | NULL    | GPL     |
	| INNODB_CMPMEM_RESET              | ACTIVE | INFORMATION SCHEMA | NULL    | GPL     |
	| partition                        | ACTIVE | STORAGE ENGINE     | NULL    | GPL     |
	+----------------------------------+--------+--------------------+---------+---------+
	22 rows in set (0.00 sec)

你也可以在SHOW ENGINES[miaodian]的输出行上，找到Engine列中包含ndbinfo和Support列中包含YES的一行，如下所示：   

	mysql> SHOW ENGINES\G
	*************************** 1. row ***************************
	      Engine: ndbcluster
	     Support: YES
	     Comment: Clustered, fault-tolerant tables
	Transactions: YES
	          XA: NO
	  Savepoints: NO
	*************************** 2. row ***************************
	      Engine: MRG_MYISAM
	     Support: YES
	     Comment: Collection of identical MyISAM tables
	Transactions: NO
	          XA: NO
	  Savepoints: NO
	*************************** 3. row ***************************
	      Engine: ndbinfo
	     Support: YES
	     Comment: MySQL Cluster system information storage engine
	Transactions: NO
	          XA: NO
	  Savepoints: NO
	*************************** 4. row ***************************
	      Engine: CSV
	     Support: YES
	     Comment: CSV storage engine
	Transactions: NO
	          XA: NO
	  Savepoints: NO
	*************************** 5. row ***************************
	      Engine: MEMORY
	     Support: YES
	     Comment: Hash based, stored in memory, useful for temporary tables
	Transactions: NO
	          XA: NO
	  Savepoints: NO
	*************************** 6. row ***************************
	      Engine: FEDERATED
	     Support: NO
	     Comment: Federated MySQL storage engine
	Transactions: NULL
	          XA: NULL
	  Savepoints: NULL
	*************************** 7. row ***************************
	      Engine: ARCHIVE
	     Support: YES
	     Comment: Archive storage engine
	Transactions: NO
	          XA: NO
	  Savepoints: NO
	*************************** 8. row ***************************
	      Engine: InnoDB
	     Support: YES
	     Comment: Supports transactions, row-level locking, and foreign keys
	Transactions: YES
	          XA: YES
	  Savepoints: YES
	*************************** 9. row ***************************
	      Engine: MyISAM
	     Support: DEFAULT
	     Comment: Default engine as of MySQL 3.23 with great performance
	Transactions: NO
	          XA: NO
	  Savepoints: NO
	*************************** 10. row ***************************
	      Engine: BLACKHOLE
	     Support: YES
	     Comment: /dev/null storage engine (anything you write to it disappears)
	Transactions: NO
	          XA: NO
	  Savepoints: NO
	10 rows in set (0.00 sec)

如果ndbinfo支持生效，你可以在mysql[miaodian]或者其他MySQL客户端使用sql语句来访问ndbinfo，例如，你可以在SHOW DATABASES[miaodian]的输出中看到ndbinfo，如下所示：
   
	mysql> SHOW DATABASES;
	+--------------------+
	| Database           |
	+--------------------+
	| information_schema |
	| mysql              |
	| ndbinfo            |
	| test               |
	+--------------------+
	4 rows in set (0.00 sec)


如果mysqld进程没有使用--ndbcluster [miaodian]选项启动，ndbinfo将不是可用的，并且不会通过SHOW DATABASES[miaodian]显示出来。如果mysqld[miaodian]已经提前连接上了集群，但是集群变得不可用（由于集群关闭，网络失去连接，等等），ndbinfo以及ndbinfo下的表仍然保持可见，但是任何试图对表(除了块或者config_params)的访问都会失败，并报错"Got error 157 'Connection to NDB failed' from NDBINFO."   

除块和config_params表，我们称之为ndbinfo“表”的实际上都是从NDB内部产生的视图，对于MySQL服务器通常是不可见的。   

所有ndbinfo表是只读，当查询时并按需生成。因为当一些表是由给定的SQL节点生成的，而其他大部分都是通过数据节点并行生成的，它们是不能保证提供一个一致的快照。   

此外，在ndbinfo表里面，倒推的joins不支持，所以joining大表的时候需要往发请求的API节点传输大量的数据，即使查询的仅仅是一个WHERE字句。   

ndbinfo表不包含在查询缓存中(Bug #59831)   

当使用USE[miaodian]的时候你可以选择ndbinfo库，然后SHOW TABLES[miaodian]包含一系列表，跟别的库一样，如下所示：   

	mysql> USE ndbinfo;
	Database changed
	
	mysql> SHOW TABLES;
	+----------------------+
	| Tables_in_ndbinfo    |
	+----------------------+
	| blocks               |
	| cluster_operations   |
	| cluster_transactions |
	| config_params        |
	| counters             |
	| diskpagebuffer       |
	| logbuffers           |
	| logspaces            |
	| memoryusage          |
	| nodes                |
	| resources            |
	| server_operations    |
	| server_transactions  |
	| threadblocks         |
	| threadstat           |
	| transporters         |
	+----------------------+
	16 rows in set (0.04 sec)

你可以对这些表执行SELECT语句操作，就如同往常的预期：

	mysql> SELECT * FROM memoryusage;
	+---------+--------------+------+-------+
	| node_id | DATA_MEMORY  | used | max   |
	+---------+--------------+------+-------+
	|       1 | DATA_MEMORY  | 3230 |  6408 |
	|       2 | DATA_MEMORY  | 3230 |  6408 |
	|       1 | INDEX_MEMORY |   16 | 12832 |
	|       2 | INDEX_MEMORY |   16 | 12832 |
	+---------+--------------+------+-------+
	4 rows in set (0.37 sec)

更复杂的查询，如以下两个SELECT[miaodian]语句使用的MemoryUsage[miaodian]表，是可能的：   

	mysql> SELECT SUM(used) as 'Data Memory Used, All Nodes' 
	     >     FROM memoryusage 
	     >     WHERE DATA_MEMORY = 'DATA_MEMORY';
	+-----------------------------+
	| Data Memory Used, All Nodes |
	+-----------------------------+
	|                        6460 |
	+-----------------------------+
	1 row in set (0.37 sec)
	
	mysql> SELECT SUM(max) as 'Total IndexMemory Available' 
	     >     FROM memoryusage 
	     >     WHERE DATA_MEMORY = 'INDEX_MEMORY';
	+-----------------------------+
	| Total IndexMemory Available |
	+-----------------------------+
	|                       25664 |
	+-----------------------------+
	1 row in set (0.33 sec)

ndbinfo表名和列名是大小写敏感的（如同ndbinfo数据库本身的名称一样）。
这些标识符为小写。尝试使用错误的大小写导致一个错误，如图这个例子：   

	mysql> SELECT * FROM nodes;
	+---------+--------+---------+-------------+
	| node_id | uptime | status  | start_phase |
	+---------+--------+---------+-------------+
	|       1 |  13602 | STARTED |           0 |
	|       2 |     16 | STARTED |           0 |
	+---------+--------+---------+-------------+
	2 rows in set (0.04 sec)
	
	mysql> SELECT * FROM Nodes;
	ERROR 1146 (42S02): Table 'ndbinfo.Nodes' doesn't exist

mysqldump[miaodian]完全忽略了ndbinfo库，并且在任何输出中也排除了，即使你使用了--databases [miaodian]或者--all-databases [miaodian]选项。   

MySQL集群还保持了INFORMATION\_SCHEMA信息数据库的表，包括MySQL集群磁盘数据存储的使用情况的FILES[miaodian]表，有关详细信息，请参阅INFORMATION\_SCHEMA Tables for MySQL Cluster[miaodian]。   

#### 17.5.10.1. ndbinfo库的arbitrator\_validity\_detail表 ####

arbitrator\_validity\_detail表是一个视图在集群每一个数据节点的仲裁,它是membership[miaodian]表的子集.   
下述表格提供了关于arbitrator\_validity\_detail表的列的信息,关于每一个列,表显示了名称,数据类型,简短的描述,额外的信息可以在表的备注找到。    

<table border="1" cellspacing="0px"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row">node_id</td><td>integer</td><td>此节点的节点ID</td></tr><tr><td scope="row"><code class="literal">arbitrator</code></td><td>integer</td><td>仲裁节点ID</td></tr><tr><td scope="row"><code class="literal">arb_ticket</code></td><td>string</td><td>用来跟踪仲裁的内部标示</td></tr><tr><td scope="row"><code class="literal">arb_connected</code></td><td><code class="literal">Yes</code> or <code class="literal">No</code></td><td>节点是否已经连接到仲裁</td></tr><tr><td scope="row"><code class="literal">arb_state</code></td><td>Enumeration (see text)</td><td>仲裁状态</td></tr></tbody></table>   

节点id与ndb\_mgm -e "SHOW"报告中的一样。   

所有的节点都应该像arb\_state值一样显示arbitrator和arb\_ticket值。arb\_state可能的值有：ARBIT\_NULL, ARBIT\_INIT, ARBIT\_FIND,ARBIT_PREP1, ARBIT\_PREP2, ARBIT\_START, ARBIT\_RUN, ARBIT\_CHOOSE, ARBIT\_CRASH, 以及UNKNOWN.   

 arb\_connected显示当前节点是否连接到了仲裁者。   

#### 17.5.10.2. arbitrator\_validity\_summary表 ####
arbitrator\_validity\_summary表提供一个关于集群的数据节点的仲裁的综合视图。   

如下表格提供了关于arbitrator\_validity\_detail表的列的信息，对于每一个列，表格显示出了名称， 数据类型，简短的描述，额外的信息可以在表的备注找到。     

<table border="1" cellspacing="0px">
	<tr><td>列名称</td><td>类型</td><td>备注</td></tr>
	<tr><td>arbitrator</td><td>integer</td><td>仲裁者节点ID</td></tr>
	<tr><td>arb_ticket</td><td>string</td><td>用来跟踪仲裁的内部标示</td></tr>
	<tr><td>arb_connected</td><td>Yes or No</td><td>仲裁者是否已经连接到仲裁</td></tr>
	<tr><td>consensus_count</td><td>integer</td><td>能看到这个节点是仲裁者的数据节点的数目</td></tr>

</table>    

在正常操作中，该表只有1行有任何明显的时间长度。如果它有更多的
超过几分钟的1行记录，然后要么不是所有的节点都连接到仲裁员，或
所有节点已连接，但不处于同一仲裁者。   

arbitrator列显示了仲裁者节点ID   

arb_ticket列显示了仲裁者所使用的内部标识符   

arb_connected列显示了连接到集群的节点是否是作为一个仲裁者   

#### 17.5.10.3. blocks表 ####
   
blocks表是一张静态表，简单的包含名称和NDB内核的内部ID(看NDB Kernel Blocks[miaodian])，它是通过其他ndbinfo表(其中大多数真正是视图)在为了产生可读的输出而映射块数量到块名称来使用的。   

下表提供的是块表中的列的信息。对于每一列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。
<table border="1" cellspacing="0px">
	<tr><td>列名称</td><td>类型</td><td>备注</td></tr>
	<tr><td>block_number</td><td>integer</td><td>块数量</td></tr>
	<tr><td>block_name</td><td>string</td><td>块名称</td></tr>
</table>   

要获得所有块名称的列表，只需执行SELECT block\_name from ndbinfo.blocks语句。
虽然这是一个静态表，在不同的MySQL Cluster版本其内容会有所不同。 
  
#### 17.5.10.4. cluster_operations表 ####

以本地数据管理块(LQH)来看，cluster_operations表提供了每一个MySQL集群中的所有活动的操作视图的观点(请察看see The DBLQH Block)   

如下表格提供了关于cluster_operations表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以发现表的备注中发现。   
<table border="1" cellspacing="0px"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>生成LQH块报表的的节点ID</td></tr><tr><td scope="row"><code class="literal">block_instance</code></td><td>integer</td><td>LQH块实例</td></tr><tr><td scope="row"><code class="literal">transid</code></td><td>integer</td><td>事务ID</td></tr><tr><td scope="row"><code class="literal">operation_type</code></td><td>string</td><td>操作类型(参见关于值域内容)</td></tr><tr><td scope="row"><code class="literal">state</code></td><td>string</td><td>操作情形(参见关于值域内容)</td></tr><tr><td scope="row"><code class="literal">tableid</code></td><td>integer</td><td>表ID</td></tr><tr><td scope="row"><code class="literal">fragmentid</code></td><td>integer</td><td>片段ID</td></tr><tr><td scope="row"><code class="literal">client_node_id</code></td><td>integer</td><td>客户节点ID</td></tr><tr><td scope="row"><code class="literal">client_block_ref</code></td><td>integer</td><td>客户块参考</td></tr><tr><td scope="row"><code class="literal">tc_node_id</code></td><td>integer</td><td>事务协调器节点ID</td></tr><tr><td scope="row"><code class="literal">tc_block_no</code></td><td>integer</td><td>事务协调器块数量</td></tr><tr><td scope="row"><code class="literal">tc_block_instance</code></td><td>integer</td><td>事务协调器块实例</td></tr></tbody></table>

事务ID是通过NDB API的getTransactionId()[miaodian]方法获得的64位的唯一数字。(目前，当进行事务的时候MySQL服务器不暴露NDB API事务ID）。     

operation_type列取以下值之一：READ, READ-SH, READ-EX, INSERT,
UPDATE, DELETE, WRITE, UNLOCK, REFRESH, SCAN, SCAN-SH, SCAN-EX, 或者<unknown\>。   

state列取以下值之一：ABORT\_QUEUED, ABORT\_STOPPED,
COMMITTED, COMMIT\_QUEUED, COMMIT\_STOPPED, COPY\_CLOSE\_STOPPED,
COPY\_FIRST\_STOPPED, COPY\_STOPPED, COPY\_TUPKEY, IDLE, LOG\_ABORT\_QUEUED,
LOG\_COMMIT\_QUEUED, LOG\_COMMIT\_QUEUED\_WAIT\_SIGNAL, LOG\_COMMIT\_WRITTEN,
LOG\_COMMIT\_WRITTEN\_WAIT\_SIGNAL, LOG\_QUEUED, PREPARED, PREPARED\_RECEIVED\_COMMIT,
SCAN\_CHECK\_STOPPED, SCAN\_CLOSE\_STOPPED, SCAN\_FIRST\_STOPPED,
SCAN\_RELEASE\_STOPPED, SCAN\_STATE\_USED, SCAN\_STOPPED, SCAN\_TUPKEY, STOPPED,
TC\_NOT\_CONNECTED, WAIT\_ACC, WAIT\_ACC\_ABORT, WAIT\_AI\_AFTER\_ABORT, WAIT\_ATTR,
WAIT\_SCAN\_AI, WAIT\_TUP, WAIT\_TUPKEYINFO, WAIT\_TUP\_COMMIT, 或者 WAIT\_TUP\_TO\_ABORT。
(如果MySQL服务是使用ndbinfo\_show\_hidden [miaodian]生效启动的，你可以通过查询ndb$dblqh\_tcconnect\_state表来看到这个情形展示)   

你可以检查ndb\_show\_tables[miaodian]的输出结果中，获得表ID中的NDB名称。   

fragid跟ndb\_desc --extrapartition-info [miaodian]中看到的分区数目一样(通过-p排序)。   

   在client\_node_id和client\_block\_ref里面,client涉及到MySQL集群SQL节点或者API节点(即是，一个NDB API客户端或者附加到集群的MySQL服务)。   

#### 17.5.10.5. cluster\_transactions表 ####
cluster_transactions表展示了在MySQL集群中正在执行的事务信息。   

下述表显示了cluster_transactions表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。   
<table border="1" cellspacing="0px"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>事务协调器节点ID</td></tr><tr><td scope="row"><code class="literal">block_instance</code></td><td>integer</td><td>TC块实例</td></tr><tr><td scope="row"><code class="literal">transid</code></td><td>integer</td><td>事务ID</td></tr><tr><td scope="row"><code class="literal">state</code></td><td>string</td><td>操作情形 (参见值域内容)</td></tr><tr><td scope="row"><code class="literal">count_operations</code></td><td>integer</td><td>事务中主键操作的数量(如同DML操作，包含读锁)</td></tr><tr><td scope="row"><code class="literal">outstanding_operations</code></td><td>integer</td><td> 在局部数据管理块中事务仍然在被执行 </td></tr><tr><td scope="row"><code class="literal">inactive_seconds</code></td><td>integer</td><td>等待API所花费的时间</td></tr><tr><td scope="row"><code class="literal">client_node_id</code></td><td>integer</td><td>客户端节点ID</td></tr><tr><td scope="row"><code class="literal">client_block_ref</code></td><td>integer</td><td>客户端块参考</td></tr></tbody></table>


事务ID是通过NDB API的getTransactionId()[miaodian]方法获得的64位的唯一数字。(目前，当进行事务的时候MySQL服务器不暴露NDB API事务ID）。    


state列取以下值之一：ABORT\_QUEUED, ABORT\_STOPPED,
COMMITTED, COMMIT\_QUEUED, COMMIT\_STOPPED, COPY\_CLOSE\_STOPPED,
COPY\_FIRST\_STOPPED, COPY\_STOPPED, COPY\_TUPKEY, IDLE, LOG\_ABORT\_QUEUED,
LOG\_COMMIT\_QUEUED, LOG\_COMMIT\_QUEUED\_WAIT\_SIGNAL, LOG\_COMMIT\_WRITTEN,
LOG\_COMMIT\_WRITTEN\_WAIT\_SIGNAL, LOG\_QUEUED, PREPARED, PREPARED\_RECEIVED\_COMMIT,
SCAN\_CHECK\_STOPPED, SCAN\_CLOSE\_STOPPED, SCAN\_FIRST\_STOPPED,
SCAN\_RELEASE\_STOPPED, SCAN\_STATE\_USED, SCAN\_STOPPED, SCAN\_TUPKEY, STOPPED,
TC\_NOT\_CONNECTED, WAIT\_ACC, WAIT\_ACC\_ABORT, WAIT\_AI\_AFTER\_ABORT, WAIT\_ATTR,
WAIT\_SCAN\_AI, WAIT\_TUP, WAIT\_TUPKEYINFO, WAIT\_TUP\_COMMIT, 或者 WAIT\_TUP\_TO\_ABORT。
(如果MySQL服务是使用ndbinfo\_show\_hidden [miaodian]生效启动的，你可以通过查询ndb$dblqh\_tcconnect\_state表来看到这个情形展示)   

在In client\_node_id和client\_block\_ref里面,client涉及到MySQL集群SQL节点或者API节点(即是，一个NDB API客户端或者附加到集群的MySQL服务)。   

#### 17.5.10.6. config_params表 ####

config_params表提供了所有MySQL集群配置参数的名称和内部ID号码。   

下述表提供了关于config\_params表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。   

<table border="1" cellspacing="0px">
   <tr><td>列名称</td><td>类型</td><td>标注</td></tr>	
   <tr><td>param_number</td><td>integer</td><td>参数的内部ID号</td></tr>
   <tr><td>param_name</td><td>string</td><td>参数名称</td></tr>
</table>

尽管这是一个静态的表，他的内容在MySQL集群安装过程中可以改变，因为为了在软件版本，集群硬件配置，以及其他因素的不同，参数支持能被修改。   

#### 17.5.10.7. counters表 ####

counters表提供了正在运行的事件的数量，比如特定的内部块和数据节点的读写。计数器是保存在当前大多数启动的或者重启的节点；节点启动或者重启或重置节点上面的计数器。不是所有的内部块都有所有类型的计数器。   

下述表提供了关于counters表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。   

<table border="1" cellspacing="0px"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">Column Name</th><th scope="col">Type</th><th scope="col">Description</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>数据节点ID</td></tr><tr><td scope="row"><code class="literal">block_name</code></td><td>string</td><td>相关NDB内核块的名称 (参见NDB Kernel Blocks[miaodian]).</td></tr><tr><td scope="row"><code class="literal">block_instance</code></td><td>integer</td><td>块实例</td></tr><tr><td scope="row"><code class="literal">counter_id</code></td><td>integer</td><td>计数器的内部ID号，通常是在1和10之间的整数值，包含1和10。</td></tr><tr><td scope="row"><code class="literal">counter_name</code></td><td>string</td><td>计数器的名称，参与个别计数器和每一个计数器有关联的NDB内核块的名称内容 </td></tr><tr><td scope="row"><code class="literal">val</code></td><td>integer</td><td>计数器的值</td></tr></tbody></table>   

每一个计数器都与特定的NDB内核块相关联。   

OPERATIONS计数器与DBLQH(本地查询处理程序)内核块相关联(参见The DBLQH Block[miaodian])。

ATTRINFO, TRANSACTIONS, COMMITS, READS, SIMPLE\_READS, WRITES, ABORTS,
TABLE\_SCANS, 以及RANGE\_SCANS与DBTC(事务协调器)内核块相关联。(参见The DBTC Block[miaodian])   

LOCAL\_TABLE\_SCANS\_SENT, READS\_RECEIVED, PRUNED\_RANGE\_SCANS\_RECEIVED,
RANGE\_SCANS\_RECEIVED, LOCAL\_READS\_SENT, CONST\_PRUNED\_RANGE\_SCANS\_RECEIVED,
LOCAL\_RANGE\_SCANS\_SENT, REMOTE\_READS\_SENT, REMOTE\_RANGE\_SCANS\_SENT,
READS\_NOT\_FOUND, SCAN\_BATCHES\_RETURNED, TABLE\_SCANS\_RECEIVED, 以及
SCAN\_ROWS\_RETURNED计数器是与DBSPJ(查看push-down连接)内核块相关联，(参见The DBSPJ 块[miaodian])。   

在In client\_node_id和client\_block\_ref里面,client涉及到MySQL集群SQL节点或者API节点(即是，一个NDB API客户端或者附加到集群的MySQL服务)。   

大量计数器提供了当故障排除这类问题时候关于传输超量和发送缓冲大小的信息。对于每个LQH实例中，有一个实例中的每个计数器清单如下：   

• LQHKEY\_OVERLOAD: 由于传输超量在LQH实例中主键请求被拒绝的数量。    

• LQHKEY\_OVERLOAD\_TC:当TC节点传输超量的时候LQHKEY\_OVERLOAD实例的数量。  
 
• LQHKEY\_OVERLOAD_READER: 当API读节点(只读)超过负荷时LQHKEY\_OVERLOAD实例的数量。   

• LQHKEY\_OVERLOAD\_NODE\_PEER: 当下一个备份节点(只写)超过负荷时LQHKEY\_OVERLOAD实例的数量。   

• LQHKEY\_OVERLOAD\_SUBSCRIBER: 当一个事件用户(只写)超过负荷时LQHKEY_OVERLOAD的实例的数量。   

• LQHSCAN\_SLOWDOWNS: 由于扫描API传输超过负荷，片段扫描批量大小被减少的实例的数量。   

#### 17.5.10.8. diskpagebuffer表 ####

diskpagebuffer表提供了MySQL集群磁盘表中关于磁盘页缓存使用率的统计。   

下述表提供了关于diskpagebuffer表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。  

<table cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>The data node ID</td></tr><tr><td scope="row"><code class="literal">block_instance</code></td><td>integer</td><td>块实例</td></tr><tr><td scope="row"><code class="literal">pages_written</code></td><td>integer</td><td>往硬盘写的块的数量</td></tr><tr><td scope="row"><code class="literal">pages_written_lcp</code></td><td>integer</td><td>局部检查点写的页的数量。</td></tr><tr><td scope="row"><code class="literal">pages_read</code></td><td>integer</td><td>从磁盘读的页的数量。</td></tr><tr><td scope="row"><code class="literal">log_waits</code></td><td>integer</td><td>等待日志写入到磁盘的页的数量。</td></tr><tr><td scope="row"><code class="literal">page_requests_direct_return</code></td><td>integer</td><td>可用在缓存的页的请求数</td></tr><tr><td scope="row"><code class="literal">page_requests_wait_queue</code></td><td>integer</td><td>
 必须等待页在缓存中变得可用的请求数</td></tr><tr><td scope="row"><code class="literal">page_requests_wait_io</code></td><td>integer</td><td>必须从硬盘上面去读取的页的数量(页在缓存中不可用)。</td></tr></tbody></table>

对于MySQL磁盘数据表，比起从硬盘中读取，你可以使用这个表来决定DiskPageBufferMemory[miaodian]是否足够大到允许数据从缓存中读取，最大限度地减少磁盘寻道可以帮助提高这些表的性能。   

你可以决定从DiskPageBufferMemory的读取到从总内存量的读取之间的比例，使用如同这个获取查询比率的查询：   


	SELECT  
	  node_id, 
	  100 * page_requests_direct_return / 
	    (page_requests_direct_return + page_requests_wait_io) 
	      AS hit_ratio 
	FROM ndbinfo.diskpagebuffer;


   
查询结果如同下述显示的那样，集群中每一个节点一行记录(此例中，集群有4个数据节点)。

	+---------+-----------+
	| node_id | hit_ratio |
	+---------+-----------+
	|       5 |   97.6744 |
	|       6 |   97.6879 |
	|       7 |   98.1776 |
	|       8 |   98.1343 |
	+---------+-----------+
	4 rows in set (0.00 sec)

hit_ratio接近100%表明比起从缓存中读取只有非常小的一部分数据是从硬盘中读取的，这意味着磁盘数据读取性能接近的最佳水平。如果这些值的任何一个小于95%，这是一个很强的指标，表明在config.ini中DiskPageBufferMemory[miaodian]的配置需要增大。
>[备注]    
DiskPageBufferMemory [miaodian]的改动需要所有的集群数据节点重启才能生效。


#### 17.5.10.9. logbuffers表 ####

logbuffer提供了MySQL日志缓存使用率的信息。   


下述表提供了关于logbuffer表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。  

<table cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>这个数据节点的ID。</td></tr><tr><td scope="row"><code class="literal">log_type</code></td><td>string</td><td>日志类型，REDO或者DD-UNDO之一。</td></tr><tr><td scope="row"><code class="literal">log_id</code></td><td>integer</td><td>日志ID。</td></tr><tr><td scope="row"><code class="literal">log_part</code></td><td>integer</td><td>日志parat数量The log part number.</td></tr><tr><td scope="row"><code class="literal">total</code></td><td>integer</td><td>此日志的总共可用空间。</td></tr><tr><td scope="row"><code class="literal">used</code></td><td>integer</td><td>日志已经使用的空间。</td></tr></tbody></table>


#### 17.5.10.10. logspaces表 ####

logspaces表提供了MySQL集群中日志空间使用的信息。   

下述表提供了关于logspaces表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。   

<table cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>这个数据节点的ID。</td></tr><tr><td scope="row"><code class="literal">log_type</code></td><td>string</td><td>日志类型，REDO或者DD-UNDO之一。</td></tr><tr><td scope="row"><code class="literal">log_id</code></td><td>integer</td><td>日志ID。</td></tr><tr><td scope="row"><code class="literal">log_part</code></td><td>integer</td><td>日志parat数量The log part number.</td></tr><tr><td scope="row"><code class="literal">total</code></td><td>integer</td><td>此日志的总共可用空间。</td></tr><tr><td scope="row"><code class="literal">used</code></td><td>integer</td><td>日志已经使用的空间。</td></tr></tbody></table>

#### 17.5.10.11. membership表 ####

membership表描述了集群中每一个节点与其它所有节点的联系的展示，包括节点组成员关系，主节点，仲裁者，仲裁备用者，仲裁者连接情形，以及其它信息。   



下述表提供了关于membership表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。 

<table cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>这个节点的节点ID</td></tr><tr><td scope="row"><code class="literal">group_id</code></td><td>integer</td><td>此节点所属的节点组</td></tr><tr><td scope="row"><code class="literal">left node</code></td><td>integer</td><td>前一个节点的节点ID</td></tr><tr><td scope="row"><code class="literal">right_node</code></td><td>integer</td><td>下一个节点的节点ID</td></tr><tr><td scope="row"><code class="literal">president</code></td><td>integer</td><td>主节点ID</td></tr><tr><td scope="row"><code class="literal">successor</code></td><td>integer</td><td>成为主节点的节点ID</td></tr><tr><td scope="row"><code class="literal">succession_order</code></td><td>integer</td><td>为了让此节点成为主节点</td></tr><tr><td scope="row"><code class="literal">Conf_HB_order</code></td><td>integer</td><td>-</td></tr><tr><td scope="row"><code class="literal">arbitrator</code></td><td>integer</td><td>仲裁者节点ID</td></tr><tr><td scope="row"><code class="literal">arb_ticket</code></td><td>string</td><td>用来跟踪仲裁者的内部标识</td></tr><tr><td scope="row"><code class="literal">arb_state</code></td><td>Enumeration (参见内容)</td><td>仲裁者声明</td></tr><tr><td scope="row"><code class="literal">arb_connected</code></td><td><code class="literal">Yes</code> or <code class="literal">No</code></td><td>节点是否已经成功地连接到仲裁者</td></tr><tr><td scope="row"><code class="literal">connected_rank1_arbs</code></td><td>List of node IDs</td><td>等级 1的已经连接的仲裁者</td></tr><tr><td scope="row"><code class="literal">connected_rank2_arbs</code></td><td>List of node IDs</td><td>等级 2的已经连接的仲裁者</td></tr></tbody></table>   

节点ID和节点组ID是跟ndb_mgm -e "SHOW"[miaodian]报告中的一样的。  

left\_node和right\_node在依据将所有数据节点连成一个圆圈的模型中定义的， 模型节点ID的顺序，类似一个时钟拨的数字排序，如下所述：


![](http://dev.mysql.com/doc/refman/5.6/en/images/cluster-left-right.png)

在此例中，我们有8个节点，编号成5, 6, 7, 8, 12, 13, 14, 和 15，依照圆圈里顺时针方向排序，我们从圈内确定了“左”和“右”。节点5的左节点是节点15，节点5的右节点是节点6。通过运行下面的查询和观察输出，你可以看到所有这些关系：   


	mysql> SELECT node_id,left_node,right_node 
	    -> FROM ndbinfo.membership;
	+---------+-----------+------------+
	| node_id | left_node | right_node |
	+---------+-----------+------------+
	|       5 |        15 |          6 |
	|       6 |         5 |          7 |
	|       7 |         6 |          8 |
	|       8 |         7 |         12 |
	|      12 |         8 |         13 |
	|      13 |        12 |         14 |
	|      14 |        13 |         15 |
	|      15 |        14 |          5 |
	+---------+-----------+------------+
	8 rows in set (0.00 sec)

“左”和“右”也同样在事件日志中使用。   

主节点就是能把当前节点设定成一个仲裁者的节点（参见MySQL Cluster Start Phases[miaodian]）。如果主节点失败并且断开链接，当前节点希望将其ID是在备选主节点一栏的成为新的主节点。
succession\_order列显示了能够展示它自己本身的备选主节点序列的地方。   


在一个正常的MySQL集群里，所有的数据节点都能看到同一个节点作为主节点，并且同一个节点(主节点除外)作为备选主节点。此外，主节点在备选序列中它自己排在第一，备选主节点看到它自己排在第二，等等。   

如同一样arb\_state的值那样，所有的节点显示了相同的arb_ticket的值。arb_state的值域是：ARBIT\_NULL, ARBIT\_INIT, ARBIT\_FIND, ARBIT\_PREP1,
ARBIT\_PREP2, ARBIT\_START, ARBIT\_RUN, ARBIT\_CHOOSE, ARBIT\_CRASH, 以及UNKNOWN.   

arb_connected显示了此节点是否连接到了显示作为此节点仲裁者的节点上。   

connected\_rank1\_arbs和connected\_rank2\_arbs列描述了0或者多个拥有ArbitrationRank [2198]分别等于1或者2的值的仲裁者的列表。
>[备注]   
所有的管理节点和API节点都有资格成为仲裁者。

#### 17.5.10.12. memoryusage表 ####

查询这个表提供的信息，与通过在ndb_mgm[miaodian]客户端执行ALL REPORT MemoryUsage命令或者通过ALL DUMP 1000记录日志所提供的信息一样。   

下述表提供了关于memoryusage表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。    


<table cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>数据节点的节点ID</td></tr><tr><td scope="row"><code class="literal">memory_type</code></td><td>string</td><td><code class="literal">DATA_MEMORY</code>或者                <code class="literal">INDEX_MEMORY</code>其中之一。</td></tr><tr><td scope="row"><code class="literal">used</code></td><td>integer</td><td>通过此节点当前用于数据内存或者索引内存的字节数。</td></tr><tr><td scope="row"><code class="literal">used_pages</code></td><td>integer</td><td>通过此节点当前用于数据内存或者索引内存的页节数；参见正文。</td></tr><tr><td scope="row"><code class="literal">total</code></td><td>integer</td><td>此节点可用的数据内存或者索引内存的字节总数；参见正文。</td></tr><tr><td scope="row"><code class="literal">total_pages</code></td><td>integer</td><td>此节点可用的数据内存或者索引内存的页总数；参见正文。</td></tr></tbody></table>   

total列指示在一个给定资源(数据内存或者索引内存)的特定的数据节点上的可用总内存总数。这个数字应该与config.ini文件中的相应的配置参数设置的值大致是相等的。   

假如集群有2个拥有节点ID为1和2的数据节点，并且config.ini文件包含下述：

	[ndbd default]
	DataMemory = 100M
	IndexMemory = 100M

下述查询显示大致相同的值：

	mysql> SELECT node_id, memory_type, total 
	     > FROM ndbinfo.memoryusage;
	+---------+--------------+-----------+
	| node_id | memory_type  | total     |
	+---------+--------------+-----------+
	|       1 | Data memory  | 104857600 |
	|       1 | Index memory | 105119744 |
	|       2 | Data memory  | 104857600 |
	|       2 | Index memory | 105119744 |
	+---------+--------------+-----------+
	4 rows in set (0.30 sec)

在此列中，由于内部四舍五入，列中的索引内存总值略高于IndexMemory [2205][miaodian]
的值。   

对于used\_pages和total\_pages列，资源单位是页，DataMemory [2204][miaodian]的是32K以及IndexMemory [2205][miaodian]的是8K。

#### 17.5.10.13. nodes表 ####

此表中包含了数据节点的状态信息。对于每个在集群中运行的数据节点，在此表中的相应的行提供了节点的节点ID，状态和正常运行时间。对于正在开始的节点，这也显示了当前的启动阶段。   

下述表提供了关于nodes表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。   

<table cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>集群中数据节点的唯一节点ID</td></tr><tr><td scope="row"><code class="literal">uptime</code></td><td>integer</td><td>自动节点最后一次启动以来的时间，单位秒。</td></tr><tr><td scope="row"><code class="literal">status</code></td><td>string</td><td>数据节点当前的状态，参见正文的值域。</td></tr><tr><td scope="row"><code class="literal">start_phase</code></td><td>integer</td><td>如果数据节点正在启动，当前的启动阶段。</td></tr><tr><td scope="row"><code class="literal">config_generation</code></td><td>integer</td><td>此数据节点再用的集群配置文件的版本。</td></tr></tbody></table>

uptime列显示了此节点自从上次启动或者重启以来已经运行的以秒为单位的时间。这是BIGINT[miaodian]类型的值。这个数字包含实际需要启动此节点的时间，换而言之，在ndbd[miaodian]或者ndbmtd[miaodian]第一次被调用的那一刻计数器就已经开始运行计数了，因此即使对于一个还没有完成启动的节点，uptime都是一个非0的值。   

status列显示了节点当前的状态，这是NOTHING, CMVMI, STARTING,
STARTED, SINGLEUSER, STOPPING\_1, STOPPING\_2, STOPPING\_3, 或者STOPPING\_4其中之一。当状态是STARTING时，你可以在start\_phase列(参见下一章节)看到当前的启动阶段。当集群处于单用户模式时，你可以在start\_phase列看到当前的启动阶段(参见17.5.8章节，“MySQL Cluster Single User Mode”[miaodian])。看到STOPPING状态之一并不一定意味着节点正在关闭，但是能意味着它相当于进入一个新的情形；例如，如果你把集群进入单用户模式，有时你会看到数据节点在状态改变到SINGLEUSER之前它的报告简要会看到STOPPING_2。

start_phase列使用了与在ndb\_mgm[miaodian]客户端使用node\_id STATUS命令得到的输出一样的范围之内的值(参见17.5.2章节，“Commands in the MySQL Cluster Management Client”)[miaodian]。如果当前节点不是正在启动，那么此列会显示为0，关于MySQL集群启动节点的描述，参见17.5.1章节，“Summary of MySQL Cluster Start Phases”[miaodian].  
 
config_generation列显示哪个版本的群集配置是在每个数据节点的影响。当为了使在配置参数里的修改生效而执行集群滚动启动时，它是有用的。例如，从下述SELECT[miaodian]语句的输出结果中，尽管节点1，2以及4都使用了，但是节点3没有使用最新的集群配置(6)：

	mysql> USE ndbinfo;
	Database changed
	mysql> SELECT * FROM nodes;
	+---------+--------+---------+-------------+-------------------+
	| node_id | uptime | status  | start_phase | config_generation |
	+---------+--------+---------+-------------+-------------------+
	|       1 |  10462 | STARTED |           0 |                 6 |
	|       2 |  10460 | STARTED |           0 |                 6 |
	|       3 |  10457 | STARTED |           0 |                 5 |
	|       4 |  10455 | STARTED |           0 |                 6 |
	+---------+--------+---------+-------------+-------------------+
	2 rows in set (0.04 sec)



因此，对于刚才的例子，应该重启节点3来完成集群的滚动重启。   

已经被关闭的节点不会在这个表格中列出来，假设你有4个节点的MySQL集群(节点ID为1，2，3以及4)，并且所有的节点正常启动，然后每个节点都包含4行如下：


	mysql> USE ndbinfo;
	Database changed
	mysql> SELECT * FROM nodes;
	+---------+--------+---------+-------------+-------------------+
	| node_id | uptime | status  | start_phase | config_generation |
	+---------+--------+---------+-------------+-------------------+
	|       1 |  11776 | STARTED |           0 |                 6 |
	|       2 |  11774 | STARTED |           0 |                 6 |
	|       3 |  11771 | STARTED |           0 |                 6 |
	|       4 |  11769 | STARTED |           0 |                 6 |
	+---------+--------+---------+-------------+-------------------+
	4 rows in set (0.04 sec)

如果你关闭了节点中的一个，正在运行的节点会出现在SELECT[md]语句执行后的输出报告中，如下所示：  
 
	ndb_mgm> 2 STOP
	Node 2: Node shutdown initiated
	Node 2: Node shutdown completed.
	Node 2 has shutdown.
	mysql> SELECT * FROM nodes;
	+---------+--------+---------+-------------+-------------------+
	| node_id | uptime | status  | start_phase | config_generation |
	+---------+--------+---------+-------------+-------------------+
	|       1 |  11807 | STARTED |           0 |                 6 |
	|       3 |  11802 | STARTED |           0 |                 6 |
	|       4 |  11800 | STARTED |           0 |                 6 |
	+---------+--------+---------+-------------+-------------------+
	3 rows in set (0.02 sec)


#### 17.5.10.14. resources表 ####

此表提供了数据节点的可用以及已用信息。   

这些资源有时候会被称作super-pools。   

下述表提供了关于resources表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。  

<table cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>此数据节点的唯一节点ID。</td></tr><tr><td scope="row"><code class="literal">resource_name</code></td><td>string</td><td>资源名称; 参见正文。</td></tr><tr><td scope="row"><code class="literal">reserved</code></td><td>integer</td><td>资源的保留量。</td></tr><tr><td scope="row"><code class="literal">used</code></td><td>integer</td><td>资源实际使用的量。</td></tr><tr><td scope="row"><code class="literal">max</code></td><td>integer</td><td>自从节点最后一次启动，资源使用过的最大的量值。</td></tr></tbody></table>

resource_name是RESERVED, DISK\_OPERATIONS, DISK\_RECORDS,
DATA\_MEMORY, JOBBUFFER, FIL\E_BUFFERS,或者TRANSPORTER\_BUFFERS其中之一。   

#### 17.5.10.15. server_operations表 ####

server\_operations表包含当前SQL节点(MySQL服务器)有关的NDB操作的条目，它是cluster\_operations表的子集，不显示其他SQL或者API节点的操作。   

下述表提供了关于server\_operations表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。   

<table cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">mysql_connection_id</code></td><td>integer</td><td>MySQL服务器连接ID</td></tr><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>节点ID</td></tr><tr><td scope="row"><code class="literal">block_instance</code></td><td>integer</td><td>块实例</td></tr><tr><td scope="row"><code class="literal">transid</code></td><td>integer</td><td>事务ID</td></tr><tr><td scope="row"><code class="literal">operation_type</code></td><td>string</td><td>操作类型(参见正文值域)</td></tr><tr><td scope="row"><code class="literal">state</code></td><td>string</td><td>操作情形(参见正文值域)</td></tr><tr><td scope="row"><code class="literal">tableid</code></td><td>integer</td><td>表ID</td></tr><tr><td scope="row"><code class="literal">fragmentid</code></td><td>integer</td><td>片段ID</td></tr><tr><td scope="row"><code class="literal">client_node_id</code></td><td>integer</td><td>客户端节电ID</td></tr><tr><td scope="row"><code class="literal">client_block_ref</code></td><td>integer</td><td>客户端块参考</td></tr><tr><td scope="row"><code class="literal">tc_node_id</code></td><td>integer</td><td>事务协调器节点ID</td></tr><tr><td scope="row"><code class="literal">tc_block_no</code></td><td>integer</td><td>事务协调器块数</td></tr><tr><td scope="row"><code class="literal">tc_block_instance</code></td><td>integer</td><td>事务协调器块实例</td></tr></tbody></table>

mysql\_connection\_id是与SHOW PROCESSLIST[md]的输出结果中的connection或者session ID一样。它包含在INFORMATION\_SCHEMA库的NDB\_TRANSID\_MYSQL_CONNECTION\_MAP[md]表里。   

事务ID是通过NDB API的getTransactionId()[md]获取的64位唯一码。(目前，MySQL服务器不暴露正在进行中的NDB API交易的事务	ID)。   

列operation\_type有READ, READ-SH, READ-EX, INSERT,
UPDATE, DELETE, WRITE, UNLOCK, REFRESH, SCAN, SCAN-SH, SCAN-EX, 或者 <unknown\>其中之一的值。   

state列有ABORT\_QUEUED, ABORT\_STOPPED,
COMMITTED, COMMIT\_QUEUED, COMMIT\_STOPPED, COPY\_CLOSE\_STOPPED,
COPY\_FIRST\_STOPPED, COPY\_STOPPED, COPY\_TUPKEY, IDLE, LOG\_ABORT\_QUEUED,
LOG\_COMMIT\_QUEUED, LOG\_COMMIT\_QUEUED\_WAIT\_SIGNAL, LOG\_COMMIT\_WRITTEN,
LOG\_COMMIT\_WRITTEN\_WAIT\_SIGNAL, LOG\_QUEUED, PREPARED, PREPARED\_RECEIVED\_COMMIT,SCAN\_CHECK\_STOPPED, SCAN\_CLOSE\_STOPPED, SCAN\_FIRST\_STOPPED,
SCAN\_RELEASE\_STOPPED, SCAN\_STATE\_USED, SCAN\_STOPPED, SCAN\_TUPKEY, STOPPED,
TC\_NOT\_CONNECTED, WAIT\_ACC, WAIT\_client_block_ref, clientACC\_ABORT, WAIT\_AI\_AFTER\_ABORT, WAIT\_ATTR,
WAIT\_SCAN\_AI, WAIT\_TUP, WAIT\_TUPKEYINFO, WAIT\_TUP\_COMMIT, 或者 WAIT\_TUP\_TO\_ABORT其中之一的值。(如果MySQL服务器是使用ndbinfo\_show\_hidden [2312][md]启动的话，你可以通过通常不被隐藏的ndb$dblqh\_tcconnect\_state表的查询来看到这些列表。)   

你也可以从通过检查ndb_show_tables[md]表的输出结果获得的表ID获取NDB表的名称。   

fragid是跟ndb_desc --extrapartition-info [2361][md]的输出结果中看到的分区树木一样。   

在client\_node\_id和client\_block\_ref里面, 客户端即是MySQL集群API或者SQL节点(既是，一个NDB API客户端或者附加到集群的MySQL服务器)。

#### 17.5.10.16. server_transactions表 ####

server\_transactions表是cluster\_transactions表的一个子集。但是仅仅包含当前SQL节点(MySQL服务器)的这些事务，以及相关连接ID。   


下述表提供了关于server\_transactions表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。   

<table  cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">mysql_connection_id</code></td><td>integer</td><td>MySQL服务器连接ID</td></tr><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>事务协调器节点ID</td></tr><tr><td scope="row"><code class="literal">block_instance</code></td><td>integer</td><td>事务协调器块实例</td></tr><tr><td scope="row"><code class="literal">transid</code></td><td>integer</td><td>事务ID</td></tr><tr><td scope="row"><code class="literal">state</code></td><td>string</td><td>操作情形(参见正文值域)</td></tr><tr><td scope="row"><code class="literal">count_operations</code></td><td>integer</td><td>事务中状态操作的数目</td></tr><tr><td scope="row"><code class="literal">outstanding_operations</code></td><td>integer</td><td>仍然在执行的本地数据管理层(LQH块)</td></tr><tr><td scope="row"><code class="literal">inactive_seconds</code></td><td>integer</td><td>等待API所花费的时间</td></tr><tr><td scope="row"><code class="literal">client_node_id</code></td><td>integer</td><td>客户端节点ID</td></tr><tr><td scope="row"><code class="literal">client_block_ref</code></td><td>integer</td><td>客户端块参考</td></tr></tbody></table>    

mysql\_connection\_id是与SHOW PROCESSLIST[md]的输出结果中的connection或者session ID一样。它包含在INFORMATION\_SCHEMA库的NDB\_TRANSID\_MYSQL_CONNECTION\_MAP[md]表里。  

事务ID是通过NDB API的getTransactionId()[md]获取的64位唯一码。(目前，MySQL服务器不暴露正在进行中的NDB API交易的事务	ID)。

state列有
CS\_ABORTING, CS\_COMMITTING,
CS\_COMMIT\_SENT, CS\_COMPLETE\_SENT, CS\_COMPLETING, CS\_CONNECTED, CS\_DISCONNECTED,
CS\_FAIL\_ABORTED, CS\_FAIL\_ABORTING, CS\_FAIL\_COMMITTED, CS\_FAIL\_COMMITTING,
CS\_FAIL\_COMPLETED, CS\_FAIL\_PREPARED, CS\_PREPARE\_TO\_COMMIT, CS\_RECEIVING,
CS\_REC\_COMMITTING, CS\_RESTART, CS\_SEND\_FIRE\_TRIG\_REQ, CS\_STARTED,
CS\_START\_COMMITTING, CS\_START\_SCAN, CS\_WAIT\_ABORT\_CONF, CS\_WAIT\_COMMIT\_CONF,CS\_WAIT\_COMPLETE\_CONF, CS\_WAIT\_FIRE\_TRIG\_REQ.CS\_ABORTING, CS\_COMMITTING,
CS\_COMMIT\_SENT, CS\_COMPLETE\_SENT, CS\_COMPLETING, CS\_CONNECTED, CS\_DISCONNECTED,
CS\_FAIL\_ABORTED, CS\_FAIL\_ABORTING, CS\_FAIL\_COMMITTED, CS\_FAIL\_COMMITTING,
CS\_FAIL\_COMPLETED, CS\_FAIL\_PREPARED, CS\_PREPARE\_TO\_COMMIT, CS\_RECEIVING,
CS\_REC\_COMMITTING, CS\_RESTART, CS\_SEND\_FIRE\_TRIG\_REQ, CS\_STARTED,
CS\_START\_COMMITTING, CS\_START\_SCAN, CS\_WAIT\_ABORT\_CONF, CS\_WAIT\_COMMIT\_CONF,CS\_WAIT\_COMPLETE\_CONF, CS\_WAIT\_FIRE\_TRIG\_REQ其中之一。(如果MySQL服务器是使用ndbinfo\_show\_hidden [2312][md]启动的话，你可以通过通常不被隐藏的ndb$dbtc\_apiconnect\_state表的查询来看到这些列表。)   

在client\_node\_id和client\_block\_ref里面, 客户端即是MySQL集群API或者SQL节点(既是，一个NDB API客户端或者附加到集群的MySQL服务器)。   

#### 17.5.10.17. threadblocks表 ####


threadblocks表把数据节点，线程以及NDB内核块实例联系起来。   

下述表提供了关于threadblocks表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。 


<table cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>节点ID</td></tr><tr><td scope="row"><code class="literal">thr_no</code></td><td>integer</td><td>线程ID</td></tr><tr><td scope="row"><code class="literal">block_name</code></td><td>string</td><td>块名称</td></tr><tr><td scope="row"><code class="literal">block_instance</code></td><td>integer</td><td>块实例数目</td></tr></tbody></table>


block_name就是，当从ndbinfo.blocks表查询时在block_name列中找到的值其中之一，尽管对于一个给定的MySQL集群版本这个值域是静态的，但是不同的版本之间它是变化的。

#### 17.5.10.18. threadstat表 ####

threadstat提供一个在NDB内核线程运行的粗略的统计数据快照。  

下述表提供了关于threadstat表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。  

<table cellspacing="0px" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>节点ID</td></tr><tr><td scope="row"><code class="literal">thr_no</code></td><td>integer</td><td>线程ID</td></tr><tr><td scope="row"><code class="literal">thr_nm</code></td><td>string</td><td>线程名称</td></tr><tr><td scope="row"><code class="literal">c_loop</code></td><td>string</td><td>主循环中的循环数</td></tr><tr><td scope="row"><code class="literal">c_exec</code></td><td>string</td><td>执行的信号数</td></tr><tr><td scope="row"><code class="literal">c_wait</code></td><td>string</td><td>等待额外输入的次数</td></tr><tr><td scope="row"><code class="literal">c_l_sent_prioa</code></td><td>integer</td><td>发送到自己节点的A信号优先数</td></tr><tr><td scope="row"><code class="literal">c_l_sent_priob</code></td><td>integer</td><td>发送到自己节点的B信号优先数</td></tr><tr><td scope="row"><code class="literal">c_r_sent_prioa</code></td><td>integer</td><td>发送到远程节点的A信号优先数</td></tr><tr><td scope="row"><code class="literal">c_r_sent_priob</code></td><td>integer</td><td>发送到远程节点的B信号优先数</td></tr><tr><td scope="row"><code class="literal">os_tid</code></td><td>integer</td><td>OS线程ID</td></tr><tr><td scope="row"><code class="literal">os_now</code></td><td>integer</td><td>OS时间(ms)</td></tr><tr><td scope="row"><code class="literal">os_ru_utime</code></td><td>integer</td><td>OS用户CPU时间(µs)</td></tr><tr><td scope="row"><code class="literal">os_ru_stime</code></td><td>integer</td><td>OS系统CPU时间 (µs)</td></tr><tr><td scope="row"><code class="literal">os_ru_minflt</code></td><td>integer</td><td>OS页面回收（软件页面错误）</td></tr><tr><td scope="row"><code class="literal">os_ru_majflt</code></td><td>integer</td><td>OS页面错误（硬件页面错误）</td></tr><tr><td scope="row"><code class="literal">os_ru_nvcsw</code></td><td>integer</td><td>OS上下文自动切换</td></tr><tr><td scope="row"><code class="literal">os_ru_nivcsw</code></td><td>integer</td><td>OS上下文不自动切换</td></tr></tbody></table>

os\_time使用系统gettimeofday()调用。   

使用调用系统getrusage()的方法，都会得到os_ru_utime, os\_ru\_stime, os\_ru\_minflt, os\_ru\_majflt, os\_ru\_nvcsw,
and os\_ru\_nivcsw列的值。   

自从该表包含一个给定时间点的计数器，关于最佳的结果就是定期查询这个表并且把结果及时存储在中间表或者表上。可以采用MySQL事件调度器来做自动化监控，更多的信息，参见19.4章节， “Using the Event Scheduler”.[md]

#### 17.5.10.19. transporters表 ####

此表包含NDB传输的信息。

下述表提供了关于transporters表的列的信息，对于每一个列，表格显示了名称，数据类型和简要说明。更多信息，可以在表的备注中发现。 

<table cellspacing="0" border="1"><colgroup><col><col><col></colgroup><thead><tr><th scope="col">列名称</th><th scope="col">类型</th><th scope="col">描述</th></tr></thead><tbody><tr><td scope="row"><code class="literal">node_id</code></td><td>integer</td><td>此节点在集群中的唯一节点ID</td></tr><tr><td scope="row"><code class="literal">remote_node_id</code></td><td>integer</td><td>远程的数据节点的节点ID</td></tr><tr><td scope="row"><code class="literal">status</code></td><td>string</td><td>连接的状态</td></tr><tr><td scope="row"><code class="literal">remote_address</code></td><td>string</td><td>远程主机的名称或者IP地址</td></tr><tr><td scope="row"><code class="literal">bytes_sent</code></td><td>integer</td><td>使用此连接发送的字节数</td></tr><tr><td scope="row"><code class="literal">bytes_received</code></td><td> </td><td>使用此连接接受到的字节数</td></tr><tr><td scope="row"><code class="literal">connect_count</code></td><td> </td><td>在此传输器上建立连接的时间数</td></tr><tr><td scope="row"><code class="literal">overloaded</code></td><td> </td><td>如果传输器当前超负荷为1，否则为0</td></tr><tr><td scope="row"><code class="literal">overload_count</code></td><td> </td><td>自从连接以来传输器超负荷的时间数</td></tr><tr><td scope="row"><code class="literal">slowdown</code></td><td> </td><td>如果此传输器处于扫描放缓状态则为1，否则为0</td></tr><tr><td scope="row"><code class="literal">slowdown_count</code></td><td> </td><td>自从连接后进入扫描放缓状态传输器开始超负荷的时间数</td></tr></tbody></table>

对集群中每一个运行中的数据节点，transporters表显示了在集群中节点与所有的节点之间的联系状态，甚至包含此节点本身。此信息在表的status列中显示出来，有如下值之一：CONNECTING,
CONNECTED, DISCONNECTING, 或者 DISCONNECTED。已经配置过但是当前并没有连接到集群的API和管理器节点的连接，在状态DISCONNECTED展示出来，当前并未连接的node_id所在的行并不会在此表中展示出来。(这在ndbinfo.nodes表表中的断开的连接的类似的漏洞)   

remote\_address是在remote\_node\_id列中展示过ID的节点的主机名称或者地址。此节点的bytes\_sent和bytes\_received是分别使用已经建立好的连接的节点发送和接收的字节数。关于谁的状态是CONNECTING或者DISCONNECTED的节点，这些列通常显示为0。   

connect\_count, overloaded, overload\_count ,slowdown, 和 slowdown\_count计数器是在连接中重置，并且在远程节点断开连接后还能保持它们的值。bytes_send
和 bytes_received计数器也可以在连接中重置，在断开连接也可以保持它们的值(直道新的连接重置它们的值)。   

假如你有5节点的集群，包含2个数据节点，2个SQL节点，以及一个管理节点，在ndb_mgm[md]管理客户端执行SHOW命令的输出结果显示：

	ndb_mgm> SHOW
	Connected to Management Server at: localhost:1186
	Cluster Configuration
	---------------------
	[ndbd(NDB)]     2 node(s)
	id=1    @10.100.10.1  (5.6.14-ndb-7.3.4, Nodegroup: 0, Master)
	id=2    @10.100.10.2  (5.6.14-ndb-7.3.4, Nodegroup: 0)
	
	[ndb_mgmd(MGM)] 1 node(s)
	id=10   @10.100.10.10  (5.6.14-ndb-7.3.4)
	
	[mysqld(API)]   2 node(s)
	id=20   @10.100.10.20  (5.6.14-ndb-7.3.4)
	id=21   @10.100.10.21  (5.6.14-ndb-7.3.4)

在transporters表有10行--5第一是关于开始的数据节点，5第二是关于所有正在运行的数据节点，如下所示：   

	mysql> SELECT node_id, remote_node_id, status
	    ->   FROM ndbinfo.transporters;
	+---------+----------------+---------------+
	| node_id | remote_node_id | status        |
	+---------+----------------+---------------+
	|       1 |              1 | DISCONNECTED  |
	|       1 |              2 | CONNECTED     |
	|       1 |             10 | CONNECTED     |
	|       1 |             20 | CONNECTED     |
	|       1 |             21 | CONNECTED     |
	|       2 |              1 | CONNECTED     |
	|       2 |              2 | DISCONNECTED  |
	|       2 |             10 | CONNECTED     |
	|       2 |             20 | CONNECTED     |
	|       2 |             21 | CONNECTED     |
	+---------+----------------+---------------+
	10 rows in set (0.04 sec)


如果你在ndb_mgm客户端使用2 STOP命令在集群中关闭数据节点中一个节点，然后重做前一个查询操作(使用MySQL[md]客户端)，此表现在显示5行--1行是关于保持管理节点到另外一个节点的每一个连接，包含它自己以及当前离线的数据节点--并且保持每一个当前离线的其它数据节点状态为CONNECTING，如下所示：

	mysql> SELECT node_id, remote_node_id, status
	    ->   FROM ndbinfo.transporters;
	+---------+----------------+---------------+
	| node_id | remote_node_id | status        |
	+---------+----------------+---------------+
	|       1 |              1 | DISCONNECTED  |
	|       1 |              2 | CONNECTING    |
	|       1 |             10 | CONNECTED     |
	|       1 |             20 | CONNECTED     |
	|       1 |             21 | CONNECTED     |
	+---------+----------------+---------------+
	5 rows in set (0.02 sec)