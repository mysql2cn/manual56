# 5.4.4 `AUTO_INCREMENT` Handing in `InnoDB`

###5.4.4 `AUTO_INCREMENT` Handing in `InnoDB`
`InnoDB` 对于有`自增列`的表在插入数据时提供优化策略，显著提升可扩展性和SQL语句的执行性能。在`InnoDB`表中使用`AUTO_INCREMENT`算法，必须定义自增属性列`ai_col`为索引的一部分，这样可实现已索引的`SELECT MAX(ai_col)`查询语句以获得该列最大值。一般地，通过定义自增列为某个索引的第一列来实现。

本节提供了`InnoDB`中自增锁的实现原理的背景知识，解释了可配置的锁算法，算法参数的配置文档，以及在复制中的行为和交互方式。
####5.4.4.1 `InnoDB` 中传统自增锁

`InnoDB`原始的自增锁实现方式使用以下的策略来避免在语句模式下使用二进制日志进行复制或回滚场景出现的问题。

如果你为一个`InnoDB`表指定自增列，`InnoDB`数据字典中包含一个名为自增计数器的特殊的计数器来分配这一列的最新值。这个计数器存在在主内存中，不存储在磁盘上。

`InnoDB`使用下面的算法赖初始化自增计数器，如表`t`的自增列为`ai_col`:实例启动后，对于第一次t表的插入，`InnoDB`执行等同于下面语句的操作：
	
	SELECT MAX(ai_col) FROM t FOR UPDATE;

`InnoDB` 增加语句的返回值并分配给这列和自增计数器。默认情况下，该值每次增加1。默认值可以通过修改参数[auto_increment_increment][16.01.04.01]的值来改变。

如果表为空，`InnoDB`使用1作为初始值。初始值可以通过修改参数[auto_increment_offset][16.01.04.02]来改变。

如果在自增计数器初始化之前执行语句[SHOW TABLE STATUS][13.07.05.37]。`InnoDB`初始化自增值但不增加值，并未后续插入保留改值。初始化过程在表上使用排他的读锁，该锁持续到事务结束。

`InnoDB`对新建表的自增列初始化使用相同的过程。

`自增列`初始化完成后，如果你未对自增列指定值，`InnoDB`增加计数器的值并分配新的值给该列。如果你指定了该列值，并且指定值大于当前计数器的值，则计数器增加在指定值。
如果用户在[INSERT][13.02.05]操作中为自增列指定的值为`0`或`NULL`，`InnoDB`认为未指定值并分配新值。

自增算法未定义指定值为负值的情况以及指定值大于自增列存储的最大值。

访问自增计算器时，`InnoDB`使用特殊的表级`自增锁`，该锁持续到当前语句结束，而不是当前事务结束。这样的锁释放策略便于提升对包含自增列的表的并发写入能力。但是，2个事务不能同时拥有同一个表的`自增`锁，如果`自增`锁持续时间较长，则会造成性能问题。例如语句`INSERT INTO t1 ...SELECT ... FROM t2`这类将一个表所有列插入到另一个表。

`InnoDB`在实例运行过程中使用全内存计算器。当实例停止或重启，`InnoDB`在第一次插入事重新初始化每个表的计数器。

实例重启也会重置[CREATE TABLE][13.01.17] 和[ALTER TABLE][13.01.07] 语句中`AUTO_INCREMENT = N`的值，你可以用于修改或初始化InnoDB表自增计数器的值。

如果你回滚了已经使用计数器生成数值的事务，你会在`自增`列中发现间隙。

####5.4.4.2配置`InnoDB`自增锁
如前面章节描述，对于有`自增列`的表，`InnoDB`使用名为表级自增锁的特殊的锁来控制自增列的插入值。该锁持续到当前语句结束（而不是事务结束），从而保证自增列的分配值和预期一致，对于给定的[INSERT][13.02.05]操作实现可重复执行。

在语句模式的复制关系中，意味着一个SQL语句在从库执行，从库上分配为自增列分配和主库相同的值。多条插入语句的执行结果是确定的，从库重新产生和主库相同的数据。执行多个[INSERT][13.02.05]语句的结果是确定，从库会产生和主库一致的数据。如果多个[INSERT][13.02.05]语句产生的自增值是交错的，那2个并发插入的语句产生的结果是不确定的，也不能在语句模式下保证正确地复制到从库。

为了搞清楚这个问题，假设使用了下面的表：

	CREATE TABLE t1 (	c1 INT(11) NOT NULL AUTO_INCREMENT,  	c2 VARCHAR(10) DEFAULT NULL,  	PRIMARY KEY (c1)	) ENGINE=InnoDB;
假设此时并行运行2个插入`自增列`的事务。其中一个事务使用[INSERT ... SELECT][13.02.05.01] 语句插入1000行，另一个线程使用简单的[INSERT][13.02.05]语句插入一行：
	Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...	Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
在事务Tx1中，`InnoDB` 并不能提前知道[SELECT][13.02.09]子句将返回多少行，在语句开始执行时它便分配了自增值。在同一时间，只能有一个[INSERT][13.02.05]语句获取表t1的表级锁，知道语句执行结束，自增值在不同的语句直接不会产生交错。事务Tx1中[INSERT ... SELECT][13.02.05.01] 语句产生的自增值是连续的，而Tx2语句中使用的自增值将比Tx1最小值小或者大于最大值，取决于哪一个语句先执行。

只要在重做二进制日志过程中（语句模式复制或恢复脚本）SQL语句执行的顺序相同，产生的结果将和Tx1和Tx2第一次运行一样。所以，持有标级锁直到语句结束保证了在语句模式复制中对自增列进行[INSERT][13.02.05]语句时的可靠性。同时，这些（自增锁）也降低了在并发插入时的并发和可扩展能力。

在上面的例子中，如果没有表级锁，Tx2中使用的自增值取决于他执行时的自增锁的计数值。如果Tx2在Tx1运行过程中开始执行（不是在Tx1开始前或者已经结束），那么2个事务[INSERT][13.02.05]获取的自增值是不确定，运行过程中可能会产生异常。

如果[INSERT][13.02.05]语句插入的行数是已知的，对于这类事务`InnoDB`可以避免使用表级的自增锁，并且保证在语句模式的复制中准确安全地运行。另外，如果你不使用二进制日志进行恢复或者复制，你可以完全禁止自增锁的使用来获得更大的并发和性能，代价则是允许自增值中出现由事务间并发运行产生的间隙。

对于那些语句开始执行时就可确定插入的行数的[INSERT][13.02.05]语句，`InnoDB`开速地分配所请求的自增值并不加任何锁，但仅仅在此时没有其他的并发线程持有该表的自增锁（因为其他语句会在执行过程中持续的分配自增值知道结束）。更准确地说，这样的[INSERT][13.02.05]语句在没有互斥锁的情况下获取自增值，直到语句结束，但仅仅作用于分配的线程中。

这种锁模式带来了更好的扩展性能。和原始算法的自增值分配方式也存在一些细微的差别。为了描述自增值在InnoDB中的运行方式，下面定义了一些术语，解释了InnoDB在参数innodb_auoinc_lock_mode不同的设置时的不同行为，该参数可以在实例启动时配置。更多的注意事项在自增锁行为部分后面描述。

首先，一些定义：

* “[INSERT][13.02.05]-like” 语句

	所有在表中产生新数据行的数据，包括[INSERT][13.02.05],[INSERT ... SELECT][13.02.05.01],[REPLACE][13.02.08],[REPLACE ... SELECT][13.02.08]和[LOAD DATA][13.02.06]。

* 简单插入

	可以提前确定插入的数据行数的语句（在语句初始化运行时）。包含单行和多行的[INSERT][13.02.05]和[REPLACE][13.02.08],但不包含子查询。不包含[INSERT ... ON DUPLICATE KEY UPDATE][13.02.05.03]
	
* 批量插入

  无法提前确定插入的行数的语句（以及需要申请的自增值个数）。包含[INSERT ... SELECT][13.02.08],[REPLACE ... SELECT][13.02.08] 和[LOAD DATA][13.02.06]。`InnoDB`将在执行过程中一次在自增列分配一个值。

* 混合插入

  简单插入操作中对自增列分配了部分值的语句。下面的例子中，c1是表t1的自增列：
  
	INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
	
  另一类混合插入是[INSERT ... ON UPDATE KEY UPDATE][13.02.05.03],[INSERT][13.02.05] 后接着[UPDATE][13.02.11]是最糟糕的情况，自增列分配的值在更新的过程中不一定会被使用到。

参数[innodb_autoinc_lock_mode][14.02.06]有三种配置方式：

* `innodb_autoinc_lock_mode = 0 `(传统锁模式)
  
  这种锁模式提供参数[innodb_autoinc_lock_mode][14.02.06]出现之前一样的效果。对于所有的“[INSERT][13.02.05]”类语句，一个特殊的表级`AUTO-INC`锁将分配并持续到语句结束。这样可以保证分配表给指定语句的自增值是连续的。

  这中锁模式提供给：
  
  * 向后兼容性
  * 性能测试
  * 解决“混合模式插入”带来的问题，缘于后文介绍的差异。

* `innodb_autoinc_lock_mode = 1`("连续"锁模式)

  这是默认的锁模式。在这个模式下，“批量插入” 使用特别的表级`自增`锁并持续到语句结束。适用于所有的[INSERT ... SELECT][13.02.08],[REPLACE ... SELECT][13.02.08]和[LOAD DATA][13.02.06]语句。在同一时间只有持有自增锁的语句可以执行。

  在这种模式下，“简单的插入”操作使用一个新的锁模式，在`自增`值分配时持有轻量级的互斥锁，不会产生表级的`自增`锁，除非自增锁被另一个事务持有。如果有另一个事务持有`自增`锁，“简单插入”将等待`自增`锁，类似于“批量插入”场景。

  这种锁模式保证了一些不能提前预估其[插入][13.02.05]行数（和那些自增值是在语句运行中分配）的情况，分配给插入的自增值是连续的，且能正确的在语句模式下进行主从复制。

  简单说，这种锁模式的重要影响就是提供更好的可扩展性。在语句模式的复制可以安全运行。进一步说，在传统锁模式中，自增值连续地分配指定的语句。这种模式下，从语义上和传统模式对于使用自增值的语句来说没有改变，只有唯一的例外。

  这个例外就是“混合模式插入”，用户明确为以部门`自增列`指定了值，但不是全部。在这样的插入操作中，`InnoDB`将分配比插入的行数更多的自增值。所有自动分配的值由之前执行的语句生成的自增值连续生成。超出的部分会被丢弃。
  
 * `innodb_autoinc_lock_mode = 2 `("交叉"锁模式)
  
 	这种模式下，没有[插入][13.02.05]类语句会使用到表级`自增`锁，并发的语句可以同时执行。这是最快也是扩展性最高的模式，但它在基于语句模式的复制或者使用binlog进行数据恢复时不安全。
 	
 	这种模式下，自增值在所有并发[插入][13.02.05]类语句执行中唯一且单调递增，但是，由于并发线程可以同时生成自增值（也就是在线程之间交叉分配自增值），那么分配给语句中插入行的自增值可能就不是连续的。
 	
 	如果只有可提前知道插入行数的简单插入在执行，那么生成的自增值将是连续的，除混合插入之外。然而，当批量插入执行时，分配给相应语句的自增值中可能出现间隙。

[innodb_autoinc_lock_mode][14.02.06]提供的自增锁模式有以下几种使用场景:

* 复制中使用自增
	
	如果你使用基于语句的复制，在主库和从库将[innodb_autoinc_lock_mode][14.02.06]设置为0或1。如果[innodb_autoinc_lock_mode][14.02.06]的值设置为2或者主从的配置不一样，则可能导致主从的自增不一致。
	
	如果你使用行模式复制，所有的自增锁模式都是安全的。行模式复制并不关心语句的执行顺序。

* ’丢失‘自增值和队列间隙
	
	在所有的锁模式中（0，1和2），如果一个事务生成了自增值之后回滚了，这些自增值将被丢弃。自增值一旦被分配，就不能回滚，不管是[插入][13.02.05]语句是否执行完成，还是所属事务是否回滚。这些丢弃的值不会被重用，于是，一个表的`自增`列存储的值有可能出现间隙。

* 批量插入中自增值间隙

	[innodb_autoinc_lock_mode][14.02.06] 设置为0（传统模式）或者1（连续模式），分配给指定语句的自增值将是连续的，没有间隙，因为语句持有表级的`自增`锁知道语句执行结束，并且这样的语句同时只能运行一个。
	
	[innodb_autoinc_lock_mode][14.02.06]设置为2（交叉模式），批量插入操作可能导致自增值队列中产生间隙，但仅在发生并发的[插入][13.02.05]操作时。
 	
 	在模式1或者2时，连续执行的语句分配的自增值中可能出现间隙，因为批量中每个语句插入的具体行数是未知的，可能出现过高的估计。
* 混合模式下的自增值分配
	
对于一个混合模式的插入操作，也可看作一个简单的查询指定部分的自增值，而不是全部。这样的语句在不同的锁模式下表现也不一样。例如，假设`c1`是表`t1`中的`自增`列，而且最近一次自增队列的值为100.考虑下面的混合插入：
	
		INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');	
将[innodb_autoinc_lock_mode][14.02.06]设置为0（传统模式），新的4行数据为：
	
		+-----+------+ 
		| c1  | c2   | 
		+-----+------+ 
		| 1   | a    | 
		| 101 | b    | 
		| 5	  | c    | 
		| 102 | d    |
		+-----+------+	
由于自增值为每次分配一个，而不是在语句一开始就全部分配，所以下一个可用的自增值为103.不管是否是并发地执行[插入][13.02.05]语句，情况都是这样。
将[innodb_autoinc_lock_mode][14.02.06]设置为1（连续模式），新的4行数据为：
		+-----+------+ 		| c1  | c2   | 		+-----+------+ 		| 1   | a    |		| 101 | b    | 		| 5   | c    | 		| 102 | d    | 		+-----+------+
这种模式下，下一个可用的自增值为105而不是103，因为4个自增值在语句执行过程中分配了，但是只有2个使用。不管是否有并发的插入语句执行，情况都是这样。
将[innodb_autoinc_lock_mode][14.02.06]设置为2（交叉模式），新的4行数据为：
		+-----+------+ 		| c1  | c2   | 		+-----+------+		| 1   |a     |  		| x   |b     |		| 5   |c     |		| y   |d     |		+-----+------+
`x`和`y`的值将是唯一的，而且大于之前所有已经生成的数据行的自增值。但是，`x`和`y`的具体值取决于自增值分配时并发执行的语句数量。
最后，考虑下面的语句，当前最近的自增值为4：

		INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');不管[innodb_autoinc_lock_mode][14.02.06]的设置，这个语句将产生一个重复键的23000错误（`Can't write; duplicate key in table`），因为5会分配给行（`NUU,'b'`）,那么行（`5，‘c’`）的插入就会失败。[16.01.04.01]:(../Chapter_16/16.01.04_Replication_and_Binary_Logging_Options_and_Variables.md#auto_increment_increment)[16.01.04.02]:(../Chapter_16/16.01.04_Replication_and_Binary_Logging_Options_and_Variables.md#auto_increment_offset)
[14.02.06]:(../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#innodb_autoinc_lock_mode)[13.07.05.37]:(../Chapter_13/13.07.05_SHOW_Syntax.md#13.7.5.37)
[13.02.05]:(../Chapter_13/13.02.05_INSERT_Syntax.md)
[13.01.07]:(../Chapter_13/13.01.07_ALTER_TABLE_Syntax.md)
[13.01.17]:(../Chapter_13/13.01.17_CREATE_TABLE_Syntax.md)
[13.02.05.01]:(../Chapter_13/13.02.05_INSERT_Syntax.md#13.2.5.1)
[13.02.05.03]:(../Chapter_13/13.02.05_INSERT_Syntax.md#13.2.5.3)
[13.02.09]:(../Chapter_13/13.02.09_SELECT_Syntax.md)
[13.02.08]:(../Chapter_13/13.02.08_REPLACE_Syntax.md)
[13.02.06]:(../Chapter_13/13.02.06_LOAD_DATA_INFILE_Syntax.md)
[13.02.11]:(../Chapter_13/13.02.11_UPDATE_Syntax.md)

