5.2.4. 二进制日志
5.2.4.1. 二进制日志记录格式
5.2.4.2. 设置二进制日志记录格式
5.2.4.3. 混合的二进制日志记录格式
5.2.4.4. 对于mysql.*表操作的记录格式
二进制日志包含记录了诸如创建表或者是数据变更操作的各种“事件”。除非我们使用了基于行的记录，否则这些事件也会包含一些可能引起数据变更的语句（比如一个不匹配任何行的DELETE语句）。二进制日志还包含了每个变更数据语句的执行时间。概括起来，它有如下两个重要的作用：
用于复制。主库上的二进制日志提供了一份完整的对于数据进行变更的记录，它将被发往从库。主库把这些包含了事件的二进制日志发送到从库并在上面执行以确保主库和从库的数据完全一致。查看16.2节，“复制的实施”。
用于某些数据恢复操作。当一份备份被还原到数据库之后，二进制日志里面包含的从建立备份以来新增的事件就会被重新执行。这些事件可以帮助数据库从备份点恢复到当前时间。查看7.5节，“使用二进制日志进行基于时间点的恢复（增量）” 。
二进制日志不会被用来记录一些不变更数据的语句比如SELECT或者SHOW。如果想要记录所有的语句（比如，找出有错误的查询），可以使用全日志。查看5.2.3节，“全日志”。
在运行中的服务器上开启二进制日志会让性能稍微有所下降。但是，二进制日志的复制和恢复功能带来的收益远远大于性能的略微牺牲。
从MYSQL 5.6.2开始，二进制日志可以避免数据库宕机带来的数据丢失。因为只有完整的事件或事务才会被记录或者是读到。
对于MYSQL 5.6.3来说，当语句被写进二进制日志时，其中的密码会被重写成加密形式而不是原来的纯字母形式。但是MYSQL 5.6.3之前的版本，密码是不会被重写的，因此二进制日志应该被保护起来防止密码泄露。查看6.1.2.3节，“密码和二进制记录”。
下面的内容描述了一些能够影响到二进制记录行为的服务器选项和变量。如果想看一个完整的列表，查看16.1.4.4节，“二进制日志选项和变量”。
想要开启二进制日志，必须用--log-bin[=文件名]选项来启动服务器。如果文件名没有设置，那么默认名字就是pid-file选项的值(默认为主机名)+“-bin”。如果设置了文件名，那么服务器就会默认把二进制日志写到数据文件目录下，除非文件名含有和数据文件目录不同的绝对路径前缀。强烈建议设置一个文件名而不是使用默认的主机名；查看C.5.8节，“MYSQL已知事项”来获取原因。
如果你为二进制日志名设置了一个扩展名（比如，--log-bin=文件名.扩展名），那么扩展名会被自动移除。
为了不断生成二进制日志，mysqld进程自动为二进制日志文件名增加一个数字类型的扩展。每次服务器新产生一个二进制日志，这个数字就会自动增加，以此来创建一系列有序的文件。每当服务器启动或者执行flush logs命令都会产生一个新的二进制日志文件。当前的二进制日志文件大小达到max_binlog_size限制时，服务器也会自动创建一个新的二进制日志文件。但是当你使用很大的事务时，二进制日志文件也可能会超过max_binlog_size这个大小，因为一个事务只会一起写进同一个文件中，不会被分散到多个文件里。
为了记录哪些二进制日志被使用，mysqld进程也会创建一个包含所有被使用的二进制日志的索引文件。默认情况下， 它和二进制日志文件的文件基础名一样，但扩展名是‘.index’。你可以用--log-bin-index[=文件名]选项来改变这个索引文件的名字。记住，在mysqld进程运行时，不能手工编辑这个索引文件，否则会引起mysqld混乱。
通常所说的“二进制日志文件”是指一系列包含了数据库事件的有序文件，而所谓的“二进制日志”则是包含了上述文件以及二进制日志的索引文件。
具有SUPER权限的客户端可以通过SET sql_log_bin=0，来关闭自己会话的二进制日志记录。查看5.1.4节，“服务器系统变量”。
默认情况下，服务器不仅会记录事件，而且会记录事件的长度以此来确认这个事件已经成功被写入二进制日志里了。你也可以设置binlog_checksum变量来让服务器记录事件的校验和。当从二进制日志里读出事件时，主库默认会使用事件长度，但也可以通过设置master_verify_checksum变量来启用校验和。从库上的I/O线程也会校验从主库上收到的事件。你可以通过设置slave_sql_verify_checksum系统变量来让从库上的SQL线程使用校验和来确保中继日志的正确性。
二进制日志中记录的事件格式取决于设置的二进制日志记录格式。mysql支持三种记录格式，基于行的记录，基于语句的记录和两者混合的记录。具体使用哪种记录格式，取决于MySQL的版本。可以查看5.2.4.1节，“二进制日志记录格式”来获取这些记录格式的全部描述。查看MYSQL internals: 二进制日志。
服务器使用和--replicate-do-db、--replicate-ignore-db相同的方法来使用--binlog-do-db和--binlog-ignore-db选项。查看16.2.3.1节，“使用数据库级复制和二进制日志记录选项”。
默认情况下从库不会将它从主库接收到的任何二进制日志数据写入本身的二进制日志中。如果想记录这些数据，同时用--log-bin和--log-slave-updates选项来启动从库（查看16.1.4.3节，“从库关于复制的选项和变量”）。这将会在级联从库中使用到。
你可以用RESET MASTER命令来删除主库上的所有二进制日志，或者用PURGE BINARY LOGS来删除其中一部分。查看13.7.6.6节，“RESET 语法”，和13.4.1.1节，“PURGE BINARY LOGS语法”。
如果正在使用复制，你不能删除主库上旧的二进制日志文件，除非你很确定从库已经应用了这些日志并且不再需要它们了。例如，如果你的从库和主库之间从不会超过三天的延迟，那么你可以在主库上执行mysqladmin flush-logs命令并删除掉三天之前的二进制日志。可以手工删除这些日志文件，但是我们更推荐PURGE BINARY LOGS命令来删除，因为这样可以同时安全的让mysql更新二进制日志索引文件（也会带来日期的争议）。查看13.4.1.1节，“PURGE BINARY LOGS语法”。
你可以通过mysqlbinlog实用工具来查看二进制日志的内容。如果你想要用二进制日志做恢复，这是一个很好的选择。例如，你可以通过如下方式来使用二进制日志更新一个MySQL服务器：
shell> mysqlbinlog log_file | mysql -h server_name
mysqlbinlog也可以被用来显示中继日志的内容，因为中继日志的格式和二进制日志一样。查看4.6.8节，“mysqlbinlog-处理二进制日志文件的实用工具” 来获取更多关于mysqlbinlog的使用信息。查看7.5节，“使用二进制日志完成基于时间点（增量）的恢复”。
二进制记录的过程是这样的：一个事务执行完，然后二进制日志被记录下来，最后线程获取的锁被释放或事务提交完成。这保证了日志按照提交的顺序被记录下来。
对于非事务型表的更新在执行完则会被马上记录进二进制日志。
在一个未提交的事务里，任何在事务型表比如InnoDB表上的更新语句（UPDATE,DELETE或INSERT）都会被缓存起来直到服务器接收到一个COMMIT语句。到那时，mysqld进程在COMMIT语句执行之前，把整个事务写进二进制日志里。
对于非事务型表的更新不能被回滚。如果一个被回滚的事务里包含了对于非事务型表的更新，那么整个事务会被记录下来，而且在事务的末尾会带有一个ROLLBACK语句来确保对于那些表的更新被复制到从库上。
当一个涉及到事务的线程启动后，它会分配一个binlog_cache_size大小的缓冲区来缓存语句。如果一个语句的大小超过了binlog_cache_size，那么线程就会打开一个临时文件来存储这个事务的语句。当线程结束时，这个临时文件会被自动删除。
Binlog_cache_use状态变量显示了使用了这个缓冲区来存储语句的事务数量（也有可能是一个临时文件）。Binlog_cache_disk_use状态变量显示了使用了临时文件的事务数量。这两个变量可以被用来调整binlog_cache_size的大小从而避免线程使用临时文件。
max_binlog_cache_size系统变量（默认4GB,也是最大值）限制了用来存放多语句的事务的缓存。如果一个事务超过了这个大小，那么事务将会失败并被回滚。这个变量最小值是4096.
如果你正在使用基于行的二进制日志，并发插入会被转换为普通的像CREATE…SELECT或者INSERT…SELECT的普通插入语句。这样做是为了保证你在备份操作中，可以用二进制日志来恢复出来一个完全一模一样的表。如果你正在使用基于语句的二进制日志，那么原始SQL语句会被直接写入。
二进制日志的格式有一些已知的限制，这些限制可能会影响恢复操作。查看16.4.1节，“复制特性和要点”
能记录存储过程和函数的二进制日志也已经发布，相关描述在18.7节，“关于存储过程和函数的二进制日志”。
需要注意的是在MySQL 5.6里二进制日志的格式和之前版本不同，因为一些复制方面的增强特性。查看16.4.2节，“MySQL版本之间的复制兼容性”。
对于二进制日志和它的索引文件的写入原理和对于MyISAM表写入是一样的。查看C.5.4.3节，“MySQL如何处理磁盘空间不足”。
默认情况下，每次写入数据时，二进制日志都不会被同步到磁盘。因此如果操作系统或者机器（不止是MySQL服务器）宕机，有可能二进制日志还在内存中没有被刷新到磁盘上，可能会导致二进制日志数据丢失。为了防止这种情况发生，你可以通过设置sync_binlog系统变量来让二进制日志在每写入N次后被同步到磁盘上作持久化。查看5.1.4节，“服务器系统变量”。1是sync_binlog最安全的值，但也是最慢的值。即使sync_binlog设置为1，仍然有可能会因为系统宕机导致表内容和二进制日志不相同。例如，如果你在使用innodb表，MySQL服务器正在处理一个commit语句，它会将整个事务写入二进制日志并且把这个事务提交给innodb引擎。如果服务器在两个操作之间宕机，那么事务会被innodb引擎回滚，但是在二进制日志里面已经被记录。为了解决这个问题，你应该设置—innodb_support_xa为1。虽然这个选项是设置innodb是否支持XA事务的，但它也可以保证二进制日志和innodb表数据是一致的。
为了提供更高程度的安全性，MySQL服务器应该被设置成在事务提交之前同步二进制日志和innodb重做日志到磁盘。innodb重做日志默认会被同步到磁盘，sync_binlog也可被设置成1来确保同步二进制日志。这个参数的作用是每次系统宕机重启，在事务被回滚后，MySQL服务器从二进制日志里面删除被回滚的事务。这会确保二进制日志能够确实反映innodb表的数据，而且从库可以保证确实和主库同步（而不是收到主库上已经被回滚的语句）。
如果MySQL服务器发现在宕机恢复过程中二进制日志比原本长度小，那么它缺少至少一个成功提交的innodb事务。这不应该发生在sync_binlog=1，且磁盘或文件系统在被要求做刷盘操作（有些不这样），因此服务器会打印一个错误消息：The binary log file_name is shorter than its expected size. 这种情况下，二进制日志是错误的而且复制也应该被重新设置。
下列这些系统变量的会话级的值会被写入二进制日志，也会被从库在解析二进制日志时应用：
sql_mode (除了在 NO_DIR_IN_CREATE 模式下不会被复制; 查看 16.4.1.32节，“复制和变量”)
foreign_key_checks
unique_checks
character_set_client
collation_connection
collation_database
collation_server
sql_auto_is_null

5.2.4.1 二进制日志格式
服务器使用几种记录格式来记录二进制日志中的内容。实际运用的格式取决于MySQL的版本。有三种记录格式：
基于原始SQL语句的复制。这被称作基于语句的日志格式。你可以通过设置--binlog-format=STATEMENT来启用这种复制。
在基于行的日志格式里，主库将事件写入到二进制日志里。这种事件可以指示哪些行被修改了。你可以通过设置--binlog-format=ROW来其中这种复制。
第三种选项也可以启用：混合的模式。在这种模式下，默认会使用基于语句的日志格式，但是在以下一些情况中会自动使用基于行的日志格式。你可以用选项- -binlog-format=MIXED来启用这种复制模式。
在MySQL 5.6中，默认二进制日志记录格式为STATEMENT。
二进制日志格式也可能被设置或者被存储引擎限制。这可以在主库和从库复制的表使用的存储引擎不同的时候解决争议，使复制结果相同。
一旦使用了基于语句的日志格式，可能会有一些语句不能在主从之间产生唯一的结果。在决定一个给定的语句对于复制来说是否安全时，MySQL会判定它是否能够保证被复制到从库。如果MySQL不能保证这一点，它会把这个语句标记为不安全并发出警告，Statement may not be safe to log in statement format.
在MySQL 5.1.36之前，这个警告为，Statement is not safe to log in statement format. (Bug #42415)
你可以通过使用基于行的日志格式来避免这个问题。

5.2.4.2 设置二进制日志格式
你可以显式的通过设置- -binlog-format=type来选择使用哪种二进制日志格式。这个参数可以设置的值包括：
STATEMENT 开启基于语句的日志格式。
ROW 开启基于行的日志格式。
MIXED 开启混合的日志格式。
默认的二进制日志格式取决于你的MySQL版本：
对于MySQL5.1.11和以前的版本，以及MySQL 5.1.29和以后的版本来说，默认会使用基于语句的日志格式。
对于MySQL5.1.12到MySQL 5.1.28版本来说，默认使用混合日志格式。
例外：对于MySQL Cluster 6.1和以后的版本使用了NDBCLUSTER存储引擎（即使那些基于MySQL 5.1.29和以后的版本），默认二进制日志格式是MIXED。查看节17.6，“MySQL Cluster的复制”。
二进制日志格式也可以在运行过程中被动态改变。若要产生全局效果，请设置全局变量binlog_format系统变量：
mysql> SET GLOBAL binlog_format = 'STATEMENT';
mysql> SET GLOBAL binlog_format = 'ROW';
mysql> SET GLOBAL binlog_format = 'MIXED';
单个客户端可以改变自己会话的binlog_format的会话级设置：
mysql> SET SESSION binlog_format = 'STATEMENT';
mysql> SET SESSION binlog_format = 'ROW';
mysql> SET SESSION binlog_format = 'MIXED';
注意
　　每个MySQL服务器都可以设置自己的二进制日志格式（不管是否binlog_format是全局设置还是会话级设置）。这意味着主库的格式不会被从库复制。（当使用STATEMENT模式，binlog_format系统变量不会被复制；当使用MIXED或者ROW日志格式时，binlog_format会被复制到从库但是会被从库忽略，不应用。）在复制进行过程中改变二进制日志格式，或者只改变主库而不改变从库上的设置会导致不期望的结果，甚至导致同步中断。
为了改变binlog_format参数值，你需要SUPER权限。在MySQL 5.1.29中，会话级的binlog_format也是如此。
此外，有一种情况当你手工改变日志格式，从库可能会自动改变格式。这发生在当服务器运行在STATEMENT或者MIXED格式且遇到了一个以ROW格式记录的二进制日志的事件。这种情况下，从库临时自动切换到基于行的复制来应用那个事件，稍后自动切换到之前的格式上。
这里解释了为什么客户端想要设置自己的二进制日志格式：
一个对数据库做了很多细小更改的会话可能想要使用基于行的日志格式。
一个更改了很多行的会话想要使用基于语句的日志格式，因为它可以在二进制日志中记录更少的内容。
一些语句可能要在主库上执行很长时间，但只更改了少量行。因此使用基于行的日志格式会更有好处。
有一些你不能再运行中改变binlog_format的例外场景：
在存储过程或者触发器内部。
如果启用了NDBCLUSTER存储过程。
如果会话正处于基于行的日志格式，而且打开了临时表。
任何在以上场景要尝试进行改变binlog_format的操作都会失败。
如果你正在使用innodb表，且事务隔离级别为READ COMMITTED或READ UNCOMMITTED,只有基于行的日志格式可以使用。可以把日志格式设置为STATEMENT，但是在运行过程中这样做只会迅速导致错误，因为innodb不能插入记录。
当打开了临时表时，不建议在运行过程中改变binlog_format，因为临时表只会在基于语句的复制中被记录，在基于行的复制模式下它们是不被记录的。在混合模式下，临时表一般会被记录；除了当使用用户定义的函数（UDF），或使用UUID()函数。
当把binlog_format设置为ROW，许多对于表的改变被写进二进制日志。但是一些改变，仍然会使用基于语句的格式。这包括了所有的DDL（数据定义语言）语句例如CREATE TABLE,ALTER TABLE,或DROP TABLE。
--binlog-row-event-max-size选项可被使用基于行的复制的服务器使用。存储进二进制日志的行被划分为块，且大小不能超过这个参数设置的大小。值必须为256的倍数。默认值是1024.
警告：
当使用基于语句的复制时，一些不安全的语句有可能会造成主从数据不一致；是由于优化器的意愿导致。总之，在复制之外这也是一个不好的实践。详细的解释，查看C.5.8节，“MySQL的已知问题”。

5.2.4.3 混合的二进制日志格式
当使用MIXED二进制日志格式，在以下情况下服务器自动从基于语句的格式切换到基于行的格式：
当一个DML语句更新一个NDBCLUSTER表。
当一个函数包含UUID()。
在MySQL 5.1.40之前，当两个或多个带有AUTO_INCREMENT列的表被更新的时候。在5.1.40中，当一个或多个带有AUTO_INCREMENT列的表被更新，且一个触发器或存储函数被触发。不像其他不安全的语句，如果binlog_format被设置为STATEMENT，这不会产生一个警告。
查看更多信息，就在16.4.11节，“复制和AUTO_INCREMENT”。
当一个INSERT DELAYED语句被执行。
当一个视图体部分要求使用基于行的复制，创建视图的语句就会使用基于行的方式。比如这种情况会发生在当一个创建视图的语句使用了UUIC()函数。
当调用UDF函数的时候。
如果一个语句被以行的方式记录下来，且执行语句的会话打开了任何临时表，那么接下来的语句都会使用基于行的方式记录（除了那些要访问临时表的语句），直到所有被这个会话使用的临时表被删除。
不管任何临时表是否被记录下来，这都是真实的。
临时表不能以基于行的格式被记录下来；因此，一旦基于行的记录被启用，所有接下来的涉及到那个表的语句都是不安全的。服务器是如何做到的？服务器认为那个会话发出的所有语句都不安全，直到那个会话不再使用任何临时表。
从MySQL 5.1.23开始：
当FOUND_ROWS()或ROW_COUNT()被使用到.( Bug #12092, Bug #30244)
当USER(),CURRENT_USER(),或CURRENT_USER被使用到。(Bug #28086)
从MySQL 5.1.24开始，当一个语句涉及一个或多个系统变量.( Bug #31168)
例外场景。下面的系统变量，当在会话级内使用到（仅仅），不会引起日志格式的改变：
auto_increment_increment
auto_increment_offset
character_set_client
character_set_connection
character_set_database
character_set_server
collation_connection
collation_database
collation_server
foreign_key_checks
identity
last_insert_id
lc_time_names
pseudo_thread_id
sql_auto_is_null
time_zone
timestamp
unique_checks
要想获取更多关于判定系统变量作用范围的信息，查看5.1.5节，“使用系统变量”。
	要想获取更多复制机制如何处理sql_mode，查看16.4.1.35节，“复制和变量”。
从MySQL 5.1.30开始，当涉及的任何一个表是mysql库里的日志表。
从MySQL 5.1.34开始，当LOAD_FILE()函数被使用。 (Bug #39701)
注意：
	从MySQL 5.1.20开始，如果你想要用基于语句的日志格式执行一个原本该用基于行的格式的语句，那么一个警告会产生。这个警告会被同时显示在客户端（SHOW WARNINGS命令的输出）和mysqld的错误日志。而且每次这样的语句被执行时，会有一个警告被添加到SHOW WARNINGS列表。然而，每个会话只有第一个这样的语句会在错误日志里写入警告信息，以防日志里面信息泛滥。
从MySQL 5.1.20开始，除了上述决议，各个存储引擎也可以决定自己使用哪种日志格式来记录表数据的变化。存储引擎的记录能力可以被描述为：
如果一个存储引擎支持基于行的格式，那么这个引擎被称之为可以基于行格式记录。
如果一个存储引擎支持基于语句的格式，那么这个引擎被称之为可以基于语句格式记录。
一个给定的存储疫情可以支持任何一种或者同时两种记录格式。下面的表列出了每种存储引擎所支持的日志格式。
存储引擎	是否支持基于行的格式	是否支持基于语句的格式
ARCHIVE	是	是
BLACKHOLE	是	是
CSV	是	是
EXAMPLE	是	否
FEDERATED	是	是
HEAP	是	是
InnoDB	是	是，当事务隔离级别设置为REPEATABLE_READ或SERIALIZABLE；其他情况为否。
MyISAM	是	是
MERGE	是	是
NDBCLUSTER	是	否
在决定要使用哪种日志格式时，表数据受二进制日志事件影响的能力也要考虑进去。受影响的表的集合是这样被标记的：
如果是可以基于行格式记录但不能基于语句的表，会被标记为仅限于行格式记录。
如果是可以基于语句格式记录但不能基于行的表，会被标记为仅限于语句格式记录。
一旦决定了接下来的语句可能要使用的日志格式，它就会被和当前的binlog_format作比较。下面的表格用来描述二进制日志里的信息是如何记录的，以及是否会在某些时刻产生一个错误。在这个表格里，能保证主从一致的操作被称之为安全的。
下面表格里的一些规则决定了语句是否是安全的，其中SLR代表仅限于语句格式记录的语句，RLR代表仅限于行格式记录的语句。如果一个语句访问的一个或多个表是不支持行格式记录的表，那么这个语句就是仅限于语句格式记录的语句，反之亦然。
条件	反应
安全/不安全	binlog_format	SLR	RLR	错误/警告	被记录成
安全	STATEMENT	Yes	Yes	Error: not loggable	 
安全	STATEMENT	Yes	No	 	STATEMENT
安全	STATEMENT	No	Yes	Error: not loggable	 
安全	STATEMENT	No	No	 	STATEMENT
安全	MIXED	Yes	Yes	Error: not loggable	 
安全	MIXED	Yes	No	 	STATEMENT
安全	MIXED	No	Yes	 	ROW
安全	MIXED	No	No	 	STATEMENT
安全	ROW	Yes	Yes	Error: not loggable	 
安全	ROW	Yes	No	Error: not loggable	 
安全	ROW	No	Yes	 	ROW
安全	ROW	No	No	 	ROW
不安全	STATEMENT	Yes	Yes	Error: not loggable	 
不安全	STATEMENT	Yes	No	Warning: unsafe	STATEMENT
不安全	STATEMENT	No	Yes	Error: not loggable	 
不安全	STATEMENT	No	No	Warning: unsafe	STATEMENT
不安全	MIXED	Yes	Yes	Error: not loggable	 
不安全	MIXED	Yes	No	Error: not loggable	 
不安全	MIXED	No	Yes	 	ROW
不安全	MIXED	No	No	 	ROW
不安全	ROW	Yes	Yes	Error: not loggable	 
不安全	ROW	Yes	No	Error: not loggable	 
不安全	ROW	No	Yes	 	ROW
不安全	ROW	No	No	 	ROW
当一个警告产生，一个标准的MySQL警告会被发出（可以通过SHOW WARNINGS看到）。这个警告信息也会被写入到mysqld的错误日志里面。只有每个客户端的第一个错误信息会被记录到错误日志里防止日志里信息泛滥。记录的信息包括SQL语句内容。
当一个从库以- -log-warnings方式启动，那么从库会打印自己的状态信息到错误日志，例如从库开启复制线程时的二进制日志和中继日志的同步点，以及开始解析另一个中继日志，或是同步线程从主库断开连接后的又一次重试，等等。

5.2.4.4 对于mysql.*表操作的记录格式
mysql.*表也即mysql库里的表，里面的授权表时可以直接修改的（比如通过INSERT或DELETE语句），当然也可以被间接修改（例如通过GRANT或CREATE USER语句）。在MySQL 5.1.17中，这些变更mysql库表的语句会在一下情况里被写入二进制日志：
直接修改mysql库表的DML语句根据binlog_format的设置会被直接写入二进制日志。这适用于INSERT,UPDATE,DELETE,REPLACE,DO,LOAD DATA INFILE,SELECT和TRUNCATE TABLE。
间接修改mysql库表的语句，不管binlog_format被设置成什么，都会被以语句的方式记录下来。这适用于GRANT,REVOKE,SET PASSWORD,RENAME USER,CREATE（所有的形式，但CREATE TABLE…SELECT除外），ALTER（所有的形式），DROP（所有的形式）。
CREATE TABLE…SELECT是一种DDL和DML语句的结合。CREATE TABLE部分会被基于语句的格式记录，而SELECT部分会被按照binlog_format的设置的格式来记录。
