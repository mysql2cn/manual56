### 14.2.5. InnoDB特性：灵活性、易用性和可靠性

本节描述了InnoDB几个新增的特性，这些特性为InnoDB增加了新的灵活性，提高了易用性、可靠性和性能。[Barracuda](../glossary.md#g_Barracuda)文件格式不但提高了大型可变长度列的存储效率，还可以使用表[压缩](../glossary.md#g_compression)。在以前版本中，这项配置不能在启动后修改，而现在可以灵活地动态修改。一些改进是自然而然的，比如更快、更有效地截断表(
`TRUNCATE TABLE`)。另外一些改进可以使你更灵活地管控InnoDB的行为；例如，你可以更好地把握某些问题是否会导致错误或者只是警告，并且信息消息和错误报告会更人性化。

#### 14.2.5.1. 支持只读介质

在服务器启动选项中启用[`--innodb-read-only`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_read_only)，你就可以查询MySQL数据目录在只读介质上的InnoDB表。

**如何启用**

如果要将一个实例转成只读操作，首先要确保在存储到只读介质上之前，所有必要的信息已经[刷新](../glossary.md#g_flush)到数据文件。在禁用修改缓冲区([`innodb_change_buffering=0`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_change_buffering))的模式下启动服务器并执行一次[慢关闭](../glossary.md#g_slow_shutdown)。

要使整个MySQL实例处于只读模式，指定以下启动选项：

* [`--innodb-read-only=1`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_read_only)

* 如果实例在DVD或CD等只读介质上，或者`/var`目录是不可写的，则需要指定:`--pid-file=path_on_writeable_media` 和 `--event-scheduler=disabled`

**使用场景**

这种操作方式适用于以下场景:

* 在DVD、CD等只读存储介质上部署MySQL应用程序或MySQL数据。
* 多个MySQL实例同时查询相同的数据目录，通常出现在数据仓库的配置中。当一个MySQL实例负载很高，或者需要针对不同实例使用不同配置项来优化特定的查询的时候，你可以使用这种技术来避免[瓶颈](../glossary.md#g_bottleneck)。
* 有时为了安全或数据完整性，数据会被设定成只读状态，如存档备份数据。

> **注意**
> 
> 此功能主要用于分发和部署的灵活性，而不是仅仅考虑到性能。查看[14.2.4.2.3节，“只读事务的优化”](../Chapter_14/14.02.04_InnoDB_Performance_Tuning_and_Troubleshooting.md#14.02.04.02.03)，讲述了无需让整个服务器只读而优化只读查询性能的方法。

**它是如何工作的**

当服务器通过[`--innodb-read-only`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_read_only)选项运行在只读模式，某些InnoDB特性和组件将缩减或完全关闭:

* [修改缓冲区](../glossary.md#g_change_buffering)将不工作，特别是不会有修改缓冲区合并操作。当你为只读实例做准备工作的时候，要确保修改缓冲区是空的，先禁用修改缓冲区([`innodb_change_buffering=0`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_change_buffering))，然后做一次[慢关闭](../glossary.md#g_slow_shutdown)。
* 启动过程没有[崩溃恢复](../glossary.md#g_crash_recovery)。实例被设定成只读状态之前，必须先做一次[慢关闭](../glossary.md#g_slow_shutdown)
* 因为只读操作不需要[重做日志](../glossary.md#g_redo_log)，你可以将[`innodb_log_file_size`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_log_file_size)设置成最小值(1MB)，然后将实例设置成只读。
* 除了I/O读取线程，所有后台线程是关闭的。因此，一个只读的实例不可能发生[死锁](../glossary.md#g_deadlock)。
* 死锁信息、监视器输出等等不会写入临时文件。因此，[`SHOW ENGINE INNODB STATUS`](../Chapter_13/13.07.05_SHOW_Syntax.md#13.07.05.16)不会产生任何输出。
* 如果MySQL服务器使用[`--innodb-read-only`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_read_only)选项启动，但数据目录仍在可写介质，root用户仍然可以执行[DCL](../glossary.md#g_DCL)操作,如[GRANT](../Chapter_13/13.07.01_Account_Management_Statements.md#13.07.01.04)和[REVOKE](../Chapter_13/13.07.01_Account_Management_Statements.md#13.07.01.06)
* 更改那些通常会改变写操作行为的配置项，对运行在只读模式的服务器没有影响。
* [MVCC](../glossary.md#g_MVCC)强制关闭[隔离级别](../glossary.md#g_isolation_level)。所有查询读到的是最新版本，因为更新和删除是不可能的。
* 无需用到[回滚日志](../glossary.md#g_undo_log)。禁用[`innodb_undo_tablespaces`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_undo_tablespaces)及[`innodb_undo_directory`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_undo_directory)配置项。

#### 14.2.5.2. 重做日志文件大小的限制提高

以前，InnoDB [重做日志](../glossary.md#g_redo_log)文件的总大小限制是4GB。从MySQL5.6.3开始，这个大小限制提高到512GB。

不需要任何特殊的升级或文件格式就可以使用此功能。记录额外尺寸信息的字节已经在InnoDB[系统表空间](../glossary.md#g_system_tablespace)中保留，并设置为零。

如果你开发与InnoDB[逻辑序列号(`LSN`)](../glossary.md#g_LSN)交互的应用程序，请修改你的代码，使用有保障的64位变量来存储和比较LSN，不要使用32位变量。

#### 14.2.5.3. InnoDB表的2-Byte排序规则ID

InnoDB表可以使用大于255的排序规则ID。目前，这个范围内的排序规则ID都是用户定义的。例如，现在可以创建以下InnoDB表，然而在以前，排序规则ID 359是已经超出了InnoDB支持的范围。
	
	sql> show collation like 'ucs2_vn_ci';
	+------------+---------+-----+---------+----------+---------+
	| Collation | Charset | Id | Default | Compiled | Sortlen |
	+------------+---------+-----+---------+----------+---------+
	| ucs2_vn_ci | ucs2 | 359 | | | 8 |
	+------------+---------+-----+---------+----------+---------+
	1 row in set (0.00 sec)
	mysql> create table two_byte_collation (c1 char(1) character set ucs2 collate ucs2_vn_ci)
	-> engine = InnoDB;
	Query OK, 0 rows affected (0.16 sec)
	
#### 14.2.5.4. Barracuda文件格式

InnoDB已经开始使用命名的文件格式来提高在升级、降级以及异构系统运行不同级别的MySQL时的兼容性。许多InnoDB的重要特性，例如表压缩和更有效的BLOB的存储格式：`DYNAMIC`行格式，就需要使用[Barracuda](../glossary.md#g_Barracuda)文件格式创建表。以前的文件格式没有名字，现在被称为[Antelope](../glossary.md#g_Antelope)。

使用配置参数[`innodb_file_format`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_format)启用Barracuda文件格式，这样在创建新表的时候，就会使用Barracuda文件格式。这个参数同时也决定了新创建的表或索引是否可以使用压缩或`DYNAMIC`行格式。

这项新特性会导致MySQL 5.1以及之前版本的内置InnoDB无法访问数据库，如需要禁用这项新特性，请忽略[`innodb_file_format`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_format)的设置或设置成Antelope格式。

可以在命令行启动`mysqld`时设置[`innodb_file_format`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_format)的值，也可以在选项文件`my.cnf`(Unix操作系统)或`my.ini`(Windows)中设置。也可以使用`SET GLOBAL`语句动态修改设置。

更多关于文件格式管理的信息，请参阅[5.4.7章, “InnoDB文件格式管理”](../Chapter_05/05.04.07_InnoDB_File-Format_Management.md)。

#### 14.2.5.5. 动态修改系统配置参数

MySQL 5.5和更高版本中，修改某些系统配置参数，不需要关闭或重启服务器，然而在MySQL 5.1和更低版本中必需要重启服务器才能生效。这项改进大大增加了服务器的正常运行时间，也使得测试和设计原型SQL及应用程序代码变得更容易。下面的章节将详细讲解这些参数。

##### 14.2.5.5.1. 动态修改`innodb_file_per_table`

从MySQL 4.1版本开始，InnoDB表在磁盘上有两种存储方式，一种方式是在共享的[系统表空间](../glossary.md#g_system_tablespace)上创建表及其索引，这种方式表将会物理存储在[ibdata文件](../glossary.md#g_ibdata_file)中。另外一种方式是在独立表空间([.ibd文件](../glossary.md#g_ibd_file))上创建表及其索引。每个InnoDB表的存储位置是由建表时的配置参数[`innodb_file_per_table`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_per_table)决定的。

在MySQL 5.5和更高版本中，配置参数[`innodb_file_per_table`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_per_table)是动态的，可以使用`SET GLOBAL`命令设置为`O`N或`OFF`。而以前的版本中，唯一的办法是在MySQL[配置文件](../glossary.md#g_configuration_file)(`my.cnf`或`my.ini`)中设置这个参数，修改它需要关闭和重启服务器。

默认设置是`OFF`，所以新表和索引在系统表空间中创建。动态修改该参数需要`SUPER`权限，修改后所有连接会立即生效。

如果建表的时候[`innodb_file_per_table`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_per_table)是启用的，并且使用了[Barracuda](../glossary.md#g_Barracuda)文件格式，`TRUNCATE`操作会将表的磁盘空间返还给操作系统。Barracuda文件格式支持表压缩和`DYNAMIC`行格式等特性。如果建表的时候[`innodb_file_per_table`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_per_table)是禁用的，这些特性将不可用。如果现有的表想使用这些特性，你可以打开file-per-table设置并在这些表上运行`ALTER TABLE t ENGINE=INNODB`操作。

当重新定义InnoDB表的主键的时候，会使用当前的[`innodb_file_per_table`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_per_table)和[`innodb_file_format`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_format)设置来重建表。就像在[InnoDB存储引擎的快速创建索引](http://dev.mysql.com/doc/refman/5.5/en/innodb-create-index.html)中描述的一样，增加或删除InnoDB二级索引不会对此有影响。如果创建二级索引的时候没有重建表，索引会存储在与表数据相同的文件中，而与当前的[`innodb_file_per_table`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_per_table)设置无关。

##### 14.2.5.5.2. 动态修改`innodb_stats_on_metadata`

在MySQL 5.5和更高版本中，可以在运行时动态修改[`innodb_stats_on_metadata`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_stats_on_metadata)的设置，用来控制在执行InnoDB元数据语句时是否收集统计信息。可能使用以下语句来修改设置，`SET GLOBAL innodb_stats_on_metadata=mode`，`mode`可以是`ON`或`OFF`(1或0)。修改此设置需要`SUPER`权限，修改后会立即影响所有连接。

与此设置相关的是[14.2.5.8节，“控制优化器的统计评估方式”](../Chapter_14/14.02.05_InnoDB_Features_for_Flexibility_Ease_of_Use_and_Reliability.md#14.02.05.08)。

##### 14.2.5.5.3. 动态修改`innodb_lock_wait_timeout`

一个事务在放弃和回滚一个语句之前等待资源的时间，是由配置参数[`innodb_lock_wait_timeout`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_lock_wait_timeout)决定的。(在MySQL 5.0.12和更早版本中，整个事务会被回滚，不只是当前语句。)应用程序可以重试当前语句(通常在等待一段时间之后)，或回滚整个事务之后再重试。

等待超时后，会返回以下错误:

	ERROR HY000: Lock wait timeout exceeded; try restarting transaction

在MySQL 5.5和更高版本中，配置参数[`innodb_lock_wait_timeout`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_lock_wait_timeout)可以在运行时使用`SET GLOBAL`或`SET SESSION`设置。更改全局设置需要`SUPER`权限并且会影响随后连接的所有客户端。任何客户端也可以修改[`innodb_lock_wait_timeout`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_lock_wait_timeout)的`SESSION`设置，只影响当前客户端。

在MySQL 5.1和更早版本中，唯一的办法是在MySQL[配置文件](../glossary.md#g_configuration_file)(`my.cnf`或`my.ini`)设置这个参数，并且修改它需要关闭和重启服务器。

##### 14.2.5.5.4. 动态修改`innodb_adaptive_hash_index`

就像[14.2.4.2.14节，”控制自适应哈希索引”](../Chapter_14/14.02.04_InnoDB_Performance_Tuning_and_Troubleshooting.md#14.02.04.02.14)中描述的，在有些情况下，可以根据负载情况，动态地启用或禁用InnoDB的[自适应哈希索引](../glossary.md#g_adaptive_hash_index)来提高查询性能。

可以使用配置项[`innodb_adaptive_hash_index`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_adaptive_hash_index)禁用自适应哈希索引。默认是启用的。可以使用`SET GLOBAL`语句修改这个参数而不需要重启服务器。修改此设置需要`SUPER`权限。

禁用自适应哈希索引会立即清空哈希表。哈希表为空时，普通操作都可以继续，使用哈希表访问索引的查询会被B-trees代替。当再次启用自适应哈希索引时，哈希表会在正常操作时被再次填充。

#### 14.2.5.6. TRUNCATE TABLE 回收空间

当[截断](../glossary.md#g_truncate)一个存储在独立[.ibd](../glossary.md#g_ibd_file)文件中的表时(创建表时启用了[`innodb_file_per_table`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_file_per_table))，并且此表没有外键约束，此表将被删除并在一个新的`.ibd`文件中重建。这样操作的速度比逐删除要快得多，并且截断表后该表磁盘空间会归还给操作系统以便重用。由于没有大块未使用的空间在[系统表空间](../glossary.md#g_system_tablespace)，[物理备份](../glossary.md#g_physical backup)也会很小。相反地，如果使用InnoDB系统表空间，截断表后的空间只会归还给InnoDB。

MySQL 5.1和更早的版本中，可以重用已存在的`.ibd`文件，但这样只释放出空间到InnoDB，而没有到操作系统。需要注意的是，当截断表时，受`TRUNCATE TABLE`语句影响的行数只是个随机数。
	
> **注意**
> 如果在同一个表的两列之间有一个[外键约束](../glossary.md#g_FOREIGN_KEY_constraint)，仍然可以使用截断表这样的快速技术。
> 
> 如果在被截断的表和其他表之间有外键约束，截断操作将会失败。与之前的行为不同的是，将会把`TRUNCATE`操作转换为删除所有行的`DELETE`操作，并且将触发[子表](../glossary.md#g_child_table)的`ON DELETE`操作。

#### 14.2.5.7. InnoDB 严格模式（Strict Mode）

为防止SQL中因疏忽产生的拼写错误和语法错误或各种操作模式和SQL语句的组合所产生的其他意想不到的后果，InnoDB提供了“[严格模式](../glossary.md#g_strict_mode)”的操作。在这种模式下，InnoDB在某些情况下会报错而不是发出警告并执行特定的语句(可能是无意识的行为)。这个模式和MySQL中的[`sql_mode`](../Chapter_01/01.08.02_Selecting_SQL_Modes.md)类似，`sql_mode`控制什么样的SQL语法的能被MySQL接受，决定是否安静地忽略错误，或者校验输入语法和数据值。因为InnoDB严格模式是相对较新的我，一些在早期MySQL版本中执行没有错误的语句在严格模式下可能会产生错误，除非你禁用严格模式。

InnoDB严格模式的设置会影响[CREATE TABLE](../Chapter_13/13.01.17_CREATE_TABLE_Syntax.md), [ALTER TABLE](../Chapter_13/13.01.07_ALTER_TABLE_Syntax.md) 和 [CREATE INDEX](../Chapter_13/13.01.13_CREATE_INDEX_Syntax.md)语句的语法错误的处理。严格模式也会启用记录长度检查功能，所以`INSERT`或`UPDATE`操作不会因为记录太大而无法在给定的页中存储而导致错误。

如果在执行[CREATE TABLE](../Chapter_13/13.01.17_CREATE_TABLE_Syntax.md), [ALTER TABLE](../Chapter_13/13.01.07_ALTER_TABLE_Syntax.md)和[CREATE INDEX](../Chapter_13/13.01.13_CREATE_INDEX_Syntax.md)语句时使用了`ROW_FORMAT`和`KEY_BLOCK_SIZE`子句，Oracle建议启用[`innodb_strict_mode`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_strict_mode)。
如果没有启用严格模式，InnoDB创建表或索引的时候将忽略冲突的子句，只在消息日志中产生一个警告。这样创建的表可能并不是你想要，比如当你想创建一个压缩表的时候，结果创建了一个非压缩的表。如果启用了InnoDB严格模式，这种情况将直接产生一个错误，表或索引不会创建，避免了后面的麻烦。

InnoDB 严格模式的设置使用配置参数[`innodb_strict_mode`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_strict_mode)，可以是`ON`或`OFF`，可以在启动mysqld的命令行上或[配置文件](../glossary.md#g_configuration_file)`my.cnf`或`my.ini`中设置，也可以在运行时使用`SET [GLOBAL|SESSION] innodb_strict_mode=mode`语句（`mode`是`ON`或`OFF`）来启用或禁用InnoDB严格模式。改变`GLOBA`L设置需要`SUPER`特权，修改后会影响所有随后连接的客户端。修改[`innodb_strict_mode`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_strict_mode)的`SESSION`设置，只影响当前客户端。

#### 14.2.5.8. 控制优化器的统计评估方式

基于索引的相对[可选择性](../glossary.md#g_selectivity)，MySQL查询优化器根据索引键分布情况的评估[统计信息(statistics)](../glossary.md#g_statistics)决定在执行计划中使用哪个索引。某些操作会让InnoDB从表的索引中随机采样一些页来评估索引的[基数(cardinality)](../glossary.md#g_cardinality)。（这种技术被称为“[随机采样(random dives)](../glossary.md#g_random_dive)”）。这些操作包括：[`ANALYZE TABLE`](../Chapter_13/13.07.02_Table_Maintenance_Statements.md#13.07.02.01)语句、[`SHOW TABLE STATUS`](../Chapter_13/13.07.05_SHOW_Syntax.md#13.07.05.37)语句和重启后第一次访问表。

为了控制统计评估的质量(以便为查询优化器提供更好的信息)，现在可以使用参数[`innodb_stats_sample_pages`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_stats_sample_pages)来改变采样页的数量。而此前，采样页的数量固定是8，这不足以产生一个准确的评估，可能会导致查询优化器选择一个糟糕的索引。这种技术对大表和[表连接](../glossary.md#g_join)尤其重要。这类表上的不必要的[全表扫描](../glossary.md#g_full_table_scan)可以引发严重的性能问题。查看[8.2.1.20节，“如何避免全表扫描”](../Chapter_08/08.02.01_Optimizing_SELECT_Statements.md#08.02.01.20)，讲述了这类查询的调优技巧。

你可以在运行时设置全局参数[`innodb_stats_sample_pages`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_stats_sample_pages)。这个参数的默认为值是8，与过去版本保持相同的行为。

> **注意**
> 
> [`innodb_stats_sample_pages`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_stats_sample_pages)的设置值会影响所有InnoDB表和索引的索引采样。当你修改索引采样大小的时候，可能会产生以下潜在的重大影响:
> 
> * 很小的值（比如1或2）可能导致非常不准确的评估基数。
> 
> * 增加[`innodb_stats_sample_pages`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_stats_sample_pages)值可能需要更多的磁盘读取。如果设置值远远大于8(例如100)，会大大减缓打开表或执`SHOW TABLE STATUS`的速度。
> 
> * 优化器可能会选择非常不同的查询计划基于不同估计的索引的选择性。

如果要禁用元数据语句(例如`SHOW TABLE STATUS`)的基数评估，请执行`SET GLOBAL innodb_stats_on_metadata=OFF` (或0)语句。这个选项也是最近才能动态设置的。

当[mysql](../Chapter_04/04.05.01_mysql_The_MySQL_Command-Line_Tool.md)命令行客户端启动的时候，如果auto-rehash设置为ON(默认设置)，所有InnoDB表会被打开，并且所有相关索引的统计信息会被重新评估。为了改善[mysql](../Chapter_04/04.05.01_mysql_The_MySQL_Command-Line_Tool.md)客户端的启动时间，你可以关闭auto-rehash设置。auto-rehash特性可以为交互式用户实现数据库名、表名和列名的自动完成。

无论[`innodb_stats_sample_pages`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_stats_sample_pages)的设置是什么值，只要是最适合于系统的，设置并保持那个值。选择一个可以使数据库中的所有表都获得准确的评估且不需要过度的I/O的设置值。因为统计信息会在除了执行[`ANALYZE TABLE`](../Chapter_13/13.07.02_Table_Maintenance_Statements.md#13.07.02.01)的其他时间自动重新计算，所以增加采样大小、运行[`ANALYZE TABLE`](../Chapter_13/13.07.02_Table_Maintenance_Statements.md#13.07.02.01)，然后再减少采样大小的做法是毫无意义的。通过设置[`innodb_stats_sample_pages`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_stats_sample_pages)为更高的值，ANALYZE语句运行生成的更准确的统计信息将会被删除。

虽然不可能为每一个表指定采样大小，较小的表一般比大表需要更少的索引采样。如果数据库中有许多大表，可以考虑使用更高的[`innodb_stats_sample_pages`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_stats_sample_pages)设置值。

#### 14.2.5.9. 删除索引时更好的错误处理

为获得DML语句的最佳性能，InnoDB[外键](../glossary.md#g_foreign_key)列上需要有索引，以便[父表](../glossary.md#g_parent_table)上的更新和删除操作可以很容易地检查[子表](../glossary.md#g_child_table)上是否存在相应的行。MySQL在执行[CREATE TABLE](../Chapter_13/13.01.17_CREATE_TABLE_Syntax.md), [CREATE INDEX](../Chapter_13/13.01.13_CREATE_INDEX_Syntax.md)和[ALTER TABLE](../Chapter_13/13.01.07_ALTER_TABLE_Syntax.md)语句时根据需要自动创建或删除这类索引。

当删除索引时，InnoDB会确认是否该索引未用于外键约束检查。如果另外还有一个索引可以用于同一个约束，这个索引就可以删除。InnoDB会阻止删除最后一个用于参考约束的索引。

这种情况的报错消息如下:

	ERROR 1553 (HY000): Cannot drop index 'fooIdx':
	needed in a foreign key constraint

这比以前的消息更加友好:

	ERROR 1025 (HY000): Error on rename of './db2/#sql-18eb_3'
	to './db2/foo'(errno: 150)

试图删除主键索引时的错误报告也有类似的变化。如果表没有一个明确的主键，InnoDB会使用表中第一个唯一且非空的列创建一个隐式的[聚集索引](../glossary.md#g_clustered_index)。当你删除这样一个索引时，InnoDB会自动复制表并使用另外一个唯一且非空的列或系统生成的键来重建索引。因为这个操作修改了主键，它使用较慢的方法复制表和重新创建索引，而不是[5.5.6章,“在线DDL的实现细节”](../Chapter_05/05.05.06_Implementation_Details_of_Online_DDL.md)中描述的快速创建索引技术。

以前，如果表不包含主键，删除此表上隐式的聚集索引(第一个唯一非空索引)会失败:

	ERROR 42000: This table type requires a primary key

#### 14.2.5.10. SHOW ENGINE INNODB MUTEX 的输出更紧凑

`SHOW ENGINE INNODB MUTEX`语句显示了信息INNODB[mutexes(互斥锁)](../glossary.md#g_mutex)和[rw-locks](../glossary.md#g_rw_lock)的信息。虽然这些信息对多核系统的调优是有用，但其大量的输出可能会淹没系统的大[缓冲池](../glossary.md#g_buffer_pool)。每个16K缓冲池块有一个mutex和一个rw-lock，65,536块/GB。缓冲池中单个块的mutex或rw-lock不太可能成为性能瓶颈。

现在`SHOW ENGINE INNODB MUTEX`跳过了缓冲池块的mutexes和rw-locks。也不列出任何未引起等待(`os_waits=`0)的mutexes和rw-locks。因此，`SHOW ENGINE INNODB MUTEX`只显示缓冲池以外的造成至少一个操作系统[等待](../glossary.md#g_wait)的mutexes和rw-locks。

#### 14.2.5.11. 更多预读统计

就像[14.2.4.2.16节,“预读算法的改变”](../Chapter_14/14.02.04_InnoDB_Performance_Tuning_and_Troubleshooting.md#14.02.04.02.16)中描述的，预读请求是对在不久将来可能使用的页的异步I/O请求。知道有多少页是通过预读机制读取的，有多少页未被访问过就被清理出缓冲池的，对调整参数[`innodb_read_ahead_threshold`](../Chapter_14/14.02.06_InnoDB_Startup_Options_and_System_Variables.md#sysvar_innodb_read_ahead_threshold)是非常有帮助的。

`SHOW ENGINE INNODB STATUS`的输出显示了全局状态变量[`Innodb_buffer_pool_read_ahead`](../Chapter_05/05.01.06_Server_Status_Variables.md#Innodb_buffer_pool_read_ahead)和[`Innodb_buffer_pool_read_ahead_evicted`](../Chapter_05/05.01.06_Server_Status_Variables.md#Innodb_buffer_pool_read_ahead_evicted)。这些变量显示了有多少页是通过预读请求进入[缓冲池](../glossary.md#g_buffer_pool)的，又有多少页未被访问过就被从缓冲池中[清理](../glossary.md#g_eviction)出来了。这些计数器提供的是自最后一次重启服务器后的全局值。

`SHOW ENGINE INNODB STATUS`也显示了预读页读入的速度和这些页未被访问就被清理掉的速度。每秒的平均值是根据上次调用`SHOW ENGINE INNODB STATUS`并显示在`BUFFER POOL AND MEMORY`那一段的信息进行统计的。
