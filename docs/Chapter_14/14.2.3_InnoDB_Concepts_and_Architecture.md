# 14.2.3. InnoDB Concepts and Architecture

这部分的信息提供了一些背景资料用于使你得到InnoDB表的最高性能及功能。为以下人提供：

* 任何从1其他数据库系统迁移过来的人，解说有哪些相同及不同。
* 任何从MyISAM迁移到InnoDB的用户，现在InnoDB是默认的储存引擎。
* 任何在意他的程序架构或者软件栈的人，可以得到设计注意事项，性能特征及精细级别的InnoDB表的可扩展性。

这部分，你会学到：

* InnoDB如何实现事务，及与你熟悉的数据库相比，事务实现的内部机制有哪些区别及共同之处。
* InnoDB如何实现行级锁来允许查询及DML语句同时对一个表读写。
* 多版本并发控制（MVCC）如何在适当的时间之前为不同用户的视图或者修改之间保持事务。
* InnoDB相关的对象在磁盘上的物理分布，比如表，索引，表空间，undo日志及redo日志。

## 14.2.3.1. The InnoDB Transaction Model and Locking

为了实现一个大规模，繁忙的，或者高可用性的数据库程序，为了从别的数据库系统迁移代码，或者把MySQL的性能推到物理允许的极限，你必须了解事务及锁在InnoDB储存引擎中的观点。

在InnoDB的事务模型里，最主要的就是使用了带有传统两阶段锁的多版本数据库的最好的特性。InnoDB在行级别加锁并且查询是默认不会加一致性读锁的，与Oracle相同。在InnoDB中锁信息不会被储存在特定的空间，因此不需要锁升级：特别是，多个用户允许锁定InnoDB表中所有的行，或者任何随机用户都可以在不造成InnoDB用量增大的情况下锁定行的一个子集。

InnoDB里，当前所有用户都内置了一个事务。如果使用了自动提交模式，每个SQL语句都属于自己独有的事务。默认情况下，MySQL会在所有用户会话建立的时候启用自动提交，MySQL会在每条SQL语句被正确执行执行之后都会做一个提交。如果语句返回一个错误，提交及回滚决定于错误的种类。参见Section 14.2.3.14, “InnoDB Error Handling”。

一个自动提交的会话可以执行一个多语句的事务。使用START TRANSACTION或者BEGIN语句开启，然后使用COMMIT或者ROLLBACK语句结束，参见 Section 13.3.1, “START TRANSACTION, COMMIT, and ROLLBACK Syntax”。

如果通过语句SET autocommit = 0关闭了自动提交，会话就会开启一个事务，一个COMMIT或者ROLLBACK会结束当前事务并开启新的事务。

COMMIT意味着当前事务所作的修改会被永久保存并可以被其他会话看到。ROLLBACK语句意味着，中止当前事务所作的修改。COMMIT与ROLLBACK都会释放所有的当前事务的InnoDB表锁。

在SQL:1992的事务隔离级别中，默认的InnoDB隔离级别是REPEATABLE READ，InnoDB也提供了SQL标准中提及的所有四个事务隔离级别：READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ, 及 SERIALIZABLE。

用户可以通过SET TRANSACTION语句来为一个会话或者接下来所有新的连接指定隔离级别。为了设置所有连接的默认隔离级别，需要在命令行选项或者选项文件中添加--transaction-isolation选项。详细的隔离级别信息及级别设置语法，可以参见Section 13.3.6, “SET TRANSACTION Syntax”。

在行级别锁里，InnoDB一般会使用下一键锁定。也就是说除了索引记录之外，InnoDB也会锁定索引记录前的间隙上的插入来阻止其他会话由于树数据结构对该位置可能的插入。下一键锁定是一个锁定索引记录及该记录之前的间隙的锁。间隙锁时一个只锁定一些索引记录之前的间隙的锁。

对于行级锁的详细信息，及间隙锁被禁用后产生的状况，可以参见Section 14.2.3.5, “InnoDB Record, Gap, and Next-Key Locks”。

## 14.2.3.2. InnoDB Lock Modes

InnoDB实现了标准的行级锁，包含两种锁：

* 一个共享锁（S）用于事务得到读一行的锁。
* 一个排他锁（X）用于事务得到对一行修改或者删除的锁。

如果事务T1得到了行r上的共享锁（S），从别的事务T2发起的对r的锁会有两种情况：

* T2发起的S锁请求会被立即接受，T1及T2都会持有r上的S锁。
* T2发起的X锁请求不会被立即接受。

如果一个事务T1持有行r上的排他锁（X），从别的事务T2发起的任何锁请求都不会被立即接受，事务T2必须等待事务T1释放在行r上的锁。

除此之外，InnoDB支持多粒度锁，可以使对行的锁定及对表实体的锁定可以共存。为了使用多粒度锁，需要添加一个名叫意图锁的新的锁类型。意图锁在InnoDB中是一个表锁，决定一个事务接下来对表中的一行需要加上哪种类型的锁（共享锁或者排他锁）。在InnoDB中有两种意图锁（根据事务T请求表t上的的显式锁）：

* 意图共享（IS）：事务T将要在表t个别的行上加S锁。
* 意图排他锁(IX)：事务T想要在指定的行上加X锁。

例如，SELECT ... LOCK IN SHARE MODE会设疑设置一个IS锁而SELECT ... FOR UPDATE会设置一个IX锁。

意图锁如下执行：

* 在事务需要表t上一行的S锁之前，必须获得表t上一个IS锁或者更强的锁。
* 在事务可以获得行上的X锁之前，必须首先获得表t上的一个IX锁。

下面的规则总结了锁类型兼容性矩阵：

<table summary=' Compatibility matrix showing which combinations of
          lock types X, IX, S, and IS are allowed. Each cell in the
          matrix is marked as either "兼容" or "冲突".
' border="1">
    <colgroup>
        <col>
        <col>
        <col>
        <col>
        <col>
    </colgroup>
    <thead>
    <tr>
        <th scope="col"></th>
        <th scope="col"><em class="replaceable"><code>X</code></em></th>
        <th scope="col"><em class="replaceable"><code>IX</code></em></th>
        <th scope="col"><em class="replaceable"><code>S</code></em></th>
        <th scope="col"><em class="replaceable"><code>IS</code></em></th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td scope="row"><em class="replaceable"><code>X</code></em></td>
        <td>冲突</td>
        <td>冲突</td>
        <td>冲突</td>
        <td>冲突</td>
    </tr>
    <tr>
        <td scope="row"><em class="replaceable"><code>IX</code></em></td>
        <td>冲突</td>
        <td>兼容</td>
        <td>冲突</td>
        <td>兼容</td>
    </tr>
    <tr>
        <td scope="row"><em class="replaceable"><code>S</code></em></td>
        <td>冲突</td>
        <td>冲突</td>
        <td>兼容</td>
        <td>兼容</td>
    </tr>
    <tr>
        <td scope="row"><em class="replaceable"><code>IS</code></em></td>
        <td>冲突</td>
        <td>兼容</td>
        <td>兼容</td>
        <td>兼容</td>
    </tr>
    </tbody>
</table>

如果事务请求的锁兼容于当前已被加上的锁，那么该请求就会被通过，但如果与当前已加上的锁冲突，请求就会被拒绝，事务会一直等待直到当前的锁被释放。如果一个锁请求与当前的锁冲突并且如果允许会导致死锁的话，会产生一个错误。

因此，意图锁只会对整个表加锁（LOCK TABLES ... WRITE）。IX及IS主要的作用是表示某个用户正在锁定一行或者将要锁定一行。

下面的例子展示了一个会造成死锁的锁请求是如何发生的。例子需要两个客户端A，B。

首先，客户端A创建一个包含一行的表，然后开启一个事务，在事务中，S锁会通过select为共享模式加在行上：

    mysql> CREATE TABLE t (i INT) ENGINE = InnoDB; Query OK, 0 rows affected (1.07 sec)    mysql> INSERT INTO t (i) VALUES(1); Query OK, 1 row affected (0.09 sec)    mysql> START TRANSACTION;    Query OK, 0 rows affected (0.00 sec)    mysql> SELECT * FROM t WHERE i = 1 LOCK IN SHARE MODE; +------+    |i |    +------+    | 1|    +------+    1 row in set (0.10 sec)
下一步，客户端B开启一个事务，然后发起删除该行的请求：
    mysql> START TRANSACTION;    Query OK, 0 rows affected (0.00 sec)    mysql> DELETE FROM t WHERE i = 1;

删除操作需要X锁，但由于这个锁与客户端A持有的S锁不兼容，该请求不会被通过，请求被放置到锁请求队列中，客户端B会被锁定。

最后，客户端A想要删除该行：

    ￼mysql> DELETE FROM t WHERE i = 1;    ERROR 1213 (40001): Deadlock found when trying to get lock; try restarti

此时会产生死锁，因为客户端需要行上的X锁来删除该行，但由于B客户端已经有一个该行上的X锁请求等待客户端A释放S锁，这个请求不会被允许。由于B已经请求了X锁，A持有的S锁不能被升级为X锁。结果，InnoDB会在客户端中的某一个上产生错误然后释放它持有的锁。客户端错误如下：

    ￼ERROR 1213 (40001): Deadlock found when trying to get lock;    try restarting transaction

这个时候，从其他客户端发起的锁请求会被允许，然后它可以删除该行。

> 注意：
> 如果InnoDB监控的LATEST DETECTED DEADLOCK输出以下信息：“TOO DEEP OR LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING TRANSACTION,” 这意味着事务等待列表上事务的数目已经达到200，该数值由LOCK_MAX_DEPTH_IN_DEADLOCK_CHECK确定。一个有200个事务的等待列表回作为死锁处理，等待列表中的事务会被回滚。
> 相同的错误也会由于锁线程必须在事务所属的等待列表中超过1,000,000个锁中执行搜索产生，该数值由 LOCK_MAX_N_STEPS_IN_DEADLOCK_CHECK指定。

## 14.2.3.3. Consistent Nonlocking Reads



## 14.2.3.4. Locking Reads (SELECT ... FOR UPDATE and SELECT ... LOCK IN SHARE MODE)

### Usage Examples

## 14.2.3.5. InnoDB Record, Gap, and Next-Key Locks

## 14.2.3.6. Avoiding the Phantom Problem Using Next-Key Locking

## 14.2.3.7. Locks Set by Different SQL Statements in InnoDB

## 14.2.3.8. Implicit Transaction Commit and Rollback

## 14.2.3.9. Deadlock Detection and Rollback

## 14.2.3.10. How to Cope with Deadlocks

## 14.2.3.11. InnoDB Multi-Versioning

### Internal Details of Multi-Versioning

### Guidelines for Managing Rollback Segments

## 14.2.3.12. InnoDB Table and Index Structures

### 14.2.3.12.1. Role of the .frm File for InnoDB Tables

### 14.2.3.12.2. Clustered and Secondary Indexes

#### How the Clustered Index Speeds Up Queries

#### How Secondary Indexes Relate to the Clustered Index

### 14.2.3.12.3. FULLTEXT Indexes

### 14.2.3.12.4. Physical Structure of an InnoDB Index

### 14.2.3.12.5. Insert Buffering

#### Disk I/O for Flushing the Insert Buffer

### 14.2.3.12.6. Adaptive Hash Indexes

### 14.2.3.12.7. Physical Row Structure

## 14.2.3.13. The InnoDB Recovery Process

## 14.2.3.14. InnoDB Error Handling

### 14.2.3.14.1. InnoDB Error Codes

### 14.2.3.14.2. Operating System Error Codes

