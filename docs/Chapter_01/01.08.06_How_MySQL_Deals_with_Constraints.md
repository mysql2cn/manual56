# 1.8.6 MySQL如何处理约束

###1.8.6 MySQL如何处理约束

  MySQL使你的工作可以采用事务表来支持回滚操作，也可以使用不支持回滚的非事务表。因此，MySQL的约束处理与其他DBMS会有所不同。我们必须要考虑往非事务表中插入或是更新大量数据的情形，因为如果产生错误不能回滚。
  
  MySQL服务器的基本原则是任何语句在执行前进行解析时，检测到任何问题都尽量报错，在执行语句时遇到任何错误都尽量恢复。我们尽可能去做了，但是还是不能考虑到所有情况。
  
  MySQL有相关的选项，可以选择当错误产生时是在执行中途停止，或是尽量恢复并继续执行。这意味着，例如，服务器可能会强制把无效的值替换成相近的值。
  
  有许多SQL模式的选项可用，提供了处理错误数据的强大控制选项，以及在遇到错误时是继续执行还是取消执行。通过这些选项，你可以把MySQL服务器配置的更像其他DBMS一样禁止错误的输入。SQL模式可以在启动时作为全局设置从而对所有客户端起作用。不同的客户端也可以在运行时分别设置SQL模式，从而使得客户端可以选择更为满足其需求的设置。参看[5.1.7 服务器SQL模式][5.1.7]。
[5.1.7]:../Chapter_05/05.01.07_Server_SQL_Modes.md

  下边的章节介绍了MySQL服务器如何处理不同类型的约束。
 
####1.8.6.1 PRIMARY KEY 与UNIQUE索引约束

  通常，对于修改数据的语句（比如INSERT或者UPDATE）可能会产生违反主键,唯一键，或是外键约束的错误。如果你使用的是事务性存储引擎比如InnoDB，MySQL会自动回滚语句。如果用的是非事务型引擎，MySQL会在出错的行的位置停止语句的执行，并且其余的行不会继续处理。
  
  MySQL支持在INSERT，UPDATE等语句中使用IGNORE关键词。如果使用了，MySQL会忽略主键或唯一键验证并继续处理剩下的行。参看你所使用的语句的相关章节([13.2.5 INSERT语法][13.2.5],[13.2.11][UPDATE 语法][13.2.11]等等)。
[13.2.5]:../Chapter_12/13.02.05_INSERT_Syntax.md
[13.2.11]:../Chapter_13/13.02.11_UPDATE_Syntax.md

  你也可以获取关于插入或是更新的行数的确切信息，通过mysql_info()这个C API函数。也可以用SHOW WARNINGS语句。参看[22.8.7.35 mysql_info()][22.8.7],[13.7.5.41 SHOW WARNINGS语法][13.7.5]。
[22.8.7.35]:../Chapter_22/22.08.07_C_API_Function_Descriptions.md
[13.7.5]:../Chapter_13/13.07.05_SHOW_Syntax.md

  目前，只有InnoDB支持外键。参看[5.4.5 InnoDB与FOREIGN KEY约束][5.4.5]。
[5.4.5]:../Chapter_05/05.04.05_InnoDB_and_FOREIGN_KEY_Constraints.md

####1.8.6.2 FOREIGN KEY约束

  外键约束使得你可以在数据与表之间相互参照，并且外键约束可以约束这些分散的数据。
  
  MySQL支持在CREATE TABLE与ALTER TABLE中使用ON UPDATE和ON DELETE外键关联。可用的相关方法有RESTRICT（默认），CASCADE,SET NULL,NO ACTION。
  
  > NDB当涉及到的列是父表的主键时，不支持ON UPDATE CASCADE方法。
  
  MySQL服务器也支持SET DEFAULT，但是目前对于InnoDB与NDB是不可用的，会被拒绝。由于MySQL不支持延迟约束检查，所以NO ACTION会被当做RESTRICT处理。关于MySQL支持的外键的确切语法，参看[13.1.17.2 使用FOREIGN KEY约束][13.1.17]。
[13.1.17]:../Chapter_13/13.01.17_CREATE_TABLE_Syntax.md

  MATCH FULL,MATCH PARTIAL,MATCH SIMPLE都是可用的，但是应该避免使用这些，因为他们会使得MySQL服务器忽略掉这条语句中的ON DELETE或ON UPDATE条件。MATCH选项在MySQL中并没有其他用处，实际上完全是为了MATCH SIMPLE的语意。
  
  MySQL要求外键的列必须有索引；如果创建表时候外键约束的列没有索引，那么会在其上创建索引。
  
  你可以通过INFORMATION_SCHEMA.KEY_COLUMN_USAGE表来获取指定外键的信息。如下展示了一个访问该表的语句示例：
  
	```sql
	mysql> SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME, CONSTRAINT_NAME
	     > FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
	     > WHERE REFERENCED_TABLE_SCHEMA IS NOT NULL;
	```
+--------------+---------------+-------------+-----------------+  
| TABLE_SCHEMA | TABLE_NAME    | COLUMN_NAME | CONSTRAINT_NAME |  
+--------------+---------------+-------------+-----------------+  
| fk1          | myuser        | myuser_id   | f               |  
| fk1          | product_order | customer_id | f2              |  
| fk1          | product_order | product_id  | f1              |  
+--------------+---------------+-------------+-----------------+  
3 rows in set (0.01 sec)

  关于InnoDB表的外键信息也可以在INNODB_SYS_FOREIGN和INNODB_SYS_FOREIGN_COLS表中找到，在INFORMATION_SCHEMA数据库中。
  
  目前，只有InnoDB表支持外键。参看[5.4.5 InnoDB与FOREIGN KEY约束][5.4.5]，来获取更多关于InnoDB支持外键的信息。
[5.4.5]:../Chapter_05/05.04.05_InnoDB_and_FOREIGN_KEY_Constraints.md

####与标准SQL的差别

  MySQL实现的外键与标准SQL的主要区别有以下几点：
  
  - 如果父表中的多行具有相同的关联键值，InnoDB在进行外键检查时会当做父表中具有相同关联键值的行不存在。例如，如果你定义了RESTRICT类型的约束，并且一个子行对应了多个父行，InnoDB则不允许删除父行中的任何一行。
  
    InnoDB在处理联级操作时是基于深度优先算法的，是基于索引中数据的外键索引一致性。
    
  - 如果在一个联合操作中，ON UPDATE CASCADE或ON UPDATE SET NULL递归更新了之前更新的同一个表，则会与RESTRICT表现一样。这意味着，在ON UPDATE CASCADE或ON UPDATE SET NULL操作中不能引用自身。这是为了避免在联合更新中造成无限循环。在ON DELETE SET NULL中引用自身，从另一方面来说是可以的，同样对于ON DELETE CASCADE也是可以的。联合操作的深度不能超过15级。
  
  - 在插入，删除，更新多个行时，外键约束(比如唯一约束)是一行一行进行检查的。当进行外键检查时，InnoDB会在必须检查的子记录或是父记录上加上共享行级锁。MySQL会立即进行外键约束检查；检查不会因为事务的提交而被延迟。也就是说，约束会在SQL语句进行处理时立即进行检查。这意味着，删除一个外键与自己相关联的行是不可能的。
  
  关于InnoDB外键与标准SQL区别的更多信息，参看[5.4.5 InnoDB与FOREIGN KEY约束][5.4.5]。
[5.4.5]:../Chapter_05/05.04.05_InnoDB_and_FOREIGN_KEY_Constraints.md

####1.8.6.3无效数据约束

  默认情况下，MySQL在插入数据时会忽略无效或不合适的值，强迫他们转换成有效值。然而，你也可以修改服务器的SQL模式来选择传统的对待无效数据的方式，比如当遇到无效数据时让服务器拒绝他们并终止语句。参看[5.1.7 服务器SQL模式][5.1.7]。
[5.1.7]:../Chapter_05/05.01.07_Server_SQL_Modes.md

  这个章节描述了默认情况(忽略模式)MySQL的表现以及严格SQL模式下的表现，以及两者的区别。
  
  如果你没使用严格模式，那么当你插入一个“不正确”的值时，比如插入NULL到NOT NULL的列中，或是向数字类型的列中插入了一个超大的数字，MySQL会把列的值设置一个“最合适的值”而不会产生错误：如下的规则描述了它如何工作的详细信息：
  
  - 如果向数字类型的列中存放一个超范围的值，MySQL服务器会存储0代替可能的最小值，或是最大的允许值，取决于哪个更接近无效值。
  
  - 对于字符串，MySQL会存储空字符串或尽可能多的将字符串存储到列中。
  
  - 如果往数字类型的列中存储一个不以数字开头的字符串，MySQL服务器会存储一个0。
  
  - 对于ENUM与SET类型列的无效值，其处理方式在[1.8.6.4 ENUM与SET约束][1.8.6]中进行了描述。
[1.8.6]:../Chapter_01/01.08.06_How_MySQL_Deals_with_Constraints.md

  - MySQL允许你向DATE与DATETIME类型的列中存储某些错误数据(诸如'2000-02-31'或'2000-02-00')。这样做是出于对SQL服务器不应该对日期进行检查的想法。如果MySQL可以保存日期值并把相同的值取出来，MySQL就会按照给定的值存储。如果日期完全不对(超过了服务器存储的能力)，则特殊的“0”日期值'0000-00-00'会代替无效值存进列中。
  
  - 如果你尝试向不能为NULL值的列中存储NULL值，对于单条INSERT语句会报错。对于多条INSERT语句或是INSERT INTO ... SELECT语句，MySQL服务器会存储该列数据类型的隐式默认值。通常，对于数字类型的默认值是0，字符串类型的是空字符串('')，日期及时间类型的是“0”。隐式默认值的相关讨论在[11.5 数据类型的默认值][11.5]。
[11.5]:../Chapter_11/11.05.00_Data_Type_Default_Values.md

  - 如果INSERT语句对于某列没有设置值，如果该列定义时明确指定了默认值，那么MySQL就会插入该列的默认值。如果定义没有设置默认值，那么MySQL会插入该列数据类型对应的隐式默认值。
  
  在非严格模式中采取这些规则是因为，我们无法检查这些情况，直到语句运行才可以。如果我们更新多行时候遇到问题也不能回滚，因为有些存储引擎可能不支持回滚功能。直接终止语句这个选项看起来并不好；这时，更新可能会“完成一半”，这是最坏的方案。因此，最好的方案是“尽可能做”然后如果没有错误产生那么就继续运行。
  
  在MySQL5.0.2以及更高版本，可以通过STRICT_TRANS_TABLES或STRICT_ALL_TABLES SQL模式语句来选择对输入值采取严格模式：
  
	```sql
	  SET sql_mode = 'STRICT_TRANS_TABLES';
	  SET sql_mode = 'STRICT_ALL_TABLES';
	```
	
  STRICT_TRANS_TABLES会对事务存储引擎开启严格模式，对于非事务引擎的一些扩展也适用。它的作用如下：
  
  - 对于事务存储引擎，语句中错误数据无论在哪儿产生，都会导致语句终止并回滚。
  
  - 对于非事务引擎，如果插入或更新的第一条数据出错那么语句会被取消执行。(如果第一条数据出错，语句取消执行那么表没有任何改变，就像事务型表一样。)第一条数据之后若产生错误则不会取消语句执行，因为第一条数据已经改变了原有表的内容。因而，错误数据值会被自动适应然后报告一个警告而不是产生错误。换句话说，在STRICT_TRANS_TABLES模式下，错误值会使MySQL回滚到目前已经完成的更新之前，如果能够不改变表并完成回滚。但是如果表一旦被改变，再产生的错误就会自动修正并发出警告。
  
  对于更严格的检查，可以开启STRICT_ALL_TABLES。这与STRICT_TRANS_TABLES基本一致，除了对非事务存储引擎，错误会终止语句执行，即便错误数据出现在第一行数据之后。这意味着，在非事务表中执行多行的插入或更新操作中途出现了错误，就会导致操作只进行了一部分。早些的行会被插入或更新，但是在错误产生之后的行则不会。为避免在非事务表中产生这种问题，可以使用单条语句或是使用STRICT_TRANS_TABLES模式，如果产生警告比错误更能接受的话。想要在一开始就避免错误，就让MySQL不检查每列的值。这是最安全(通常也是最快)的使应用程序保证它只存储了正确值到数据库中的方法。
  
  对于两种阎格模式而言，你可以把错误当做警告来处理，通过使用INSERT IGNORE或UPDATE IGNORE，比INSERT或UPDATE而不带IGNORE要好。
  
####1.8.6.4 ENUM与SET约束

  ENUM与SET列提供了更为高效的方式来定义那些只能存储给定的一组值的列。参看[11.4.4 ENUM类型][11.4.4],[11.4.5 SET类型][11.4.5]。然而，在MySQL5.0.2之前，ENUM与SET列对于插入的错误数据并没有提供真正的检查：
[11.4.4]:../Chapter_11/11.04.04_The_ENUM_Type.md
[11.4.5]:../Chapter_11/11.04.05_The_SET_Type.md
  
  - ENUM列永远具有默认值。如果没有指定默认值，那么对于可以为NULL的列默认值就是NULL，或者是列定义中的第一个值。
  
  - 如果向ENUM列中插入了错误的值或是通过IGNORE强制把值插入到ENUM列中，会被设置成保留的数值0，在字符串内容中会显示为空字符。
  
  - 如果向SET列中插入了错误的值，错误的值会被忽略。比如，如果列的可取值为'a','b','c',如果尝试插入'a,x,b,y'则只会插入'a,b'。
  
  对于MySQL5.0.2，可以配置服务器来使用严格SQL模式。参看[5.1.7服务器SQL模式][5.1.7]。当开启严格模式时，ENUM或SET列的定义就会成为插入到列中值的约束。如果插入值不能满足这些条件，就会产生错误：
  
  - ENUM的值可以是列定义值的其中一个，或者一个与其等价的数字。这个值不能是一个错误值(也就是说，0或者空字符串)。对于一个定义为ENUM('a','b','c')的列，诸如'','d',或'ax'是无效的会被拒绝。
  
  - SET的值必须是空字符串或是列定义时列出的值，并且用逗号分隔。对于一个定义为SET('a','b','c')的列，诸如'd',或'a,b,c,d'是无效的会被拒绝。
  
  非法值产生的错误在严格模式中可以通过INSERT IGNORE或UPDATE IGNORE来忽略。这样，会产生警告而不是错误。对于ENUM类型，插入的值是错误值(0)。对于SET类型，会插入给定值中除去非法子字符串之后的值。例如，'a,x,b,y'插入后的结果是'a,b'。
  
  
