# 1.8.5 MySQL与标准SQL的区别

###1.8.5 MySQL与标准SQL的区别
  
  我们尽量使MySQL服务器遵循ANSI SQL标准与ODBC SQL标准，但MySQL服务器在某些方面表现会有些不一样：
  
  + MySQL与标准SQL的权限系统有一些区别。例如，在MySQL中，删除一个表时表的权限并不是自动撤销的。你必须单独调用REVOKE语句来撤销某个表的权限。更多信息，参看[13.7.1.6 REVOKE语法][13.7.1]。
[13.7.1]:../Chapter_13/13.07.01_Account_Management_Statements.md

  + CAST()方法不支持转换成REAL或BIGINT类型。参看[12.10 转换方法与操作][12.10]。
[12.10]:../Chapter_12/12.10.00_Cast_Functions_and_Operators.md


####1.8.5.1 SELECT INTO TABLE 的区别

  MySQL不支持SELECT … INTO TABLE的塞贝斯SQL扩展。但是，MySQL支持INSERT INTO … SELECT标准SQL语法，这两者几乎是等价的。参看[13.2.5.1 INSERT … SELECT语法][13.2.5]。例如：
[13.2.5]:../Chapter_13/13.02.05_INSERT_Syntax.md

```sql
  INSERT INTO tbl_temp2 (fld_id) 
    SELECT tpl_temp1.fld_order_id
    FROM tbl_temp1 WHERE tbl_temp1.fld_order_id > 100;
```
  另一种选择，你也可以用SELECT … INTO OUTFILE 或 CREATE TABLE … SELECT。
  
  你可以在SELECT … INTO 中使用用户自定义的变量。同样的语法也可以通过游标与本地变量在内部存储过程中使用。参看[13.2.9.1 SELECT … INTO 语法]。 
  
####1.8.5.2 UPDATE的区别

  如果你在更新语句中访问了表中的某列，UPDATE会使用当前的值。在下面的语句中，第二个任务设置了col2为当前（更新后）的col1的值，而不是原来col1的值。这一点与标准SQL是不一样的。

```sql
  UPDATE t1 SET col1=col1 + 1, col2 = col1;
```

####1.8.5.3 事务与原子操作的区别

  MySQL服务器(3.23-max版本以及4.0及其以上版本)通过InnoDB事务存储引擎提供了对事务的支持。在MySQL 5.5及以上版本，新创建的表默认使用InnoDB引擎，这点在[14.2.1.1 InnoDB作为MySQL默认存储引擎][14.2.1]中进行了解释。默认的，InnoDB提供了完整的ACID支持，参看[14.2.8 MySQL及ACID模型][14.2.8]中提供的调整设置的方法，可以平衡ACID支持的原生性能。更多关于InnoDB与标准SQL的差别，以及处理事务错误的方法，参看[14.2.3.14 InnoDB错误处理][14.2.3]。
[14.2.1]:../Chapter_14/14.02.01_getting_started_with_innodb_tables.md
[14.2.8]:../Chapter_14/14.02.08_MySQL_and_the_ACID_Model.md
[14.2.3]:../Chapter_14/14.02.03_InnoDB_Concepts_and_Architecture.md

  MySQL服务器中的非事务引擎(例如MyISAM)为了确保数据完整性的默认范例称作“原子操作”。MyISAM表实际上可看做是一直运行在autocommit=1的模式中。因为每次一条语句的数据变化都会被写入到磁盘中，这就很难保证一系列相关DML操作的顺序的一致性，可能会在中途被打断。因此，这个模式对于经常处于读状态的任务是很合适的。在事务性操作中，每个更新操作是独立运行的，其他用户无法干涉，永远也不会有自动回滚，也不会有脏读。然而，这些特效都是针对单独操作的，而不是关于更新成功或失败的单元。变通的方式比如LOCK TABLES语句会限制对于非事务型表的并发写入请求。
  
  你可以选择使用何种范例，甚至在一个程序中可以针对不同的表：事务型的用来满足高性能并且可靠性要求较高的需求，或使用原子操作满足非关键性的，需要大量读取的数据(例如，在复制的从服务器上)。
  
  事务型的存储引擎比如InnoDB提供了许多有意义的特性来保证高读/写负荷下的可靠性。这也导致，事务型的表需要更多内存与磁盘空间，同时CPU占用率也更高。MySQL服务器的模块化设计使得可以同时使用不同的存储引擎来满足不同需求并且提供了最佳性能。
  
####保证非事务型表可靠性的一种方法

  然而，该采用哪些特性保证MySQL服务器中非事务型表诸如MyISAM表的完整性，这些特性与事务引擎又有哪些区别？
  
  - 如果你的程序在特定情况下实现的方式是通过ROLLBACK而不是COMMIT，那么用事务会更加方便。事务也能保证未完成的更新或是错误的操作不被提交到数据库中；服务器提供了原子级别的回滚，数据库的数据不会改变。
  
    如果采用的是非事务型表，你就必须在应用程序级别解决可靠性问题，通过在更新前进行检查，通过执行脚本来检测数据库的一致性，当不一致时要进行自动修复或是进行警告。通常你可以通过MySQL日志修复表从而保证数据的完整性，甚至也可以再加一个日志。
  
  - 有时候，临界的事务更新可以作为原子操作进行写入。多个DML操作可以通过LOCK TABLES完成或是作为原子更新，通过限制并发写入来保证没有死锁。如果获得一个表的READ LOCAK锁(相反的是写锁)，使得在表的末尾可以进行并发写入操作与读取，同时其他客户端也可以进行插入操作。新插入的记录不会被持有读锁的客户端访问到，直到它释放了锁。通过INSERT DELAYED，可以把数据插入到本地的一个队列中直到锁释放再写入，而客户端可以不用等到插入完成。参看[8.10.3 并发写入][8.10.3],[13.2.5.2 INSERT DELAYED语法][13.2.5]。
[8.10.3]:../Chapter_08/08.10.03_Concurrent_Inserts.md
[13.2.5]:../Chapter_13/13.02.05_INSERT_Syntax.md

  - 想要确保MySQL服务器的安全，不管你用的是什么类型的表，都要定期进行备份，并且开启二进制日志。经常备份是个好习惯，不管你用的是什么数据库系统。
  
    如下介绍了一些技术可以用在非事务型表上：
    
  - 需要使用事务的循环通常可以在代码中使用LOCK TABLES，并且你不需要游标匆匆忙忙的更新记录。
  
  - 想要避免使用ROLLBACK，可以使用如下的策略：
  
    1. 使用LOCK TABLES把所有你需要访问的表锁住。
    
    2. 更新前对条件进行测试确保为真。
    
    3. 当条件满足时再更新。
    
    4. 使用UNLOCK TABLES来释放锁。
    
	```
	  这个解决方案并不能处理在更新过程中有人把进程杀死的情况。在此种情况下，所有的锁都会被施放但是有些更新可能不会被执行。
	```
	
  - 你也可以通过函数来在一个操作中更新记录，通过如下的技术：
	
    + 基于与当前值来修改某列的值。这会使得更新总是正确的，即便有其他客户端同时更新了该列的值。
	  
    + 只更新那些确实发生了改变的列。通常这也是良好的数据库实践。
	  
  - 当处理不同的标识符时，可以通过使用AUTO_INCREMENT列或是LAST_INSERT_ID()这个SQL函数或是mysql_insert_id()这个C API函数来避免使用LOCK TABLES或是ROLLBACK语句。参看[12.14 信息函数][12.14]，以及[22.8.7.37 mysql_insert_id()][22.8.7]。
[12.14]:../Chpater_12/12.14.00_Information_Functions.md
[22.8.7]:../Chapter_22/22.08.07_C_API_Function_Descriptions.md

    对于需要进行低级锁定的情况，可以用InnoDB类型的表。另外，在MyISAM类型表中，可以通过增加标记列通过如下方式来完成：
    
	```sql
	  UPDATE tbl_name SET row_flag=1 WHERE id=ID
	```
  对于那些受影响的列MySQL会返回1，而其他列的row_flag值则不是1。你也可以把这个当做是在MySQL服务器中将之前的语句修改成这样：
	
	```sql
		UPDATE tbl_name SET row_flag=1 WHERE id=ID AND row_flag <> 1;
	```
	
####1.8.5.4外键的区别

  InnoDB存储引擎支持外键约束检查，包括CASCADE,ON DELETE,ON UPDATE。参看[5.4.5 InnoDB与FOREIGN KEY检查][5.4.5]。
[5.4.5]:../Chapter_05/05.04.05_InnoDB_and_FOREIGN_KEY_Constraints.md

  对于除InnoDB以外的存储引擎，MySQL服务器会解析在CREATE TABLE语句中的FOREIGN KEY语法，但是不会使用或是存储它。在将来，会通过扩展实现将这部分信息存储在表的描述文件中，这样mysqldump与ODBC就能获得这部分信息了。
  
  外键约束对于数据库开发者而言提供了如下便利：
  
  - 假定数据关系设计合理，外键约束能够使不一致性更难以被开发者引入到数据库中。
  
  - 数据库服务器对约束进行统一检查使得不需要在应用程序端进行检查了。这样消除了不同程序可能不会使用同一种方式进行约束检查的问题。
  
  - 使用联级更新与删除能简化应用程序的代码。
  
  - 正确设计外键规则能够使得各个表之间的关系更文档化。
  
    时刻记得，这些好处的代价是数据库服务器必须要运行一些必要的检查。服务器额外的检查会影响性能，对于有些程序可能会有不良影响需要尽可能避免。(一些主要的商业程序因为这一点儿在应用程序级别实现了外键的逻辑。)
	
  MySQL给了数据库开发者一个机会来选择使用那种方法。如果你不需要外键并且想避免对引用完整性检查带来的性能损失，可以选择其他引擎来代替，比如MyISAM。(例如，MyISAM存储引擎对于只需要INSERT和SELECT操作的应用程序能够提供非常高的性能。因此，数据表中没有碎片并且通过索引能够实现并发写入。参看[8.10.3 并发写入][8.10.3]。)
[8.10.3]:../Chapter_08/08.10.03_Concurrent_Inserts.md

  如果你选择不使用来源完整性检查，时刻记得这几点：
  
  - 服务器端不进行外键关系检查，程序自身就必须能够处理关系问题。例如，程序必须注意插入到表中的行顺序正确，同时避免插入孤儿记录。它还必须具有从多条插入操作产生的错误中恢复的能力。
  
  - 如果ON DELETE是这个程序唯一需要做的引用完整性检查，那么可以参考MySQL 4.0，通过使用多表的DELETE语句通过一条语句来从多个表中删除记录，从而实现相似的功能。参看[13.2.2 DELETE语法][13.2.2]。
[13.2.2]:../Chapter_13/13.02.02_DELETE_Syntax.md  
  
#####1.8.5.5注释起始符'--'

  标准SQL采用C格式的语法/* 这里面是注释 */来表示注释，MySQL服务器也支持这种语法。MySQL同时将这种语法进行了扩展，使得MySQL特有的SQL语句可以放在注释中执行，详情参看[9.6 注释语法][9.6]。
[9.6]:../Chapter_09/09.06.00_Comment_Syntax.md

  标准SQL用"--"来表示多行注释的开始。MySQL服务器使用"#"作为评论起始符号。MySQL 3.23.3及其更高版本也支持"--"作为评论标识符的一种变形形式。即，使用"--"作为一段评论的标识符号，其后必须跟一个空格(或是一个控制符比如换行符)。这个空格是为了防止使用如下语句自动生成的SQL查询语句出现问题，通常我们用这样的语句来给payment列添加相应的值：

	```sql
	  UPDATE account SET credit=credit-payment
	```

  考虑一下如果payment的值为负数比如-1:
  
	```sql
	  UPDATE account SET credit=credit--1
	```
	
  credit--1在SQL语句中是合法的，然而"--"作为注释的标识符将表达式打断了，语句的一部分被注释掉了。结果就是，语句的结果与期望的结果截然不同：
  
	```sql
	  UPDATE account SET credit=credit
	```
  
  语句运行的结果是根本没变化。举这个例子是想证明采用"--"来作为注释的标识符可能会带来严重的影响。
  
  在MySQL 3.23.3及更高版本的服务器软件中，我们的实现需要在"--"后边跟一个空格才能被作为一段评论的起始符号。因此，credit--1就可以安全使用了。
  
  另一个安全的特性是mysql命令行客户端会忽略以"--"开头的行。
  
  如下的信息只针对MySQL 3.23.3以及更高版本：
  
  如果你的SQL脚本保存在文本文件中并且其中包含了用"--"作为注释标识，那么在运行脚本之前应该用如下所示的replace工具将注释转换为以" #"作为标识符:
  
	```
	shell> replace " --" " #" < text-file-with-funny-comments.sql \ | mysql db_name
	```
  
  上边那样会比直接运行脚本更安全:
  
	```
	shell> mysql db_name < text-file-with-funny-comments.sql
	```
	
  你也可以把脚本文件中的"--"注释适当地转换为"#"注释：
  
	```
	shell> replace " --" " #" -- text-file-with-funny-comments.sql
	```
	
  可以用如下的语句转换回来：
  
	```
	shell> replace " #" " --" -- text-file-with-funny-comments.sql
	```
	
  参看[4.8.2 replace--一个字符串替换工具][4.8.2]。
[4.8.2]:../Chapter_04/04.08.02_replace_A_String-Replacement_Utility.md
   


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  